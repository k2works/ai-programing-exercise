# ADR-003: JWT認証による認証・認可戦略

ステートレスなJWT（JSON Web Token）認証システムの採用

日付: 2025-08-29

## ステータス

2025-08-29 採用されました

## コンテキスト

RESTful API中心の会議室予約システムにおいて、以下の認証・認可要件が存在する：

### 機能要件
- ユーザー認証（ログイン・ログアウト）
- APIエンドポイントの認可制御
- ユーザーロールベースアクセス制御（RBAC）
- 長期間ログイン状態の維持

### 非機能要件
- ステートレス設計（RESTful原則）
- 高いスケーラビリティ
- マイクロサービス対応
- セキュリティの確保

### 制約
- WebUI不使用（API-First）
- C#/.NET 8環境
- セッション管理の回避

## 決定

**JWT（JSON Web Token）ベースの認証・認可システムを採用する**

### 主要コンポーネント
1. **アクセストークン** - 短期間（15分）の認証トークン
2. **リフレッシュトークン** - 長期間（30日）の更新トークン
3. **クレームベース認可** - ロールと権限の制御

## 実装アプローチ

### JWT設定
```csharp
// appsettings.json
{
  "Jwt": {
    "SecretKey": "your-256-bit-secret-key-here",
    "Issuer": "MRS-API",
    "Audience": "MRS-Clients",
    "AccessTokenExpiration": 15,  // 分
    "RefreshTokenExpiration": 30  // 日
  }
}
```

### トークンプロバイダー実装
```csharp
public class JwtTokenProvider : ITokenProvider
{
    private readonly JwtOptions _options;

    public AuthResult GenerateTokens(User user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.Value.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Email, user.Email),
            new Claim(ClaimTypes.Role, user.Role.ToString()),
            new Claim("user_id", user.Id.Value.ToString()),
            new Claim("permissions", string.Join(",", user.GetPermissions()))
        };

        var accessToken = GenerateAccessToken(claims);
        var refreshToken = GenerateRefreshToken();

        return new AuthResult
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            ExpiresIn = _options.AccessTokenExpiration * 60,
            TokenType = "Bearer"
        };
    }

    private string GenerateAccessToken(IEnumerable<Claim> claims)
    {
        var key = Encoding.UTF8.GetBytes(_options.SecretKey);
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddMinutes(_options.AccessTokenExpiration),
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature),
            Issuer = _options.Issuer,
            Audience = _options.Audience
        };

        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

### 認証ミドルウェア
```csharp
public class JwtMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var token = ExtractTokenFromHeader(context.Request);
        
        if (token != null)
        {
            await AttachUserToContext(context, token);
        }

        await next(context);
    }

    private async Task AttachUserToContext(HttpContext context, string token)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_jwtOptions.SecretKey);
            
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _jwtOptions.Issuer,
                ValidateAudience = true,
                ValidAudience = _jwtOptions.Audience,
                ClockSkew = TimeSpan.Zero
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out _);
            context.User = principal;

            // ユーザー情報をHTTPコンテキストに添付
            var userId = principal.FindFirst("user_id")?.Value;
            if (userId != null)
            {
                context.Items["UserId"] = UserId.Of(Guid.Parse(userId));
            }
        }
        catch (SecurityTokenException)
        {
            // トークンが無効な場合は認証なしで続行
        }
    }
}
```

### 認可属性
```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class AuthorizeAttribute : Attribute, IAuthorizationFilter
{
    private readonly string[] _roles;

    public AuthorizeAttribute(params string[] roles)
    {
        _roles = roles ?? Array.Empty<string>();
    }

    public void OnAuthorization(AuthorizationFilterContext context)
    {
        var user = context.HttpContext.User;

        if (!user.Identity?.IsAuthenticated == true)
        {
            context.Result = new UnauthorizedResult();
            return;
        }

        if (_roles.Length > 0 && !_roles.Any(role => user.IsInRole(role)))
        {
            context.Result = new ForbidResult();
            return;
        }
    }
}
```

### API使用例
```csharp
[ApiController]
[Route("api/v1/[controller]")]
public class ReservationsController : BaseApiController
{
    [HttpPost]
    [Authorize] // 認証が必要
    public async Task<IActionResult> CreateReservation([FromBody] CreateReservationRequest request)
    {
        var userId = GetCurrentUserId(); // JWTから取得
        // ...
    }

    [HttpDelete("{id}")]
    [Authorize("ADMIN")] // 管理者権限が必要
    public async Task<IActionResult> DeleteAnyReservation(Guid id)
    {
        // ...
    }
}
```

## 影響

### 正の影響

1. **スケーラビリティ**
   - サーバーサイド状態の排除
   - 水平スケーリングの容易性
   - ロードバランシング対応

2. **セキュリティ**
   - トークンの有効期限制御
   - 署名による改ざん防止
   - クレームベース細粒度制御

3. **開発効率**
   - 標準化されたトークン形式
   - デバッグの容易性
   - マイクロサービス間での共有

### 負の影響・リスク

1. **セキュリティリスク**
   - トークン漏洩時の影響
   - リフレッシュトークン管理の複雑性
   - XSS攻撃によるトークン窃取

2. **運用上の課題**
   - トークンのライフサイクル管理
   - ログアウト処理の複雑性
   - 秘密鍵のローテーション

### リスク軽減策

1. **セキュリティ強化**
   ```csharp
   // 短いアクセストークン有効期限
   AccessTokenExpiration = 15, // 分
   
   // リフレッシュトークンの暗号化保存
   var encryptedRefreshToken = _encryptionService.Encrypt(refreshToken);
   ```

2. **ログアウト対応**
   ```csharp
   // ブラックリスト方式でのトークン無効化
   public async Task<Result> LogoutAsync(string token)
   {
       await _tokenBlacklistService.AddToBlacklistAsync(token);
       return Result.Success();
   }
   ```

3. **監査とロギング**
   ```csharp
   // 認証・認可イベントのログ記録
   _logger.LogInformation("User {UserId} authenticated successfully", userId);
   _logger.LogWarning("Unauthorized access attempt from {IP}", context.Connection.RemoteIpAddress);
   ```

## 代替案と比較

### Cookie-Based認証
**利点**: セッション管理の簡単さ
**欠点**: ステートフル、スケーラビリティの制限

### OAuth 2.0
**利点**: 業界標準、第三者認証
**欠点**: 実装の複雑性、外部依存

### Basic認証
**利点**: シンプルな実装
**欠点**: セキュリティの脆弱性、毎回認証

## コンプライアンス

### セキュリティ基準
- トークン有効期限：アクセス15分、リフレッシュ30日
- 暗号化：HMAC-SHA256以上
- 秘密鍵：256ビット以上

### 監査要件
```csharp
// 認証ログの記録
[Fact]
public void Should_Log_Authentication_Events()
{
    // 認証成功・失敗のログ記録検証
}
```

### パフォーマンス
- トークン検証：10ms以下
- トークン生成：50ms以下

## 備考

- **著者**: GitHub Copilot (AI Assistant)
- **影響範囲**: Infrastructure層（Security）、API層（認証・認可）
- **関連ADR**: 
  - ADR-001: ヘキサゴナルアーキテクチャ採用
  - ADR-004: テスト戦略
- **セキュリティレビュー**: 必要
- **実装参考**: 
  - RFC 7519 (JWT)
  - OWASP JWT Security Guidelines
