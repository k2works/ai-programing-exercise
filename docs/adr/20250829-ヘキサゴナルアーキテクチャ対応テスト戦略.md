# ADR-004: ヘキサゴナルアーキテクチャ対応テスト戦略

ポート&アダプターパターンに最適化されたテスト戦略の採用

日付: 2025-08-29

## ステータス

2025-08-29 採用されました

## コンテキスト

ヘキサゴナルアーキテクチャを採用した会議室予約システムにおいて、アーキテクチャの利点を最大限活用できるテスト戦略が必要：

### アーキテクチャ特性
- ドメインコアの外部依存なし
- プライマリー・セカンダリーポートによる明確な境界
- アダプターによる技術的実装の分離
- 依存性逆転原則の徹底

### テスト要件
- 高速で信頼性の高い単体テスト
- 外部システム統合の検証
- アーキテクチャ制約の自動検証
- 継続的インテグレーション対応

### 品質目標
- テストカバレッジ：ドメイン100%、アプリケーション95%
- テスト実行速度：単体テスト全体で30秒以内
- アーキテクチャ違反：0件

## 決定

**ヘキサゴナルアーキテクチャに特化したテストピラミッド戦略を採用する**

### テスト分類と責務

1. **ドメインテスト（Unit）** - ビジネスロジックの正確性
2. **ユースケーステスト（Unit with Mocks）** - アプリケーション調整の検証
3. **アダプターテスト（Integration）** - 外部システム連携の検証
4. **アーキテクチャテスト（Architecture）** - 設計制約の自動検証
5. **契約テスト（Contract）** - インターフェース仕様の整合性
6. **エンドツーエンドテスト（E2E）** - ユーザーシナリオの検証

## 実装アプローチ

### 1. ドメインテスト（最重要・最多）

**目的**: ビジネスルールの完全な検証

```csharp
namespace MRS.Domain.UnitTests.Models
{
    public class ReservationTests
    {
        [Theory]
        [InlineData("09:00", "17:00", false)] // 8時間は許可
        [InlineData("09:00", "18:00", true)]  // 8時間超過でエラー
        public void Constructor_Given_TimeSlot_Validates_Duration(
            string start, string end, bool shouldThrow)
        {
            // Arrange
            var userId = UserId.Of(Guid.NewGuid());
            var roomId = RoomId.Of(Guid.NewGuid());
            var date = DateOnly.Today;
            var timeSlot = TimeSlot.Create(start, end);

            // Act & Assert
            if (shouldThrow)
            {
                Assert.Throws<DomainException>(() => 
                    new Reservation(userId, roomId, date, timeSlot));
            }
            else
            {
                var reservation = new Reservation(userId, roomId, date, timeSlot);
                reservation.Should().NotBeNull();
            }
        }

        [Fact]
        public void OverlapsWith_Given_ConflictingTimeSlots_Returns_True()
        {
            // 純粋なドメインロジックテスト（外部依存なし）
            var reservation1 = CreateReservation("09:00", "10:00");
            var reservation2 = CreateReservation("09:30", "10:30");

            var result = reservation1.OverlapsWith(reservation2);

            result.Should().BeTrue();
        }
    }
}
```

### 2. ユースケーステスト（モック活用）

**目的**: ポート間の調整ロジック検証

```csharp
namespace MRS.Application.UnitTests.Services
{
    public class ReservationServiceTests
    {
        private readonly Mock<IReservationRepository> _mockReservationRepo;
        private readonly Mock<IRoomRepository> _mockRoomRepo;
        private readonly Mock<ICacheService> _mockCache;
        private readonly ReservationService _service;

        public ReservationServiceTests()
        {
            _mockReservationRepo = new Mock<IReservationRepository>();
            _mockRoomRepo = new Mock<IRoomRepository>();
            _mockCache = new Mock<ICacheService>();
            
            _service = new ReservationService(
                _mockReservationRepo.Object,
                _mockRoomRepo.Object,
                _mockCache.Object,
                Mock.Of<IUnitOfWork>(),
                new ReservationDomainService(),
                Mock.Of<IMapper>(),
                Mock.Of<ILogger<ReservationService>>());
        }

        [Fact]
        public async Task CreateReservationAsync_Given_ValidRequest_Calls_Repository()
        {
            // Arrange
            var command = new CreateReservationCommand(
                UserId.Of(Guid.NewGuid()),
                RoomId.Of(Guid.NewGuid()),
                DateOnly.Today.AddDays(1),
                "09:00", "10:00", "会議");

            _mockRoomRepo.Setup(x => x.GetByIdAsync(command.RoomId))
                .ReturnsAsync(new MeetingRoom(command.RoomId, "会議室A"));
            
            _mockReservationRepo.Setup(x => x.GetByRoomAndDateAsync(command.RoomId, command.Date))
                .ReturnsAsync(Enumerable.Empty<Reservation>());

            // Act
            var result = await _service.CreateReservationAsync(command);

            // Assert
            result.IsSuccess.Should().BeTrue();
            
            // セカンダリーポートが正しく呼ばれることを検証
            _mockReservationRepo.Verify(x => x.SaveAsync(It.IsAny<Reservation>()), Times.Once);
            _mockCache.Verify(x => x.RemovePatternAsync(It.IsAny<string>()), Times.Once);
        }
    }
}
```

### 3. アダプターテスト（統合テスト）

**目的**: 外部システム連携の実際の動作検証

```csharp
namespace MRS.Infrastructure.IntegrationTests.Adapters
{
    public class ReservationRepositoryTests : IClassFixture<DatabaseFixture>
    {
        private readonly DatabaseFixture _fixture;
        private readonly ReservationRepository _repository;

        [Fact]
        public async Task SaveAsync_Given_ValidReservation_Persists_To_Database()
        {
            // Arrange
            using var transaction = await _fixture.BeginTransactionAsync();
            
            var reservation = new Reservation(
                UserId.Of(Guid.NewGuid()),
                RoomId.Of(_fixture.SeedData.Room1.Id),
                DateOnly.Today.AddDays(1),
                TimeSlot.Create("09:00", "10:00"),
                "統合テスト");

            // Act
            await _repository.SaveAsync(reservation);
            var saved = await _repository.GetByIdAsync(reservation.Id);

            // Assert
            saved.Should().NotBeNull();
            saved.Purpose.Should().Be("統合テスト");
            saved.TimeSlot.StartTime.Should().Be(TimeOnly.Parse("09:00"));
        }

        [Fact]
        public async Task GetByRoomAndDateWithLockAsync_Prevents_Concurrent_Modifications()
        {
            // 悲観的ロックの動作を実際のDBで検証
            var roomId = RoomId.Of(_fixture.SeedData.Room1.Id);
            var date = DateOnly.Today.AddDays(1);

            var task1 = _repository.GetByRoomAndDateWithLockAsync(roomId, date);
            var task2 = _repository.GetByRoomAndDateWithLockAsync(roomId, date);

            // 同時実行時の制御を検証
            await Task.WhenAll(task1, task2);
        }
    }
}
```

### 4. アーキテクチャテスト（制約検証）

**目的**: ヘキサゴナル制約の自動検証

```csharp
namespace MRS.ArchitectureTests
{
    public class HexagonalArchitectureConstraintTests
    {
        [Fact]
        public void Domain_Should_Not_Reference_Any_External_Layer()
        {
            // ドメイン層の純粋性を検証
            var domainAssembly = typeof(Reservation).Assembly;
            
            var forbiddenReferences = new[]
            {
                "MRS.Application",
                "MRS.Infrastructure", 
                "MRS.Api",
                "Microsoft.EntityFrameworkCore",
                "System.Data.SqlClient",
                "Newtonsoft.Json"
            };

            var result = Types.InAssembly(domainAssembly)
                .Should()
                .NotHaveDependencyOnAny(forbiddenReferences);

            result.GetResult().IsSuccessful.Should().BeTrue(
                "ドメイン層は外部ライブラリに依存してはいけません");
        }

        [Fact]
        public void Application_Should_Only_Reference_Domain_And_System()
        {
            // アプリケーション層の依存関係を検証
            var applicationAssembly = typeof(ReservationService).Assembly;
            
            var allowedReferences = new[]
            {
                "MRS.Domain",
                "System",
                "Microsoft.Extensions",
                "AutoMapper",
                "FluentValidation"
            };

            var result = Types.InAssembly(applicationAssembly)
                .Should()
                .OnlyHaveDependenciesOn(allowedReferences);

            result.GetResult().IsSuccessful.Should().BeTrue();
        }

        [Fact]
        public void Controllers_Should_Only_Depend_On_Primary_Ports()
        {
            // プライマリーアダプターがプライマリーポートのみに依存
            var controllerTypes = Types.InAssembly(typeof(ReservationsController).Assembly)
                .That().ResideInNamespace("MRS.Api.Controllers");

            var result = controllerTypes
                .Should()
                .OnlyHaveDependenciesOn(
                    "MRS.Application.Ports",      // プライマリーポートのみ
                    "MRS.Application.DTOs",       // データ転送オブジェクト
                    "System",
                    "Microsoft.AspNetCore");

            result.GetResult().IsSuccessful.Should().BeTrue();
        }

        [Fact]
        public void Repositories_Should_Implement_Secondary_Ports()
        {
            // セカンダリーアダプターがセカンダリーポートを実装
            var repositoryTypes = Types.InAssembly(typeof(ReservationRepository).Assembly)
                .That().ResideInNamespace("MRS.Infrastructure.Adapters.Persistence");

            repositoryTypes.Should().ImplementInterface(typeof(IReservationRepository));
        }
    }
}
```

### 5. 契約テスト（API仕様検証）

**目的**: プライマリーポートの契約遵守検証

```csharp
namespace MRS.ContractTests
{
    public class ReservationApiContractTests
    {
        [Fact]
        public async Task POST_Reservations_Should_Match_OpenAPI_Schema()
        {
            var factory = new WebApplicationFactory<Program>();
            var client = factory.CreateClient();

            var request = new CreateReservationRequest
            {
                RoomId = Guid.NewGuid(),
                Date = DateTime.Today.AddDays(1),
                StartTime = "09:00",
                EndTime = "10:00",
                Purpose = "契約テスト"
            };

            // OpenAPI仕様と実装の整合性検証
            var response = await client.PostAsJsonAsync("/api/v1/reservations", request);
            var content = await response.Content.ReadAsStringAsync();
            
            // レスポンススキーマの検証
            var schema = await LoadOpenApiSchema("CreateReservationResponse");
            JsonSchema.IsValid(schema, content).Should().BeTrue();
        }
    }
}
```

### 6. エンドツーエンドテスト（シナリオ検証）

**目的**: ユーザーストーリーの実現検証

```csharp
namespace MRS.E2ETests
{
    public class ReservationWorkflowTests : IClassFixture<ApiTestFixture>
    {
        [Fact]
        public async Task User_Can_Create_And_Cancel_Reservation_Successfully()
        {
            var client = _fixture.CreateAuthenticatedClient("testuser@example.com");

            // 1. 利用可能な会議室を検索
            var roomsResponse = await client.GetAsync("/api/v1/rooms/available?date=2025-08-30");
            var rooms = await roomsResponse.Content.ReadFromJsonAsync<RoomResponse[]>();
            
            rooms.Should().NotBeEmpty();
            var targetRoom = rooms.First();

            // 2. 予約を作成
            var createRequest = new CreateReservationRequest
            {
                RoomId = targetRoom.Id,
                Date = DateTime.Parse("2025-08-30"),
                StartTime = "10:00",
                EndTime = "11:00",
                Purpose = "E2Eテスト会議"
            };

            var createResponse = await client.PostAsJsonAsync("/api/v1/reservations", createRequest);
            createResponse.StatusCode.Should().Be(HttpStatusCode.Created);
            
            var createdReservation = await createResponse.Content
                .ReadFromJsonAsync<ApiResponse<ReservationResponse>>();

            // 3. 予約一覧で確認
            var listResponse = await client.GetAsync("/api/v1/reservations/my");
            var reservations = await listResponse.Content
                .ReadFromJsonAsync<ApiResponse<ReservationResponse[]>>();
            
            reservations.Data.Should().Contain(r => r.Id == createdReservation.Data.Id);

            // 4. 予約をキャンセル
            var cancelResponse = await client.DeleteAsync($"/api/v1/reservations/{createdReservation.Data.Id}");
            cancelResponse.StatusCode.Should().Be(HttpStatusCode.OK);

            // 5. キャンセルの確認
            var checkResponse = await client.GetAsync($"/api/v1/reservations/{createdReservation.Data.Id}");
            checkResponse.StatusCode.Should().Be(HttpStatusCode.NotFound);
        }
    }
}
```

## テスト実行戦略

### 継続的インテグレーション

```yaml
# .github/workflows/test-strategy.yml
name: Hexagonal Architecture Test Strategy

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Domain Tests
        run: dotnet test tests/Unit/MRS.Domain.UnitTests/ --logger trx --collect:"XPlat Code Coverage"
      
      - name: Application Tests  
        run: dotnet test tests/Unit/MRS.Application.UnitTests/ --logger trx --collect:"XPlat Code Coverage"

  architecture-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Architecture Constraints
        run: dotnet test tests/Architecture/ --logger trx
        
  integration-tests:
    runs-on: ubuntu-latest
    services:
      sqlserver:
        image: mcr.microsoft.com/mssql/server:2022-latest
        env:
          SA_PASSWORD: YourStrong@Passw0rd
    steps:
      - name: Infrastructure Integration Tests
        run: dotnet test tests/Integration/ --logger trx
        
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - name: End-to-End Scenarios
        run: dotnet test tests/E2E/ --logger trx
```

### テストカバレッジ目標

| 層 | カバレッジ目標 | 理由 |
|---|---|---|
| ドメイン層 | 100% | ビジネスロジックの完全性 |
| アプリケーション層 | 95% | ユースケースの網羅性 |
| インフラストラクチャ層 | 80% | 技術実装の検証 |
| API層 | 90% | エンドポイントの信頼性 |

## 影響

### 正の影響

1. **品質の大幅向上**
   - バグの早期発見と修正
   - リグレッションの防止
   - アーキテクチャ違反の自動検出

2. **開発効率の向上**
   - 安全なリファクタリング
   - 高速なフィードバックループ
   - ドキュメントとしてのテスト

3. **保守性の向上**
   - 意図の明確化
   - 変更影響範囲の特定
   - 技術的負債の軽減

### 実装コスト

1. **初期投資**
   - テストフレームワーク設定
   - テストデータ管理基盤
   - CI/CDパイプライン構築

2. **継続コスト**
   - テストコードの保守
   - テスト環境の運用
   - 開発者の学習コスト

## コンプライアンス

### 品質ゲート
```csharp
// 品質基準の自動検証
[Fact]
public void All_Tests_Should_Meet_Quality_Standards()
{
    var domainCoverage = GetCodeCoverage("MRS.Domain");
    var applicationCoverage = GetCodeCoverage("MRS.Application");
    
    domainCoverage.Should().BeGreaterOrEqualTo(100);
    applicationCoverage.Should().BeGreaterOrEqualTo(95);
}
```

### パフォーマンス基準
- 単体テスト全体：30秒以内
- 統合テスト全体：5分以内
- E2Eテスト全体：15分以内

## 備考

- **著者**: GitHub Copilot (AI Assistant)
- **影響範囲**: 全プロジェクト（テスト戦略）
- **関連ADR**: 
  - ADR-001: ヘキサゴナルアーキテクチャ採用
  - ADR-002: Dapper採用データアクセス戦略
  - ADR-003: JWT認証戦略
- **実装優先度**: 高（アーキテクチャの価値実現に必須）
- **レビュー頻度**: 四半期ごと
