# ADR-002: Dapper採用によるデータアクセス戦略

Entity FrameworkではなくDapperを採用したデータアクセス戦略

日付: 2025-08-29

## ステータス

2025-08-29 採用されました

## コンテキスト

会議室予約システムにおけるデータアクセス技術選択で、以下の候補が検討された：

### 候補技術
1. **Entity Framework Core** - Microsoft公式O/Rマッパー
2. **Dapper** - 軽量O/Rマッパー
3. **ADO.NET** - 生SQL実行

### 要件
- 高いパフォーマンス（同時予約処理）
- 予約競合制御（楽観的・悲観的ロック）
- 複雑なクエリ実行能力
- ヘキサゴナルアーキテクチャとの親和性
- 開発・保守効率

## 決定

**Dapperを採用し、以下の戦略でデータアクセス層を実装する**

### 採用理由

1. **パフォーマンス優位性**
   ```csharp
   // Dapper - 軽量で高速
   var reservations = await connection.QueryAsync<Reservation>(sql, parameters);
   
   // vs Entity Framework - 重厚で機能豊富だが低速
   var reservations = await context.Reservations.Where(r => ...).ToListAsync();
   ```

2. **SQL制御の柔軟性**
   ```sql
   -- 悲観的ロックによる予約競合制御
   SELECT * FROM reservations 
   WHERE room_id = @RoomId AND reserved_date = @Date
   WITH (UPDLOCK, HOLDLOCK)
   ```

3. **ヘキサゴナルアーキテクチャ適合性**
   - リポジトリパターンの自然な実装
   - ドメインモデルとデータモデルの分離
   - セカンダリーアダプターとしての明確な位置づけ

4. **学習コストの低さ**
   - SQLスキルの直接活用
   - EFのような抽象化による複雑性回避

## 実装アプローチ

### リポジトリ実装例
```csharp
public class ReservationRepository : IReservationRepository
{
    private readonly IConnectionFactory _connectionFactory;

    public async Task<IEnumerable<Reservation>> GetByRoomAndDateWithLockAsync(
        RoomId roomId, DateOnly date)
    {
        using var connection = await _connectionFactory.CreateConnectionAsync();
        
        var results = await connection.QueryAsync<dynamic>(
            ReservationQueries.GetByRoomAndDateWithLock,
            new { RoomId = roomId.Value, Date = date });

        return results.Select(MapToReservation);
    }
}
```

### SQL管理戦略
```csharp
public static class ReservationQueries
{
    public const string GetByRoomAndDateWithLock = @"
        SELECT reservation_id, user_id, room_id, reserved_date, 
               start_time, end_time, purpose, created_at
        FROM reservations 
        WHERE room_id = @RoomId AND reserved_date = @Date
        WITH (UPDLOCK, HOLDLOCK)
        ORDER BY start_time";
}
```

## 影響

### 正の影響

1. **パフォーマンス向上**
   - 軽量な実行時オーバーヘッド
   - 最適化されたSQL実行
   - メモリ使用量の削減

2. **制御の柔軟性**
   - 複雑なクエリの直接記述
   - データベース固有機能の活用
   - パフォーマンスチューニングの容易さ

3. **アーキテクチャ適合性**
   - 依存性逆転原則の自然な実装
   - テスタビリティの向上
   - ドメインモデルの純粋性保持

### 負の影響・リスク

1. **開発効率の課題**
   - SQL手書きによる工数増加
   - タイプセーフティの部分的欠如
   - マイグレーション管理の手動化

2. **保守性の懸念**
   - SQLとC#コードの分散管理
   - データベーススキーマ変更の影響
   - 複雑なオブジェクトマッピング

### リスク軽減策

1. **SQL管理の体系化**
   ```csharp
   // 静的クラスによるSQL集約管理
   public static class ReservationQueries
   {
       public const string Insert = "...";
       public const string Update = "..."; 
       public const string Delete = "...";
   }
   ```

2. **強力なテスト戦略**
   ```csharp
   [Fact]
   public async Task SaveAsync_Given_ValidReservation_Persists_Successfully()
   {
       // 統合テストによるSQL検証
   }
   ```

3. **マイグレーション管理**
   ```sql
   -- scripts/migrations/001_initial_schema.sql
   CREATE TABLE reservations (
       reservation_id uniqueidentifier PRIMARY KEY,
       -- ...
   );
   ```

## 代替案と比較

### Entity Framework Core
**利点**: 
- 高い開発効率
- 強いタイプセーフティ
- LINQ to Entities

**欠点**: 
- パフォーマンスオーバーヘッド
- 複雑なクエリの制限
- ヘキサゴナルアーキテクチャとの摩擦

### ADO.NET
**利点**: 
- 最高のパフォーマンス
- 完全なSQL制御

**欠点**: 
- 大量のボイラープレートコード
- オブジェクトマッピングの手動実装
- 開発効率の大幅低下

## コンプライアンス

### 性能基準
- 予約作成：500ms以下
- 予約検索：200ms以下
- 同時ユーザー：100人以上

### テストカバレッジ
- リポジトリ実装：90%以上
- SQL統合テスト：全クエリ対象

### コード品質
```csharp
// サイクロマティック複雑度制御
public async Task<Reservation> MapToReservation(dynamic row)
{
    // 複雑度7以下を維持
}
```

## 備考

- **著者**: GitHub Copilot (AI Assistant)
- **影響範囲**: Infrastructure層、テスト戦略
- **関連ADR**: 
  - ADR-001: ヘキサゴナルアーキテクチャ採用
  - ADR-004: テスト戦略
- **実装参考**:
  - docs/design/アプリケーション構成.md
  - docs/reference/会議室予約システムのケーススタディ/実装詳細.md
