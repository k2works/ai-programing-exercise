---
title: 骨までしゃぶりつくす「ぷよぷよプログラミング」(1/4) 
tags: ぷよぷよプログラミング JavaScript HTML5
author: KennyKTA
slide: false
---
# 後続記事へのインデックス

https://qiita.com/KennyKTA/items/b70422c28fa986b52bbe

https://qiita.com/KennyKTA/items/d9383cacb180096261ef

https://qiita.com/KennyKTA/items/cab4905a01bd1ff4b626

# 背景

世の中には情報システムを構築するための教材があふれていて、何から手を付ければいいかわからない人も多いと思います。筆者もそのような一人で、何を題材にし、自分のエンジニアリングの核を形成しようかと常に悩んでいます。ちなみにプログラミングの力量を示す一つの指標としてコンテストサイトの実力がありますが、筆者はAtCoderでは茶色であり、アルゴリズム的な観点でみれば駆け出しエンジニアと言っても差し支えないレベルです。全くの素人ではないものの、様々な分野で中途半端な力量だなと感じることが多く再勉強を試みてはその度に焦燥感を感じています。
　そんな中、目を付けたたのが「[ぷよぷよプログラミング](https://puyo.sega.jp/program_2020)」です。詳細な説明はオフィシャルに譲りますが、「小さなころから慣れ親しんだゲームであるぷよぷよを作れる！」というモチベーションを刺激されました。この教材の概要はjavascript と html を用いてブラウザで上で動作するゲームを実装するというものであり、インフラではなくWebフロント寄りの学習教材です。一方で私のキャリアはWebフロント開発がほぼ白紙の状態で、流行りのTypesScriptやReactなどに触れてみたいなと目移りしている最中でした。しかしながら少し調べてみるとTypeScript もReact もjavascript やhtml を基礎としたものであり、この教材を始点として学習すれば基礎を鍛えられるので、長い目で見て有用だろうと考えて学習に踏み切りました。

# 目的
　これから記述していく一連の記事の目的は大きく４つです。

- 目的1.「ぷよぷよプログラミング」で作成していく範囲のソースコードから javascript と html の技術を学んでいく
- 目的2.「ぷよぷよプログラミング」のソースコードを理解することで、その仕様や設計を推測してドキュメント化する
- 目的3. Markdown 記法での文書作成に慣れる
- 目的4.「ぷよぷよプログラミング」に独自の機能追加を実施してみる

目的1 に関しては、限定的な学習範囲となるため網羅的/体系的な理解はできないでしょう。ただし、学習の皮切りとしては最終成果物の目的がはっきりしていることもあり記憶に残りやすいと思っています。
　目的2 に関しては、開発現場にありがちなソースコードがあってもドキュメント類が少なく仕様や設計がわからない状態を想定しています。こういったケースではソースコードから仕様や設計をくみ取る必要があり、開発領域を問わず求められやすいエンジニアリング能力です。「ぷよぷよプログラミング」ではソースコードが与えられており、他の情報は無いに等しいため似たような状況です。言語や開発対象に応じてソースコードから拾うべき概念は異なるため、トレーニングの一環として実施しようと思います。そしてこれは自己満足ですが、これから「ぷよぷよプログラミング」に着手する方たちの参考資料になることを期待しています。
　目的3 に関しては、記述している通りで文書を書くことに慣れようと思います。
　目的4 に関しては、アドバンスな内容として用意しています。教材の外に飛び出して何か活動したいという宣言に近いもので、実現できるかは執筆時にはわかっていません。

目的の順番は私にとっての重要度の順ですが、記事作成の便宜を考慮すると目的2, 1 （,4）の順番で執筆を行うことになります。2に関しては for 文や if 文といった制御構文や変数宣言などの説明は行わず、私にとって重要だなと思った技術に関して言及するにとどめます。

# 事前準備
さて「ぷよぷよプログラミング」公式では気合による写経が課せられているわけですが、単にプログラムを打ち込むだけでは上記の目的は達成できません。そこでMDN Web Docsの入門文書を確認することにしました。それぞれの文法や用法を深く読み込むというよりは、HTML,CSS,Javascript がどのように相互作用するかを簡単に確認しました。

- [ウェブ入門](https://developer.mozilla.org/ja/docs/Learn/Getting_started_with_the_web)
- [HTMLの基本](https://developer.mozilla.org/ja/docs/Learn/Getting_started_with_the_web/HTML_basics)
- [CSSの基本](https://developer.mozilla.org/ja/docs/Learn/Getting_started_with_the_web/CSS_basics)
- [JavaScript](https://developer.mozilla.org/ja/docs/Learn/JavaScript)

また、上位にプラスして書籍を一冊読みました。[「ステップアップJavascript　フロント電度開発の初級から中級へ進むために」](https://www.shoeisha.co.jp/book/detail/9784798169835)という本です。知識を補うには良いと思いました。「ぷよぷよプログラミング」は各種の計算や状態管理などのゲームを構築するための要素がつまっています。その一方で、通信（書籍内ではAJAX）、パッケージ管理を含む開発環境そのもの（書籍内ではNode.jsとnpm）、Javascript 圏特有のトランスパイルなどに触れることができません。本来私が書籍を手に取った理由は、this とスコープを理解するためだったのですが、読みやすかったので通しで読んで上記のような内容も取り込むことができました。ただし、for 文やif 文などの制御構文が理解できていない人にとっては難しいと思いますので、より入門レベルに近い書籍を読むのをお勧めします。

#最後に
　次回以降の記事で「ぷよぷよプログラミング」そのものに関して目的にそって言及していきたいと思います。以降の記事はある程度かけた段階で公開して、都度アップデートしていくかもしれません。
　念のためにですが、「ぷよぷよプログラミング」は改変や非商用利用においてのみの公開が認められているものの、基本的には商用利用できません。着手される方はいきなり突っ走らず、「ぷよぷよプログラミング」著作物利用許諾所を一読する必要があります。

この記事は未完成です@2022/02/15
大まかに使用の要点は記述できたのでfixとします。@2022/02/19

# この記事の目的
この記事では[前回記事](https://qiita.com/KennyKTA/items/360aa62aa7f7ba084a2f)の

- 目的2.「ぷよぷよプログラミング」のソースコードを理解することで、その仕様や設計を推測してドキュメント化する

に沿ってソースコードを読み込んだ結果をできるだけ仕様、設計に復元しようと思います。

# 前置き
「ぷよぷよ」は日本ではかなりの市民権を得ているゲームで、そのルールを知らない人はあまりいないと思います。ですので、ゲームとしてのルールはある程度知っている前提で、そのゲームをWebアプリとして動作させるために必要な仕様や設計をソースコードから書き起こします。下記を一読してからソースコードを読むと、何を実現しようとしているか理解しやすくなると思われます。以下は厳密な仕様を規定するわけではなく、ソースコードの理解を促す目的のドキュメントだと捉えてください。

# 仕様

## 状態遷移仕様
game.js から抽出したゲームの状態遷移図が以下です。楕円が状態を表現します。ゲームは開始状態(Start）から始まり、終了状態（batankyu）へ移行するまでループします。この状態を約1/60秒毎（ディスプレイのリフレッシュレート）に更新することでゲームが動きます。状態遷移図をよく見てみると<font color="Red">newPuyo</font>が中心的な存在に見えます。名前からわかる通り、新しいぷよぷよを発生させる処理が紐づいているのですが、ぷよぷよが発生することで操作対象が生まれて playing できますし、詰みの状態であれば gameOver になりますし、連鎖後には新しいぷよぷよを発生させる必要があるので線が出入りしているわけです。大雑把にみると<font color="MediumSeaGreen">緑点線（プレイヤーが介入しない）</font>、黒点線（プレイヤーが介入する）、<font color="Red">赤点線（終了処理）</font>で系統をくくれるように見えます。ゲーム自体の挙動を体感したことがあっても、プログラミングする前にはこのような遷移図があると作製対象への理解が高まります。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/0c9e43ab-740e-642c-a025-9504f7777f7f.png)

## 画面仕様
このぷよぷよは、右方向を正としたX軸、下方向を正としたY軸でゲーム内の論理的な位置を表現します。デフォルトでは横６マス、縦１２マスのエリアでプレイが可能です。図にすると以下のようになります。薄く着色している部分でプレーすることになります。この範囲は、コンフィギュレーション可能です。また、デフォルトではぷよぷよは左から3列目（ソース内のコメントでは2列目とあるが、そのまま実装すると3列目になります）のマイナス位置で発生します。後述しますが、ぷよぷよは中心ぷよ（centralPuyo）と可動ぷよ（movablePuyo）で構成されます。可動ぷよは中心ぷよの論理的な位置を基準として回転します。ぷよぷよのデフォルト発生位置は<font color="DarkMagenta">図中紫が中心ぷよ</font>、<font color="MediumSeaGreen">黄緑が可動ぷよ</font>です。
　

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/b28d0635-4075-832a-23ee-9cf05ea5af87.png)

## 操作仕様
###プレイヤーの入力
　プレイヤーはぷよぷよを操作することができます。ゲームの状態に応じて可能な操作が変わります。

batankyuの場合

- キーボードの上矢印でページをリロードして新しいゲームを再開する

それ以外の場合

- キーボードの左矢印で中心ぷよの位置を１つ左に動かす
- キーボードの右矢印で中心ぷよの位置を１つ右に動かす
- キーボードの上矢印で可動ぷよの位置を反時計回りに９０度動かす
- キーボードの下矢印でぷよぷよの落下速度を上げる

です。

###可動ぷよの回転仕様
中心ぷよの位置に対して特定位置に床、壁、積まれたぷよぷよが存在すると可動ぷよの回転によって中心ぷよの位置に影響を及ぼします。可動ぷよの移動前の位置に応じて仕様を記述します。

- 可動ぷよが中心ぷよの右にある場合

この場合は何も注意することはなく、可動ぷよが中心ぷよの上に移動します。図にすると以下のようになります。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/c23b2d46-2f5b-b7f1-bf49-c2b3f5e2a238.png)

- 可動ぷよが中心ぷよの上にある場合

中心ぷよの左隣に壁もしくは積まれたぷよぷよが存在すると中心ぷよの位置が右に一つずれて回転します。図にすると以下のようになります。この挙動が実現できない場合、つまり中心ぷよの右隣に壁もしくは積まれたぷよが存在する場合は回転はできません。それ以外は可動ぷよが中心ぷよの左に移動します。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/4813692f-c9b2-9a08-b69b-72ee01458f2d.png)


- 可動ぷよが中心ぷよの左にある場合
  中心ぷよの真下もしくは左下に床もしくは積まれたぷよぷよが存在すると中心ぷよの位置が上に一つずれて回転します。図にすると以下のようになります。

真下の場合
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/e32f6977-b353-3f59-b340-eebf7e8b7788.png)
左下の場合
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/84f2e1c2-d9d2-dd4b-8183-082f0821a653.png)



- 可動ぷよが中心ぷよの下にある場合

中心ぷよの右隣に壁もしくは積まれたぷよぷよが存在すると中心ぷよの位置が左に一つずれて回転します。図にすると以下のようになります。この挙動が実現できない場合、つまり中心ぷよの左隣に壁もしくは積まれたぷよが存在する場合は回転はできません。それ以外は可動ぷよが中心ぷよの右に移動します。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/626166/dfc419f4-bcf1-85b8-a6fb-b4537d174f44.png)


パターンは上述の通りです。何気なく操作しているぷよぷよですが、その動きを文書化してみるとこういったケースに分類できるんですね。ぷよぷよプログラミングでは逆回りの回転は仕様に無いので追加で実装してみるのも面白いかもしれません。

## 落下の仕様
ぷよぷよの自由落下はデフォルトでは1/60秒毎に16pxずつ落下していきます。また、設置の閾値は20フレーム（つまり1/3秒）です。

## 全消しに関して
積まれたぷよぷよがある状態ですべてのぷよぷよが消された場合、全消しと判定します。全消しした場合は全消しのイラストが画面下から中央に登場します。登場したイラストは次回ぷよぷよを消すまで表示されます。

## バタンキューに関して
ゲームオーバーになるとバタンキューのイラストが表示されます。ページがリロードされるまで左右に揺れながらページを上下します。

# 得点の仕様に関して

- 全消し:3600点
- 下キー入力による加速:1点/1論理位置
- ぷよぷを消したことによる得点

計算式
スコア= スケール×消したぷよの数×10
スケール = 連鎖ボーナス+ 消した数のボーナス + 消した色の数のボーナス
連鎖ボーナス=Score.rensaBonusに格納されている値から選ばれる。連鎖数が配列のインデックスとなる。
消した数のボーナス=Score.pieceBonusに格納されている値から選ばれる。連鎖の各回で消したぷよぷよの数が配列のインデックスとなる。
消した色の数のボーナス=Score.colorBonusに格納されている値から選ばれる。連鎖の各回で消したぷよぷよの色の数が配列のインデックスとなる。

例として連鎖ごとに１色、４ぷよぷよを消して３連鎖した場合を考えると

1連鎖目：スケール = 8 + 2 + 0 = 10、スコア=10×4×10 = 400
2連鎖目：スケール = 16+ 2 + 0 = 10、スコア=18×4×10 = 720
3連鎖目：スケール = 32+ 2 + 0 = 10、スコア=34×4×10 = 1360

合計点=400+720+1360=2480

となる。

## 最後に
ＧＵＩ系統の仕様記述があまいが、このあたりで仕様の記述はとめる。

次回

https://qiita.com/KennyKTA/items/d9383cacb180096261ef

# この記事の目的
この記事では[前々回記事](https://qiita.com/KennyKTA/items/360aa62aa7f7ba084a2f)の

- 目的1.「ぷよぷよプログラミング」で作成していく範囲のソースコードから javascript と html の技術を学んでいく

に沿ってソースコードを読み込んだ結果を記述しようと思います。記載する項目は私が学びがあったと感じたものだけで、すべての文法などを解説するものではありませんん。下に言及する項目の一覧を示します。

1. HTML
    - 全般
    - `<div style="display:none">`

1. Javascript ( ECMA Script )
    - 全般
    - クラスと静的プロパティ／静的メソッドと this
    - return の仕様
    - 定義されていない配列要素へのアクセス
    - オペランド ||
    - オペランド &&
    - キーコード

1. Document Object Model ( DOM )
    - 全般


# 前置き
この記事はjavascriptに関しての入門者が書くので正確性を欠く場合があります。

# HTML

## 全般
実はぷよぷよプログラミングではHTMLのコード量は多くなく、たった45行です。HTMLの仕様[WHATWG](https://html.spec.whatwg.org/multipage/)から確認できます。

## `<div style="display:none>`
私が唯一なるほどなと感じたのは`<div style="display:none>`によるHTML要素の非表示です。このdivで囲まれたコード領域はDOMを介して操作できる状態にはあるものの、表示されなくなります。この非表示の要素をjavascriptからdocument.getElementByIdなどを利用して取得し、動的に位置などのプロパティを操作した後に、appendChildを通してブラウザに伝えることでぷよぷよの位置表示を実現しています。

# Javascript
## 全般
Javascript の仕様は[ECMA Script の仕様](https://tc39.es/ecma262/) として定義されています。しかし、現状私は読んでも上手く理解できません。できればこういった一次情報から理解したいですが難しそうなので、しばらくはかみ砕いて技術紹介しているブログ等を読むことになると思います。

## クラスと静的プロパティ／静的メソッドと this
私が今回ソースコードを読み進めるにあたって最初に混乱したのがこの項目です。JavaScript にはオブジェクト指向の class を定義する文法があるのですが、class 内で定義した静的メソッドや静的プロパティを理解するのに少し時間を要しました。余談ですが、JavaScriptのclassは歴史的な拡張を経て用意されたシンタックスシュガーであり、プロトタイプと呼ばれる構文を簡易的に記述できる文法のようです。筆者もこのあたりの技術の関係性は執筆時点で詳しく理解していません。今回の「ぷよぷよプログラミング」を理解するために必要な情報だけ調べています。
　「ぷよぷよプログラミング」で定義する class はインスタンス化せずに class に定義された静的メソッド／静的プロパティを参照する形で利用されます。そういう意味では、ここでの class 定義はオブジェクト指向的な意味を持たず、処理概念の纏まりや命名規則程度の意味しか持ちません。
　さて、本題に話を移します。まず静的メソッドに関してですが class 内で static を文頭に付与したメソッドはインスタンス化したオブジェクトに属するものでなく、class そのものに割り振られます。したがって class名.静的メソッド名() のようにして呼び出すことができます。例にすると下記のようになります。

```static_method.js
class SampleClass{
    static sample_method(){
        console.log("hello static method");
    }
}

SampleClass.sample_method();
```

「ぷよぷよプログラミング」ではこの静的メソッド内にthisを使った変数が登場します。これらの変数はクラス定義の最初にコメントアウトで静的変数だと書かれているのですが、なぜこれでクラスの外側からアクセスできるのか、しっくりきませんでした。インスタンス化する前提であれば当該オブジェクト内の変数である、というイメージがあったのですがsatatic_property.js のように書いた場合にはthis が指し示すオブジェクトはSampleClassそのものであるという認識が落ちていたからです。（コード内のコメントアウトを動作するように変更しても問題ありません。）

```static_property.js
class SampleClass {
    // static sample_property;
    static sample_method(){
        this.sample_property = "toto";
        console.log(this.sample_property);
    }
}

SampleClass.sample_method();
```

私にとっては[ここのページ](https://ja.javascript.info/static-properties-methods)が理解の補助となりました。上記を読んでみるとわかるように静的メソッドを定義するのは、関数プロパティを定義することに等しいようです。この説明を頭に入れておくと、幾分かスムーズに理解できるようになりました。

## return
return を利用すると関数に返り値を持たせることができるのですが、単純にreturn した場合に何が返るのかがわかりませんでした。結論 undefined が返されます。

```return.js
function ret(){return;}
const v = ret();
console.log(v);
```
上記の結果はundefinedとなります。return がundefined を投げる仕様もすべてを把握できていませんが、[このあたりが](https://teratail.com/questions/53696) 参考になります。一方で言語に対する正確な理解はECMA Script を読み込む必要があると感じています。「[13.10 The return Statement](https://262.ecma-international.org/11.0/#sec-return-statement)」あたりを読むといいのだと推測しているのですが、記号の意味がわからず解読できていません…

## 定義されていない配列要素へのアクセス
突然ですが下記のarray_access.pyはどのように動作するでしょうか？2行目が特に気持ち悪いですね。liは3要素の配列なので、li[3]はインデックスの範囲を超えています。

```array_access.py
const li=[1,2,3];
const li4=li[3];
console.log(li4);
```
結論、このコードは動作します。li[3] の部分はundefined を返して、コンソールにはundefined が表示されます。私はこの仕様を知らずにstage.js の50,52行目で困りました。というのもConfig.stageRows で Config.stageCols でステージのサイズを変更できるのですが、その前段のthis.board には固定サイズの配列しか用意されていないためインデックスサイズを超えたアクセスが実行されてしまうのです。定義していない領域にもアクセス可能で、それを前提にコーディングできるのは別言語での経験を持っていると少しとっつきにくかったです。

## オペランド ||
もちろん、論理和を表すのですが…

```operand.js
exp1 || exp2
```
と記述し、exp1 がtrue に変換可能な場合はexp1を返して、それ以外はexp2を返します。stage.js の50行目で利用されている書き方で初見では何をやろうとしているのか何となくわかるものの、少し気持ちが悪かったです。[ここを参照](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Logical_OR)すると理解できます。

さて、この記述からわかる通り、このオペランドが返すものはtrue/false とは限りません。下記のコードはundefined がコンソール出力されますし、

```operand_undefined.js
console.log(undefined || undefined);　
```

下記はfugaがコンソール出力されます。

```operand_string.js
console.log(false||'fuga');
```

## オペランド &&
オペランド|| と同じように&&も他の言語とは一風変わった動作に感じます。exp1 がtrue に変換可能な場合はexp2を返して、それ以外はexp1を返します。
|| と同じように以下のコードはundefinedを返します。trule/falseを必ず返すとは限らないことを念頭に置いておく必要があります。

```operand_undefined.js
console.log(undefined || undefined);　
```

下記はfugaがコンソール出力されます。

```operand_string.js
console.log(true&&'fuga');
```

## キーコード
キーボードからの入力に対するコードが存在します（[参照](http://faq.creasus.net/04/0131/CharCode.html)）。アスキーコードとは別物です。player.jsの27～43行目あたりで登場します。
また、矢印キー入力に対してのデフォルトイベント処理を打ち消すためにpreventDefault() と呼ばれるメソッドがコールされています。[こちらの記事](https://qiita.com/tochiji/items/4e9e64cabc0a1cd7a1ae) にわかりやすくまとめてありました。矢印操作はブラウザにとってスクロールバーを操作するデフォルトの機能を持つため、これを打ち消すために必要なのだと理解しました。

# Document Object model
HTMLとCSSをブラウザが解釈して、その状態を保持するのですがJavaScriptを介して動的にその状態を操作することができます。その際に利用するAPIのことをDOMと呼びます。DOMはJavaScriptから利用する機能なのでECMAの仕様に規定があるのかと思っていたのですが、どうやら分離された状態で管理されています([参照](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Introduction))。仕様はW3Cが規定しており、[このあたり](https://www.w3.org/TR/WD-DOM/introduction.html)から読み込んでいくといいのかなと思っています。
少しググると[APIを検索できるサービス](https://devdocs.io/dom/)があったのでこういったものを参照しながら学習するのがいいのかなと思いました。

## ぷよぷよプログラミングで利用するDOM API
各APIの仕様は上記のAPIを検索できるサービスを調べればわかるのでそちらに譲ります。ここではこれらがわかっていれば、ぷよぷよプログラミングが少なくともDOMの観点では理解できるという意味でリストを提示しておきます。

- getElementById
- addEventListener
- requestAnimationFrame
- cloneNode
- appendChild
- addEventListener
- preventDefault
- removeChild
- remove
- requestAnimationFrame
- insertBefore

# 最後に

次回

https://qiita.com/KennyKTA/items/cab4905a01bd1ff4b626

# この記事の目的
この記事ではソースコードを読んで冗長そうであったり、間違いがあるのではないか、と感じた点を記述していきます。初回に述べた目的の内容からは外れた番外編的な内容となります。

初回

https://qiita.com/KennyKTA/items/360aa62aa7f7ba084a2f


## おそらく不要なコード

```pyuyoimage.js
this.batankyuImage.style.top = -this.batankyuImage.height + 'px';
```
目的はthis.batankyuImage.style.topの初期化に見えるのですが、this.batankyuImage.heightがundefinedです。実行時はundefinedが適当な数値となって動作はするようです。

ちなみに後のコードで

```puyoimage.js
this.batankyuImage.style.top = y + 'px';
```

とあり、ここで正常な値が上書きされる形でプログラムの動作が担保されているように見えます。

## おそらく間違えているコメント

```player.js
x: 2, // 中心ぷよの位置: 左から2列目
```

実際に動作させてみると、左から３列目から中心ぷよは登場します。配列上のインデックス（もしくは当該中心ぷよのleft）が2なのでコメントとしては少し不適切かなと思いました。（もしくは、若干ミスリーディングなコメントを記述して実際の動作を学習者に確認させるための策かもしれませんね。）
