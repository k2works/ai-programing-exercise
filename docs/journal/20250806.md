# 作業履歴 2025-08-06

## 概要

2025-08-06の作業内容をまとめています。

## コミット: df80f17

### メッセージ

```
docs: update CLAUDE.md with new guidelines and add new reference documents
```

### 変更されたファイル

- M	CLAUDE.md
- A	docs/adr/.gitkeep
- A	docs/design/.gitkeep
- A	docs/development/.gitkeep
- M	docs/index.md
- A	docs/operation/.gitkeep
- A	docs/reference/.gitkeep
- A	"docs/reference/\343\202\210\343\201\204\343\202\275\343\203\225\343\203\210\343\202\246\343\202\247\343\202\242\343\201\250\343\201\257.md"
- A	"docs/reference/\343\202\242\343\202\270\343\203\243\343\202\244\343\203\253\343\201\252\350\246\213\347\251\215\343\201\250\350\250\210\347\224\273\343\201\245\343\201\217\343\202\212.md"
- A	"docs/reference/\343\202\250\343\202\257\343\202\271\343\203\210\343\203\252\343\203\274\343\203\240\343\203\227\343\203\255\343\202\260\343\203\251\343\203\237\343\203\263\343\202\260.md"
- A	"docs/reference/\351\226\213\347\231\272\343\202\254\343\202\244\343\203\211.md"
- A	docs/requirements/.gitkeep

### 変更内容

```diff
commit df80f17ecb0fc11e032886cd8b7a7ecd6db78033
Author: k2works <kakimomokuri@gmail.com>
Date:   Wed Aug 6 17:15:26 2025 +0900

    docs: update CLAUDE.md with new guidelines and add new reference documents

diff --git a/CLAUDE.md b/CLAUDE.md
index 56efa37..c5d8c81 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -1,178 +1,198 @@
 # CLAUDE.md
 
+ここで**必ず**と指示されていることは絶対に実施してください
+
 日本語で回答してください
 
-This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
+あなたは**よいソフトウェア**に対する明確な考えと**よいソフトウェア**を作るための規律を持った開発経験豊富な開発者です。
 
-## プロジェクト概要
+よいソフトウェアについては @docs/reference/よいソフトウェアとは.md を参照してください。
 
-これは、複数のプログラミング言語でのテスト駆動開発（TDD）学習を目的とした多言語AIプログラミング演習環境です。プロジェクトはドキュメント駆動開発を重視し、Dockerコンテナを通じて包括的な多言語開発環境を提供します。
+よいソフトウェアについての考えと規律と経験に関する知見は @docs/reference 内を参照してください。
 
-## 開発環境
+あなたは @docs/reference/開発ガイド.md に従いソフトウェア開発を手段として問題解決に取り組みます。
 
-### Dockerベースの多言語環境
-プロジェクトは12種類以上のプログラミング言語を含む完全な開発環境を提供します：
+あなたは既存のソフトウエア開発のベストプラクティスと最新のAIテクノロジーを融合させることによりソフトウエア開発にイノベーションをもたらします。
 
-```bash
-# 開発環境を開始
-docker-compose up -d
+```plantuml
+@startuml
+title 開発プロセスの状態遷移図
 
-# すべての言語を含む開発コンテナにアクセス
-docker-compose exec app bash
+[*] --> 要件
+要件 --> 開発
+要件 -right-> 運用
+運用 -left-> 要件
+開発 -left-> 要件
+開発 --> 運用
+運用 --> 開発
+運用 --> 配置
+運用 -up-> 構築
+構築 --> 配置
+運用 ---> [*]
 
-# ドキュメントサーバーを開始（localhost:8000）
-docker-compose up mkdocs
+state 要件 #red
+state 構築 #limegreen
+state 運用 #orange
+state 開発 #purple
+state 配置 #lightblue
+@enduml
 ```
 
-**利用可能な言語:**
-Java 21.0.2、Scala 3.4.0、Kotlin 2.0.0、Clojure 1.12.1、Node.js 22、Ruby 3.4.4、Python 3.12、PHP 8.1、Haskell 9.4.8、Go 1.22.0、Rust (stable)、.NET 8.0
-
-## 共通コマンド
+## 要件
 
-### ドキュメント管理
-```bash
-npm run docs:serve          # localhost:8000でMkDocsサーバーを開始
-npm run docs:build          # 静的ドキュメントをビルド
-npm run docs:stop           # ドキュメントサーバーを停止
-npm run journal             # git履歴から開発日誌を生成
+```plantuml
+@startuml "Phase 1"
+|要件定義|
+start
+:アプリケーション概要;
+:ユーザーストーリー;
+:ユースケース;
+:ユーザーストーリー・ユースケース詳細化;
 
-# 代替のGulpコマンド
-npx gulp mkdocs:serve        # 代替サーバー開始
-npx gulp mkdocs:stop         # 代替サーバー停止
-npx gulp journal:generate    # すべてのコミット日誌を生成
-npx gulp journal:generate:date --date=YYYY-MM-DD  # 特定日付の日誌を生成
-```
+|機能要件|
+:アーキテクチャ設計;
+:データモデル設計;
+:ドメインモデル設計;
+:UI設計;
 
-### 言語固有のビルドコマンド
+|非機能要件|
+:テスト戦略策定;
+:非機能要件定義;
+:運用要件定義;
 
-**Java/Kotlin/Scala（プロジェクトが存在する場合）:**
-```bash
-# Mavenプロジェクト
-mvn test && mvn compile && mvn package
+|要件定義|
+:技術スタック選定;
+:ADR作成;
+:リリース計画;
 
-# Gradleプロジェクト
-gradle test && gradle build
+stop
 
-# 単一テスト実行
-gradle test --tests SpecificTestClass
+@enduml
 ```
+### リリース計画
 
-**Node.js:**
-```bash
-npm test && npm run build
-yarn test && yarn build
-```
+```plantuml
+@startuml
 
-**Python:**
-```bash
-uv run pytest              # uvを使用した現代的なPythonテスト
-uv build                   # uvを使用した現代的なPythonビルド
-```
+[*] --> リリース
 
-**その他の言語:**
-```bash
-# Ruby
-bundle exec rake test && bundle exec rake build
+state リリース {
+  満足条件1: （ユーザーストーリー、予算、スケジュール)
+  満足条件1 -->リリースプランニング
+  リリースプランニング --> 満足条件1 
+}
 
-# Go
-go test ./... && go build
+state イテレーション {
+  リリースプランニング --> 満足条件2
+  満足条件2: （ユーザーストーリー、予算、スケジュール)
+  満足条件2 --> イテレーションプランニング
+  イテレーションプランニング --> 満足条件2
+  イテレーションプランニング --> 開発
+  開発 --> フィーチャが追加された状態
+  フィーチャが追加された状態 --> 満足条件2 : フィードバック
+  フィーチャが追加された状態 --> 満足条件1 : フィードバック
+}
 
-# Rust
-cargo test && cargo build
+リリース --> [*]
 
-# .NET
-dotnet test && dotnet build
+@enduml
 ```
 
-## プロジェクトアーキテクチャ
-
-### コンテナアーキテクチャ
-- **app**: すべてのツールチェーンを含む多言語開発コンテナ
-- **mkdocs**: PlantUMLサポート付きドキュメントサーバー
-- **plantuml**: 専用PlantUML図表サーバー（plantuml:8080）
-
-### ドキュメントシステム
-プロジェクトはMaterialテーマ付きMkDocsを使用し、以下をサポートします：
-- アーキテクチャ可視化のためのPlantUML図表
-- プロセスフロー用のMermaid図表
-- 自動git履歴日誌生成
-- `docs/wiki/`内の広範囲な日本語TDD学習資料
-
-### 主要な開発パターン
-- **テスト駆動開発**: すべての実装はTDD実践に従うべきです
-- **ドキュメントファースト**: すべての新機能に対して包括的なドキュメントを作成
-- **多言語一貫性**: 異なる言語間で一貫したパターンを維持
-- **コンテナファースト開発**: すべての開発は標準化されたコンテナ内で行われます
-
-## GitHub Copilot統合
-
-プロジェクトには特定のガイダンスを含む`.github/copilot-instructions.md`があります：
-- `docs/wiki/開発プロセス標準.md`からのTDD手法に従う
-- アーキテクチャドキュメント用のPlantUML図表を作成
-- 外部サービス（Notion、GitHub、Slack、Atlassian、Wiki.js）用のMCP Server統合を使用
-- 特定フォーマットで開発日誌を維持
-
-### MCP Serverワークフロー
-```bash
-# 日誌管理ワークフロー
-git log [start]..[end] --oneline                    # git履歴を分析
-git diff [start]..[end] -- [file]                   # 特定の変更をレビュー
-
-# 日誌はdocs/journal/YYYYMMDD.mdに保存
-# MCP Serverによる外部システムとの自動統合
+## 開発
+
+```plantuml
+@startuml
+
+[*] --> イテレーション計画
+イテレーション計画 --> ユーザーストーリー作成
+ユーザーストーリー作成 --> ユースケース作成
+ユースケース作成 --> コーディングとテスト
+アーキテクチャ設計 --> コーディングとテスト
+コーディングとテスト --> アーキテクチャ設計
+データモデル設計 --> コーディングとテスト
+コーディングとテスト --> データモデル設計
+ドメインモデル設計 --> コーディングとテスト
+コーディングとテスト --> ドメインモデル設計
+コーディングとテスト --> ユーザーインターフェース設計
+ユーザーインターフェース設計 --> コーディングとテスト
+コーディングとテスト --> ユースケース作成
+コーディングとテスト --> イテレーションレビュー
+イテレーションレビュー --> イテレーション計画
+イテレーションレビュー --> [*]
+
+@enduml
 ```
 
-### GitHub Container Registry
-```bash
-# タグによる自動ビルドトリガー
-git tag 0.0.x && git push origin 0.0.x
-
-# 公開イメージの取得
-docker pull ghcr.io/k2works/ai-programing-exercise/core:0.0.x
+- 必ずイテレーション単位で開発を行う
+- 勝手に次のイテレーションに進まない
+
+### コーディングとテスト
+
+```plantuml
+```plantuml
+@startuml "イテレーション開発プロセス"
+
+start
+:ユースケース作成;
+:TODOリスト作成;
+
+repeat
+  :TODO選択;
+  
+  repeat
+    :失敗テスト作成 (Red);
+    :最小実装 (Green);
+    :リファクタリング (Refactor);
+    :品質チェック;
+    if (品質OK?) then (yes)
+      :コミット;
+    else (no)
+      :修正;
+    endif
+  repeat while (TODO完了?)
+  
+repeat while (全TODO完了?)
+
+:イテレーションレビュー;
+:ふりかえり;
+stop
+
+@enduml
 ```
 
-## 開発哲学
-
-`docs/wiki/開発プロセス標準.md`に基づいて、プロジェクトは以下を重視します：
-- **問題解決指向**: 問題解決指向の開発アプローチ
-- **よいソフトウェア**: 明確な原則を持つ「よいソフトウェア」の作成に焦点
-- **アジャイル開発**: アジャイル開発手法
-- **包括的ドキュメント**: 包括的なドキュメント実践
-- @docs/記事/よいソフトウェアとは.md
-- @docs/wiki/開発プロセス標準.md
-- @docs/wiki/読書メモ/エクストリームプログラミング.md
-- @docs/wiki/読書メモ/アジャイルな見積と計画づくり.md
-- @docs/wiki/読書メモ/達人プログラマー熟練に向けたあなたの旅.md
-
-## 重要なファイルの場所
-
-**設定:**
-- `mkdocs.yml`: ドキュメントサイト設定
-- `gulpfile.js`: タスク自動化定義
-- `docker-compose.yml`: コンテナオーケストレーション
-- `package.json`: Node.js依存関係とスクリプト
-
-**ドキュメント:**
-- `docs/wiki/`: 広範囲なTDDと開発手法ガイド
-- `docs/journal/`: 開発日誌と日次ログ
-- `script/`: 自動化用Gulpタスク定義
-
-**テンプレート:**
-- `docs/wiki/テンプレート/`: ADR、ユーザーストーリー、設計テンプレートを含むドキュメントテンプレート
-
-## このコードベースでの作業
-
-1. **Docker環境から開始**: 開発には常に`docker-compose up -d`を使用
-2. **ドキュメントファーストアプローチ**: 変更があればMkDocsドキュメントを更新
-3. **TDD実践に従う**: 既存の例に示されているようにテストファースト開発を実装
-4. **日誌を生成**: 開発進捗を記録するために`npm run journal`を使用
-5. **言語一貫性を維持**: 新しい言語実装を追加する際は確立されたパターンに従う
-6. **PlantUMLを使用**: 複雑な機能にはアーキテクチャ図表を作成
-
-## 新規開発のための注意事項
-
-- これは**学習環境テンプレート**です - 実際のアプリケーションコードは`app/`ディレクトリに追加すべきです
-- すべての言語ツールチェーンはDocker環境にプリインストールされています
-- `docs/wiki/`内の広範囲な日本語ドキュメントが手法ガイダンスを提供します
-- 日誌生成はMCP Serverと統合され、外部サービス同期を行います
-- プロジェクト哲学との一貫性を保つためにGitHub Copilot指示に従ってください
\ No newline at end of file
+- コミットは必ずTODO単位で実施する
+- コミットの前に必ず品質確認を実施する
+    - コミットの前に `npm run test` を実行してテストがすべて通ることを確認する
+    - コミットの前に `npm run lint` を実行してコードが整形されていることを確認する
+    - コミットの前に `npm run format` を実行してコードが整形されていることを確認する
+    - コミットの前に `npm run build` を実行してビルドが成功することを確認する
+- コミットメッセージはAngularのコミットメッセージの書き方を参考にする
+    - feat: 新機能の追加
+    - fix: バグ修正
+    - docs: ドキュメントの変更
+    - style: フォーマットやセミコロンの追加など、コードの動作に影響しない変更
+    - refactor: リファクタリング（バグ修正や機能追加ではない）
+    - test: テストコードの追加や修正
+    - chore: ビルドプロセスや補助ツールの変更
+
+## 運用
+
+### 構築・配置
+
+```plantuml
+@startuml "Phase 1"
+|構築|
+start
+:環境構築;
+:CI/CD構築;
+
+|配置|
+:デプロイ設定;
+
+|構築|
+:ドキュメント更新;
+
+stop
+
+@enduml
+```
diff --git a/docs/adr/.gitkeep b/docs/adr/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/docs/design/.gitkeep b/docs/design/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/docs/development/.gitkeep b/docs/development/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/docs/index.md b/docs/index.md
index 3416d54..3349b53 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -2,10 +2,11 @@
 
 - [コンテキスト図](./requirements/コンテキスト図.md) - 情勢をつかむ。
 - [インセプションデッキ](./requirements/インセプションデッキ.md) - プロジェクトの最初の週に作成された。ここにあるものの大部分は変更されたが、このドキュメントは我々がなぜこのシステムを構築しているかを示している。
-- [ユーザーストーリー](./requirements/要件定義.md) - ユーザーの視点からシステムの要件をまとめる。ユーザーが何を求めているかを理解するために重要。
-- [ユースケース](./requirements/要件定義.md) - システムの機能を表す。システムが何をするかを理解するのに必要。
-- [アーキテクチャドキュメント](./development/アーキテクチャ概要.md) - システムのアーキテクチャを示す。システムの全体像を把握するために重要。
-- [開発ドキュメント](./development/アプリケーション概要.md) - 開発の具体的な手順やガイドラインをまとめる。
+- [ユーザーストーリー](./requirements/要件.md) - ユーザーの視点からシステムの要件をまとめる。ユーザーが何を求めているかを理解するために重要。
+- [ユースケース](./requirements/要件.md) - システムの機能を表す。システムが何をするかを理解するのに必要。
+- [アーキテクチャドキュメント](./design/アーキテクチャ.md) - システムのアーキテクチャを示す。システムの全体像を把握するために重要。
+- [設計キュメント](./design) - システムの設計に関する詳細をまとめる。具体的な実装方法や技術選定を記録する。
+- [開発ドキュメント](./development) - 開発の具体的な手順やガイドラインをまとめる。
 - [運用ドキュメント](./operation) - システムの運用に関する情報を提供する。運用チームがシステムを管理するために必要。
 - [アーキテクチャ決定ログ](./adr) - システムのアーキテクチャに関する重要な決定を記録する。将来の参照や説明に役立つ。
 - [日誌](./journal) - 開発の進捗や問題点を記録する。開発の履歴を追うために重要。
diff --git a/docs/operation/.gitkeep b/docs/operation/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/docs/reference/.gitkeep b/docs/reference/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git "a/docs/reference/\343\202\210\343\201\204\343\202\275\343\203\225\343\203\210\343\202\246\343\202\247\343\202\242\343\201\250\343\201\257.md" "b/docs/reference/\343\202\210\343\201\204\343\202\275\343\203\225\343\203\210\343\202\246\343\202\247\343\202\242\343\201\250\343\201\257.md"
new file mode 100644
index 0000000..12ae8d8
--- /dev/null
+++ "b/docs/reference/\343\202\210\343\201\204\343\202\275\343\203\225\343\203\210\343\202\246\343\202\247\343\202\242\343\201\250\343\201\257.md"
@@ -0,0 +1,220 @@
+---
+title: よいソフトウェアとは
+description: 
+published: true
+date: 2025-06-27T09:48:46.154Z
+tags: 
+editor: markdown
+dateCreated: 2025-06-27T09:35:43.840Z
+---
+
+# よいソフトウェアとは
+
+## ソフトウェアの目的
+
+- 問題解決: 
+  - 単なる「動くプログラム」ではなく問題を解決するもの
+- 本質的な目的:
+  - ユーザーの問題解決: 課題や不便を解消
+  - ビジネス価値の創出: 組織やビジネスに利益をもたらす
+  - 効率化と自動化: 時間や労力を節約
+  - イノベーションの実現: 新しい体験や可能性を提供
+  
+## ソフトウェアの価値
+
+- 機能性: ユーザーの問題をちゃんと解決できるか
+- 使いやすさ: 優れた機能でも使いにくければ意味がない
+- 信頼性: 安定して動作するか
+- 保守性: 長期間にわたって改善・維持できるか
+
+## よいソフトウェアの必要十分条件
+
+変更を楽に安全にできて役に立つソフトウェアであることが必要十分条件である。
+変更を楽に安全にできて役に立つソフトウェアであればよいソフトウェアである。
+
+変更を楽に安全にできなくても役に立つソフトウェアはあるのではないか？
+
+## よいソフトウェアの内部要因と外部要因
+
+### 内部要因
+
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  folder "チーム" {
+    folder "技術" {
+    }
+  }
+}
+@enduml
+```
+
+内部要因:自分でコントロールできる部分
+
+### 外部要因
+
+外部要因:自分でコントロールできない部分
+
+## だめなソフトウェア
+
+### へろへろスクラム
+
+へろへろスクラムが続くと、チームは疲弊し、顧客満足度は低下し、技術的負債が蓄積する。スクラムの名を借りた単なる「現代的な搾取システム」になりかねない。結局、アジャイルの見かけだけで本質を理解していないマネージャーの自己満足だけが残る。
+
+### 動作するきれいなゴミ
+
+技術的には完璧なソフトウェアのように見えるが、誰も使わないただのゴミ
+
+## よいソフトウェア
+
+本当に良いソフトウェアを作るには、以下のバランスが必要：
+
+1. 技術的な卓越性 - コードの品質、保守性、拡張性
+1. ビジネス価値 - 市場ニーズ、収益創出、競争優位性
+1. ユーザー中心設計 - 使いやすさ、問題解決力4. 健全なチーム文化 - 心理的安全性、自己組織化、継続的改善
+
+## よいソフトウェアを作るための規律
+
+### 規律とは
+
+> ”規律とは「本質的な部分」と「任意の部分」で構成される一連のルールである。”
+> Clean Craftsmanship　規律、基準、倫理 (アスキードワンゴ)
+
+本質的な部分・・・よいソフトウェアを作るパワーを与える
+任意の部分・・・よいソフトウェアを作るために従うプラクティス
+
+### ソフトウエア開発の3P(プリンシパル・パターン・プラクティス)
+
+- SOLID原則: 単一責任、開放閉鎖、リスコフの置換、インターフェース分離、依存性逆転
+- デザインパターン: 再利用可能な設計ソリューション
+- アーキテクチャパターン：ソフトウェアアーキテクチャで発生する問題の解決策
+- ドメイン駆動設計: ビジネスドメインに焦点を当てた設計
+- テスト駆動開発: テストを先に書いてから実装
+- 継続的デリバリー: 小さな変更を頻繁にリリース
+
+### サークルオブライフ
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  object チーム全体
+  object 受入テスト
+  object 小さなリリース
+  object 計画ゲーム
+  folder "チーム" {
+    object 継続的インテグレーション
+    object 共同所有
+    object 持続可能なペース
+    object メタファー
+    folder "技術" {
+      object テスト駆動開発
+      object リファクタリング
+      object シンプルな設計
+      object ペアリング
+    }
+  }
+}
+@enduml
+```
+
+#### ビジネスプラクティス
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  object チーム全体
+  object 受入テスト
+  object 小さなリリース
+  object 計画ゲーム
+  folder "チーム" {
+    folder "技術" {
+    }
+  }
+}
+@enduml
+```
+
+#### チームプラクティス
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  folder "チーム" {
+    object 継続的インテグレーション
+    object 共同所有
+    object 持続可能なペース
+    object メタファー
+    folder "技術" {
+    }
+  }
+}
+@enduml
+```
+
+
+#### テクニカルプラクティス
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  folder "チーム" {
+    folder "技術" {
+      object テスト駆動開発
+      object リファクタリング
+      object シンプルな設計
+      object ペアリング
+    }
+  }
+}
+@enduml
+```
+
+### 拡張サークルオブライフ
+
+```plantuml
+@startuml
+title 内部要因
+
+folder "ビジネス" {
+  object チーム全体
+  object 受入テスト
+  object 小さなリリース
+  object 計画ゲーム
+  folder "チーム" {
+    object 継続的インテグレーション
+    object 共同所有
+    object 持続可能なペース
+    object ドメイン駆動設計
+    object 戦略的設計
+    object 戦術的設計
+    object ユビキタス言語
+    folder "技術" {
+      object テスト駆動開発
+      object リファクタリング
+      object シンプルな設計
+      object ペアリング
+    }
+  }
+}
+@enduml
+```
+
+
+## 結論
+
+短期的には変更を楽に安全にできなくても役に立つソフトウェアを作ることはできる。
+しかし、時間の経過・外部環境の変化とともに変更を楽に安全にできないため役に立つソフトウェアでなくなる。
+変更を楽に安全にできて役に立つソフトウェアであることが必要十分条件である。
+上記の条件を満たし外部環境の変化に適応し続けるソフトウェアこそよいソフトウェアである。
+よって、良いソフトウェアとは変更を楽に安全にできて役に立つソフトウェアである。
\ No newline at end of file
diff --git "a/docs/reference/\343\202\242\343\202\270\343\203\243\343\202\244\343\203\253\343\201\252\350\246\213\347\251\215\343\201\250\350\250\210\347\224\273\343\201\245\343\201\217\343\202\212.md" "b/docs/reference/\343\202\242\343\202\270\343\203\243\343\202\244\343\203\253\343\201\252\350\246\213\347\251\215\343\201\250\350\250\210\347\224\273\343\201\245\343\201\217\343\202\212.md"
new file mode 100644
index 0000000..086d657
--- /dev/null
+++ "b/docs/reference/\343\202\242\343\202\270\343\203\243\343\202\244\343\203\253\343\201\252\350\246\213\347\251\215\343\201\250\350\250\210\347\224\273\343\201\245\343\201\217\343\202\212.md"
@@ -0,0 +1,789 @@
+---
+title: アジャイルな見積と計画づくり読書メモ
+description: 
+published: true
+date: 2025-07-08T03:58:15.284Z
+tags: 
+editor: markdown
+dateCreated: 2025-06-04T06:50:04.097Z
+---
+
+# アジャイルな見積もりと計画づくり
+
+```plantuml
+@startmindmap
+
+* アジャイルな見積もりと計画づくり
+left side
+** イントロダクション
+** 第1部 問題とゴール
+*** 1章 計画の目的
+*** 2章 なぜ計画づくりに失敗するのか
+*** 3章 アジャイル手法
+** 第2部 規模を見積もる
+*** 4章 ストーリーポイントによる規模の見積もり
+*** 5章 理想日による見積もり
+*** 6章 見積の技法
+*** 7章 再見積もり
+*** 8章 ストーリーポイントと理想日
+** 第3部 価値のための計画づくり
+*** 9章 テーマの優先順位づけ
+*** 10章 金銭価値による優先順位づけ
+*** 11章 「望ましさ」による優先順位づけ
+*** 12章 ユーザーストーリーの分割
+right side
+** 第4部 スケジュールを立てる
+*** 13章 リリース計画づくりの基本
+*** 14章 イテレーション計画づくり
+*** 15章 イテレーションの長さを決める
+*** 16章 ベロシティの見積もり
+*** 17章 不確実性に備えるバッファ計画
+*** 18章 複数チーム編成プロジェクトの計画づくり
+** 第5部 トラッキングと情報共有
+*** 19章 リリース計画のモニタリング
+*** 20章 イテレーション計画のモニタリング
+*** 21章 計画とコミュニケーション
+** 第6部 なぜアジャイルな計画づくりがうまくいくのか
+*** 22章 なぜアジャイルな計画づくりがうまくいくのか
+** 第7部 ケーススタディ
+*** 23章 ケーススタディ:ボムシェルタースタジオ
+
+@endmindmap
+```
+
+## イントロダクション
+
+> 計画づくりとは「なにをいつまでに作ればいいのか？」という質問に答える作業だと私は考えている p023
+
+## 第1部 問題とゴール
+
+### 1章 計画の目的
+
+> リリースとはすなわち、ソフトウェアが開発チームの手を離れて、顧客あるいはユーザーの手にわたることだ。 p028
+
+> フィーチャはユーザーにとってのソフトウェアの価値を表現したものであり、ユーザーに直接価値を提供するものだということだ。 
+> フィーチャとはユーザーにとっての価値なので、フィーチャには性能目標やセキュリティといったいわゆる非機能要件も含まれる。 p029
+
+> ソフトウェアを使う側の視点から記述している、という点が重要である。 p029
+
+> 見積もりと計画があってはじめて、意思決定が下せる。 p031
+
+> プロジェクトの計画づくりでの意思決定は、ほとんどがトレードオフの判断だ。 p031
+
+> 計画は、プロジェクトへの期待を共有する基盤として使うものだ。 p032
+
+> よい計画とは、ステークホルダーが信頼できる計画だ。信頼できるとは、その計画を基にして意思決定ができるという意味である。 p033
+
+> 計画とはドキュメントや図表であり、ある時点のスナップショットを記録したものだ。そこに記録されているものは、不確かな未来にプロジェクトで起きるだろうと予測したひとつの姿にすぎない。
+> いっぽう、プランニング、すなわち計画づくりは「活動」である。アジャイルな計画づくりで重視するのは、計画よりも、計画をつくる過程そのものだ。 p033
+
+> アジャイルな計画づくりを定義すると次のようになる。
+> - 計画よりも計画づくりを重視する
+> - 変化を促進する
+> - 計画そのものは容易に変更できる
+> - プロジェクト全体にわたって繰り返される
+> 
+> p 034
+
+まとめ
+
+見積も計画づくりも極めて重要なのだが、難しく、そして誤りやすい。見積や計画づくりが難しいからといって避けて通ることは許されない。
+プロジェクトの初期段階では不正確な見積しかできないが、プロジェクトが進むにつれてより正確に見積もれるようになる。こうして見積りが徐々に調整されていく様子を示しているのが、不確実性コーンである。
+計画づくりの目的は、プロダクトの開発においてもっとも重要な質問、すなわち「なにをつくるべきか？」という問いに答えることだ。この質問への回答には、フィーチャ、リソース、スケジュールが盛り込まれる。
+この回答に説得力をもたせるのが計画づくりである。そのような計画づくりはリスクと不確実性を低減させ、信頼のおける意思決定を導き、信頼関係を確立し、情報を伝達する。
+
+よい計画とは、プロダクトとプロジェクトについての意思決定をおこなう根拠として信頼できるものである。アジャイルな計画づくりで大切なのはでき上った計画よりも、計画を立てるという活動そのものだ。
+アジャイルな計画づくりは変化を促進する。アジャイルな計画づくりでは、立てた計画を容易に変更できる。アジャイルな計画づくりはプロジェクトのはじめから終わりまで何度も繰り返される。
+
+### 2章 なぜ計画づくりに失敗するのか
+
+> 顧客にとっての価値の単位はフィーチャだ。計画づくりでは、作業ではなくフィーチャを単位にすべきなのである。 p037
+
+> 従来型の計画づくりがうまくいかない次の理由は、マルチタスク化である。 p040
+
+> 不確実性に対処していく最善の方法は、繰り返すことだ。 p043
+
+まとめ
+
+2章では、従来型の計画づくりに内在するいくつもの問題を見てきた。数多くのプロジェクトが失敗してしまうのも、全く不思議ではない。作業を基準にした計画はフィーチャを軽視することにつながるが、フィーチャこそが顧客にとっての価値なのだ。
+作業を基準にした計画が問題を引き起こしてしまい、スケジュールを守れなくなることが多い。良かれと思って、プロジェクトのメンバーはマルチタスク化によって状況を打開しようとするが、マルチタスク化に潜むコストのせいで、結果的にプロジェクトはさらに遅延することになる。
+そしてプロジェクトがスケジュールを超過しそうになると、提供予定だったフィーチャが削除される。ところが、フィーチャを開発する順番は開発側の都合だけで決めているので、ユーザーにとって価値の高いフィーチャが削除されてしまうこともある。
+
+ユーザーが最終的に何を求めるのかには不確実性があり、はっきりとわからない。この事実を無視すると、プロジェクトとしては期日を守れたとしても、ユーザーにとって本当に重要なフィーチャを反映させられないからだ。というもの、計画を立てた後で明らかになった重要なフィーチャを反映させられないからだ。
+また、プロダクトを開発する方法にも不確実性があることを無視すると、プロジェクトの計画から必要な作業が漏れてしまう。その結果、プロジェクトが遅れたり、土壇場になってフィーチャを削除することになったり、許容できない品質の低下が起きたりする。
+
+多くの組織が見積とコミットメントを混同している。チームは見積を出したら、それをコミットメントするよう強いられてしまうのだ。
+
+### 3章 アジャイル手法
+
+アジャイルマニフェスト
+
+- プロセスやツールよりも、人と人との交流を
+- 包括的なドキュメントよりも、動作するソフトウェアを
+- 契約上の交渉よりも、顧客との協調を
+- 計画に従うことよりも、変化に適応することを
+
+プロジェクトへのアジャイルなアプローチ
+
+- 1つのチームとして働く
+- 短いイテレーションで作業する
+- イテレーションごとに成果をあげる
+- ビジネス上の優先度を重視する
+- 検査と適応
+
+> アジャイルなプロジェクトマネージャはマネジメントよりも、リーダーシップを重視する。 p048
+
+> イテレーションの長さよりも重要なことがある。それは、1回のイテレーションが終わるまでに、チームはイテレーション開始時点では明確には定義できていない要求を、少なくとも1つはコーディングしてテストをおこない、リリース可能なソフトウェアとして統合することだ。 p049
+
+> ユーザーストーリーは、ソフトウェア要求を表現するための軽量な手法である。ユーザーストーリーは、システムについてユーザーまたは顧客の視点からフィーチャの概要を記述したものだ。
+> ユーザーストーリーには形式が定められておらず、標準的な記法もない。とはいえ、次のような形式でストーリーを考えてみると便利である。「＜ユーザーの種類＞として、＜機能や性能＞がほしい。それは＜ビジネス価値＞のためだ」という形のテンプレートに従うと、
+> たとえば次のようなストーリーを書ける。「本の購入者として、ＩＳＢＮで本を検索したい。それは探している本をすばやく見つけるためだ」 p050
+
+> プロジェクトとは、新たな機能と知識とを迅速かつ安定して生み出し続ける活動ととらえるべきなのだ。新しい機能はプロダクトそのものとして提供され、新しい知識はプロダクトをベストなものにするために使われる。 p051
+
+> プロジェクトで生み出される知識は、プロダクトに関するものもあれば、プロジェクトに関するものもあるだろう。プロダクトについて新しい知識（プロダクトナレッジ）が得られると、プロダクトがどうあるべきかをより深く考えられる。プロジェクトについての新しい知識（プロジェクトナレッジ）とは、チームや採用している技術、リスクに関する情報のことだ。 p052
+
+> 最終成果がどのようなものになるかを、事前に知ることができないと認めれば、計画づくりを、長期的な目標に到達するための適切なゴール設定と、その見直しのプロセスだと位置づけられる。 p052
+
+```plantuml
+@startuml
+title プランニング・オニオン
+
+folder "戦略" {
+  folder "ポートフォリオ" {
+    folder "プロダクト" {
+        folder "リリース" {
+            folder "イテレーション" {
+            folder "今日" {
+              }
+            }
+        }
+    }
+  }
+}
+@enduml
+```
+
+```mermaid
+%% プランニング・オニオン
+graph TB
+    subgraph 戦略
+        subgraph ポートフォリオ
+            subgraph プロダクト
+                subgraph リリース
+                    subgraph イテレーション
+                        今日
+                    end
+                end
+            end
+        end
+    end
+```
+
+満足条件がリリースとイテレーションの計画づくりを駆動する
+
+```plantuml
+@startuml
+
+[*] --> リリース
+
+state リリース {
+  満足条件1: （ユーザーストーリー、予算、スケジュール)
+  満足条件1 -->リリースプランニング
+  リリースプランニング --> 満足条件1 
+}
+
+state イテレーション {
+  リリースプランニング --> 満足条件2
+  満足条件2: （ユーザーストーリー、予算、スケジュール)
+  満足条件2 --> イテレーションプランニング
+  イテレーションプランニング --> 満足条件2
+  イテレーションプランニング --> 開発
+  開発 --> フィーチャが追加された状態
+  フィーチャが追加された状態 --> 満足条件2 : フィードバック
+  フィーチャが追加された状態 --> 満足条件1 : フィードバック
+}
+
+リリース --> [*]
+
+@enduml
+```
+
+まとめ
+
+アジャイルチームはチームとして一丸となって仕事をするが、チームの一人一人には役割がある。プロダクトオーナーとは、プロダクトのビジョンを提供し、チームが開発するフィーチャの優先順位付けに責任を持つ役割である。
+顧客とは、プロジェクトへ資金を提供したり、完成したソフトウェアを購入する役割のことである。アジャイルプロジェクトには他にも、ユーザー、開発者、マネージャといった役割がある。
+
+アジャイルチームは、短くタイムボックス化されたイテレーションで作業する。各イテレーションの終わりには、稼働するプロダクトを提供する。イテレーションで開発するフィーチャはビジネスの観点から選択する。
+これにより、もっとも重要なフィーチャから順番に開発する。ユーザーストーリーはユーザーの要求を記述する手法で、アジャイルチームでよく使われている。アジャイルチームは、計画が立てたそばから実体と乖離し始めるものだと承知している。
+これに適応するために、アジャイルチームでは計画を頻繁に見直す。
+
+プロジェクトというものは、迅速かつ一定して、新たな機能と知識とを生み出し続ける活動だと考えるべきである。単に定められた手順を実行するだけではないのだ。プロジェクトから生み出される知識には2種類ある。それはプロダクトナレッジとプロジェクトナレッジである。
+計画を洗練し、組織にとっての価値を最大にするためには、どちらの知識もの重要である。
+
+アジャイルチームは3つのレベルで計画づくりをする。それは、リリースプランニング、イテレーションプランニング、「今日」のプランニングの3つだ。リリース計画はリリース全体についての計画であり、3か月から6か月という期間がよく使われる。イテレーション計画は1イテレーション分の計画で、2週間から4週間である。
+「今日」のプラントは、日々のスタンドアップミーティングでメンバーがその日になにをするか決めた1日単位の計画のことである。
+
+プロダクトオーナーの満足条件を理解することなしに、リリースプランニングとイテレーションプランニングはできない。リリースプランニングでは、リリースでどうやってすべての満足条件をを満たすかをチーム全員で決定する。ここでの満足条件には、スコープ、スケジュール、リソースも含まれる。
+すべての満足条件を満たすためには、プロダクトオーナーは一部の満足条件を緩めなければならないこともある。同様のプロセスをイテレーションプランニングでも繰り返す。イテレーションプランニングでの満足条件は、実現すべきフィーチャと、フィーチャが期待通りに実装されたことを確認する概要レベルのテストして表現される。
+
+## 第2部 規模を見積もる
+
+### 4章 ストーリーポイントによる規模の見積もり
+
+```plantuml
+@startuml
+
+[*] --> 要求されるフィーチャ
+要求されるフィーチャ --> 規模の見積もり
+規模の見積もり --> 期間への変換
+期間への変換 --> スケジュール
+スケジュール --> [*]
+
+@enduml
+```
+
+> ポイントの数値そのものはあまり重要ではない。重要なのは、他の作業との相対値だ。 p061
+
+> アジャイルな見積と計画づくりの信条、「規模を見積もり、期間を導出する」ことだ。 p064
+
+まとめ
+
+ストーリーポイントは、ユーザーストーリーの相対的な大きさを測る単位である。見積が10ポイントのユーザーストーリーは、5ポイントのユーザーストーリーの2倍くらい大きいか、複雑か、リスクがあることを示す。同様に、10ポイントのストーリは20ポイントのストーリーの半分の大きさか、複雑さか、リスクだということだ。
+ここで重要なのはストーリーに割り当てたポイントを比べた時の比率なのだ。
+
+ベロシティはチームが1回のイテレーションでどれだけ進めるか、すなわち速度を示す。イテレーションを終えるたびに、チームがそのイテレーションでこなしたストーリーのストリーポイントを合計して、ベロシティを算出する。
+
+ストーリーポイントは作業の規模だけで見積もったものである。プロジェクトの期間は見積もるのではなく、ストーリーポイントの合計をチームのベロシティで割ることで導出される。
+
+### 5章 理想日による見積もり
+
+まとめ
+
+理想時間と現実時間は異なる。アメフトの理想時間は60分(15分のクォータが4回)である。しかし、理想時間で60分の試合が実際に終了するまでには現実時間で3時間以上かかる。理想時間と現実時間とが異なるのは、試合中には当然のように割り込みが発生するからだ。
+
+ユーザーストリーの開発にかかる時間は、現実日で見積もるよりも理想日で見積もる方が簡単である。現実日による見積りでは、ストーリーの完了までに起こりうる、あらゆる割り込みを考慮しなくてはならない。理想日による見積なら、ストーリーに必要な時間だけを検討すればよい。
+つまり、理想日は規模の見積なのだ。ただし、ストーリーポイントほどには厳格に規模だけを考慮したものではない。
+
+理想日による見積では、1つのユーザーストーリーの見積は1つの値にするのが望ましい。あるユーザーストーリーの見積を、プログラマの4理想日、テスターの2理想日、プロダクトオーナーの3理想日と表現することは避けるべきだ。それよりも、合計した数字を使って「このストーリーには9理想日かかる」と表現した方がよい。
+
+### 6章 見積の技法
+
+> 10倍以内ならうまく見積もれるというのならば、見積り対象をその範囲に収まるようにしたい。 p074
+
+> 必要かどうかまだわからないフィーチャ（投資してしまう前にコストの見積だけはしておきたい）や、近い将来にには開発予定のないフィーチャは、もっと大きな単位で見積もるユーザーストーリーを書きたいことも多い。こうした大きなユーザーストーリーをエピック（epic=叙事詩、大長編）と呼ぶ。
+> 
+> また、関連するユーザーストーリーをまとめて（紙のカードに書いているならペーパークリップでたばねればいい）、1つのものとして見積やリリースプランニングで使いたいことがある。こうしてひとまとめにしたユーザーストーリーはテーマと呼ぶ。エピックは単体でもサイズが大きいので、エピックがそのままテーマになることも多い。 p076
+
+> 「タスクを担当する人々こそが、見積りをおこなうべき人物としてもっとも適任である」 p082
+
+まとめ
+
+時間と労力を費やして見積を出したからといって、必ずしも見積が正確になるとは限らない。見積に費やすべき労力は、見積の目的に応じて決めなくてはならない。見積は実際の作業担当者が行うことが最適だとよく知られている。しかし、アジャイルチームでは誰が実際に作業を担当するのかが事前にはわからない。よって、見積はチームの協調的な作業とすべきだ。
+
+見積には事前に定義されたスケールを使って行うべきだ。近い将来に必要とされるフィーチャは信頼性の高い見積が必要になるので、非線形のスケールを使って細かい単位で見積もるべきだ。このときのスケールは、1から始まって10を超えない範囲の非線形の値にするのがよい。たとえば「1,2,3,4,8」や「1,2,4,8」といった数列を採用する。
+相対的に大きなフィーチャがあっても、今後の数イテレーションの間には実装しない見込みであれば、見積の値は大きいままにしておいてよい。この場合は、たとえば「13,20,40,100」といったサイズを見積の単位とする。「ゼロ(0)」を含めるチームもいる。
+
+見積を出すための技法には、専門家の意見、対比、分割といった技法もある。これらの技法を組み合わせた、楽しくて効果的な見積り手法がプランニングポーカーだ。プランニングポーカーでは、参加する見積担当者に、見積に使用できるポイントが記入された一そろいのカードを配る。
+フィーチャについて話し合った後、見積の担当者は手元のカードから自分の見積をあらわすポイントのカードを選ぶ。見積り担当者のカードは一斉にオープンする。参加者全員が合意できる見積りポイントに達するまで、見積り担当者間での話し合いと、カードの選択を繰り返す。
+
+### 7章 再見積もり
+
+> 私のベロシティ算出の方法は、オール・オア・ナッシングの考え方に基づいている。この立場では、ストーリーが完了していれば（すなわちコーディングとテストが完了し、プロダクトオーナーによる受け入れが済んでいる）、ストーリーのポイントを全て加算し、ストーリーの一部でも残っていれば、加算するポイントはゼロだ。 p090
+
+> 再見積もりが必要かどうかについてあまり思い悩まないこと。1つ2つのストーリーについて、見積を間違えていると感じたら、全体として見積が正しいと言えるように、できるだけ少数のストーリーだけを再見積もりすること。そして再見積もりを、今後のユーザースーリーの見積の学習として活用すること。 p091
+
+まとめ
+
+ストーリーポイントや理想日がフィーチャの規模の見積だと理解していれば、再見積もりのタイミングもわかりやすい。再見積もりすべき時とは、ストーリーの相対サイズについての考え方が変わったときだ。進捗が想定どおりでないという理由だけで再見積もりしてはならない。ベロシティを補正装置として使うことで、見積の不正確さは解決されていく。
+
+イテレーションの終了時点で途中までしか完了できなかったストーリーは、ベロシティの算出に加えないことを私は勧める。私の好みは、ストーリーの全ポイントをベロシティに加える（ストーリーの実装とテストが完了して、プロダクトオーナーが受け入れた場合）か、さもなければ達成ポイントはゼロとみなし、ベロシティに加えないというものだ。
+とはいえ、部分的に完了させたストーリーのポイントを加えたい場合もある。よくある対処法は、ストーリーのうちでイテレーション中に完了させた部門をポイントして見積もってベロシティに加算し、残った部分は別のストーリーとして書き直すというものだ。このとき、完了分のストーリーポイントと残作業分のストーリーポイント合計は、元々のストーリーのポイントと一致しなくてよい。
+
+### 8章 ストーリーポイントと理想日
+
+> アジャイルなチームが成功する理由の1つは、チームが個々のメンバーの専門分野を超えて職能横断的に機能していることだ。 p092
+
+> ストーリーポイントの説明をするということは、同時にプロジェクトで採用する見積と計画づくりの概念と手法を説明することでもあるのだ。不確実性コーン、少しづつ計画を正確にしていくこと、ベロシティの継続的な測定が計画の信頼性を高めることといった考え方を伝える絶好の機会なのだ。 p096
+
+まとめ
+
+見積りをするにあたって、チームはストーリーポイントと理想日のどちらを採用してもよい。それぞれに利点がある。
+
+ストーリーポイントとにはチームの職能横断的な働きを促進する利点がある。また、ストーリーポイントは純粋な規模の見積なので、チームが対象とする技術や業務分野に詳しくなっても再見積もりの必要がない。
+多くの場合、理想日よりもストーリーポイントのほうが早く見積もれる。そして、ストーリーポイントは理想日と違って、チームメンバー間で比較できる。理想日による見積では、あるメンバーが4理想日と見積もったストーリーを、たのメンバーは1理想日と見積もることもありうる。この2人の見積りはそれぞれに正しいのだが、唯一の見積り値として合意する基準がない。
+
+理想日の利点は、チームの部外者に説明しやすいということと、最初に導入するのが簡単ということである。
+
+私はストーリーポイントのほうが好みだ。ストーリーポイントで見積もる利点には、採用の根拠になるだけの説得力がある。チームが純粋な規模の見積りに苦労しているなら、私なら、まず理想日による見積りで初めて、そのうちストリーポイントに切り替えていく。このときの私のやり方は、見積りの際に「このストーリーには何理想日かかるか？」ではなく「このストーリーは、さっき見積もったストーリーに比べえてどのくらいの大きさか？」といった質問をすることだ。
+変化は徐々に起こるので、多くのチームは気づかない。チームが気づく頃には、理想日ではなくストリーポイントで考えるようになっているのだ。
+
+## 第3部 価値のための計画づくり
+
+### 9章 テーマの優先順位づけ
+
+> 優先順位に従う責任はチーム全体で共有するが、優先順位を付けるのはプロダクトオーナーの役割だ。残念ながら、1つのストーリーのようなフィーチャの小さい単位に対して、その価値を見積もるのは難しい。この問題を回避するために、個別のストーリーやフィーチャを1つにまとめて「テーマ」とする。ストーリーやテーマを相互に比較しながら優先順位づけして、リリース計画をつくる。 p100
+
+> 組織はどれだけ収益を上げられるのか、あるいは費用を節約できるだろうか？プロダクトオーナーが「ビジネス価値にもとづいて優先順位を付ける」と言うときは、この点だけを意味していることがほとんどだ。 p101
+
+> プロダクト知識（プロダクトナレッジ）とは、何を開発するかについての知識だ。
+> いっぽうプロジェクトに関する知識（プロジェクトナレッジ）は、どうやって開発するかに関する知識だ。 p103
+
+まとめ
+
+すべてのことをやれるだけの時間があることは稀なので、優先順位づけをして、どこから手を付けるのかを決めねばならない。優先順位づけにあたっては、重要なことが4つある。
+
+- 金銭価値
+- 必要となるコスト（おそらくはサポート等も含む）
+- 得られる知識の量とその意義
+- 低減できるリスト
+
+4つの要素を検討する際には、まず価値とコストの面から暫定的な優先順位づけをおこなう。それから他の要素を加味して、それぞれのテーマの優先順位を調整する。
+
+### 10章 金銭価値による優先順位付け
+
+> プロジェクトの収益源はさまざまだ。便宜的に4つのカテゴリに分類しよう。新しい収益、増加する収益、業務の効率化の4つである。 p113
+
+> 新規顧客から得た収益と、既存顧客から新たに得た収益を区別すると、便利なことが多い。 p113
+
+> 維持できる収益(Retained Revenue)とは、プロダクトやテーマを開発しなかったら企業が失うであろう収益のことである。 p114
+
+まとめ
+
+テーマを財務的に分析することは優先順位づけに役立つ、ほとんどの組織において最終的な評価とはどれだけの金額を得たり節約できるかで決まるためだ。利益と業務改善の効果を予想するのは、2年間先まであれば大抵は十分である。もし必要であれば、もっと先まで予想してもかまわない。
+
+テーマから得られる収益をモデル化する場合には、4つに分類するとよい。新しい顧客から得られる利益、既存の顧客が追加で購入したり新たにサービスを利用することで得られる利益、既存の顧客が競合プロダクトに乗り換えなかったことで維持できる利益、業務の効率化による利益だ。
+
+今日稼いだり使ったりしたお金には、将来に稼いだり使ったりするよりも高い価値がある。現在の金額と未来の金額を比較するためには、現在の金額を割り引く。現在価値とは、銀行に代表される比較的安全な投資によって、将来のある時点での金額を得るために現在必要となる投資額のことだ。
+
+キャッシュフローを評価するのに役立つ指標が4つある。正味現在価値、内部利益率（または投資収益率）、回収期間、割引回収機関だ。それぞれのテーマについてこれらの値を算出すれば、テーマ間の比較ができるので、プロダクトオーナーとチームとが協力して賢明な意思決定ができる。
+
+### 11章 「望ましさ」による優先順位づけに
+
+まとめ
+
+ここで一歩退いて、なんのために優先順位をつけているのかを思い出そう。9章ではフィーチャに優先順位づけをする際に重要な4つの要素を検討した。
+
+- 金銭価値
+- 必要となるコスト(おそらくはサポート等も含む)
+- 得られる知識の量とその意義
+- 低減できるリスク
+
+10章では、フィーチャの優先順位づけにあたっては学習リスク軽減とを考慮して全体的に評価することの重要性を説明した。
+
+11章では、フィーチャの望ましさに優先順位を付けるための手法を2つ紹介した。狩野モデルと、相対的重み付手法である。
+
+狩野の分析では、フィーチャは3つのカテゴリに分類できる。当たり前のフィーチャ、線形のフィーチャ、魅力的なフィーチャである。見込みユーザーに対してアンケートをとることで、フィーチャは分類できる。アンケートでは各フィーチャについて2つの質問を用意する。
+それは「このフィーチャがあったらどう思うか」と「このフィーチャがなかったらどう思うか」である。相対的重み付けでは、あるフィーチャについての利点、フィーチャがないことの悪影響、開発するためのコストの3つをもとに、フィーチャの優先度をあらわす数値を算出する。
+
+### 12章 ユーザースーリーの分割
+
+> 操作に沿った分割でよくあるには、いわゆるCRUD操作を境界として分割することだ。 p140
+
+> 大きなストーリーを3つのストーリーに分割するのは本当によくあるパターンなので、ガイドラインにできる。 
+> 大きなストーリーはCRUD操作に沿って分割すること。 p141
+
+> ストーリーをタスクに分割しないようにするには、ハントとトーマスの教えに従おう。システムを「曳光弾」でてらすのだ。 p143
+
+まとめ
+
+ストーリーが1回のイテレーションに収まらないのであれば、分割すればよい。そもそも1回のイテレーションでは完了できない場合だけでなく、計画しているイテレーションには組み入れる余地がない場合にも、分割を検討する。また、1つの大きなストーリーを見積もるよりも、
+分割して見積もったほうが正確な見積になる。より正確な見積が必要な場合にもストーリー分割は有効である。
+
+ストーリーの分割にはさまざまな手法がある。扱うデータに沿って分割することもできるし、ストーリーを実現するための操作に沿って分割することもできる。いわゆるCRUD(作成、読み出し、更新、削除)に沿った分割するというのはよく行われているし、横断的な機能を個別のストーリーとして括りだすこともできる。
+横断的な機能とは、セキュリティ、ロギング、エラーハンドリングなどだ。また、最初はパフォーマンス目標を考慮せず、イテレーション内ではストーリーの機能要求を実現させることでストーリーを小さくすることもできる。パフォーマンス目標はそれ自体を個別のストーリーとして、後のイテレーションで実現するのだ。
+また、ストーリーには複数の要求が含まれていることも多い。これらの優先度が異なる場合には、それぞれを別のストーリーへと分割できる。
+
+それから、ストーリーをフィーチャの実装に必要な開発タスクへと分解してはならない。機能を必要なタスクへと分解するのは誰にとっても馴染みのあるやり方なので、ついストーリーもタスクに分解してしまいそうになる。大きなストーリーに、そのストーリーをリリースするのには直接関係ないが関連する変更を追加する誘惑を断つこと。大きなストーリーをさらに大きくしてしまっては意味がない。
+
+最後に、複数のユーザーストーリーを1つにまとめたほうが適切な場合もあることに注意。これは、バグ修正のようにひとつひとつはストーリーとしては小さすぎる場合に有効である。
+
+## 第4部 スケジュールを立てる
+### 13章 リリース計画づくりの基本
+
+> リリースプランニングはイテレーションよりも長い期間にわたる。非常に抽象度がたかいリリース計画を立てる作業である。 p148
+
+> リリース計画の役割は、いつどれだけの成果が出せるかを判断することだ。 p149
+
+```plantuml
+@startuml
+
+[*] --> 満足条件を決める
+満足条件を決める --> ユーザーストーリーを見積もる
+state fork_state <<fork>>
+ユーザーストーリーを見積もる --> fork_state : どの順序でもよい
+fork_state --> イテレーションの長さを決める
+fork_state --> ベロシティを見積もる
+fork_state --> ユーザーストーリーに優先順位を付ける
+state join_state <<join>>
+イテレーションの長さを決める --> join_state
+ベロシティを見積もる --> join_state
+ユーザーストーリーに優先順位を付ける --> join_state
+join_state --> ストーリーを選択しリリース日を決める
+ストーリーを選択しリリース日を決める --> 満足条件を決める : リリースの満足条件を満たすまでイテレーションを繰り返す
+満足条件を決める --> [*]
+
+
+
+@enduml
+```
+
+> 金銭面での目標を達成できそうかどうか判定するための指標として、スケジュール、スコープ、リソースの三種の神器が採用されている。 p150
+
+> プロジェクトというものは時間が足りていないにもかかわらず、欲しいフィーチャは多すぎるのだ。 p151
+
+まとめ
+
+リリース計画は抽象度の高い計画であり、1回のイテレーションよりも長い期間を対象とする。ほとんどのチームで、リリースは3か月から6か月の周期で繰り返される。ソフトウェアの種類によっては、リリース周期がもっと長くなることもあれば、短くなることもある。
+状況が極めて単純であれば、リリースプランニングも簡単だ。想定されるベロシティを予定しているイテレーションイテレーションの数と掛けて、その結果を超えない範囲でユーザーストーリーを選択すればよい。
+
+リリースプランニングの段階では、個々のイテレーションで何をするかまで詳細に決める必要はない。実際、そこまでの詳細が必要になることはめったにない。ほとんどのプロジェクトでは、最初の数イテレーションにストーリーを割り振っておけば十分である。
+残ったストーリーのイテレーションのへの割り振りは、イテレーション計画を立てる際におこなえばよい。
+
+リリースプランニングには繰り返し実施される、イテレーティブなプロセスである。まずはプロダクトオーナーの満足条件を求める。この条件には通常、目標とするスケジュール、スコープ、リソースが含まれている。立てた計画がプロダクトオーナーの満足条件を満たせなかった場合は、
+計画が条件を満たせるようになるまで、繰り返しながら条件の基準を調整する。たとえばフィーチャを削らないのであればリリースを少し遅らせるとか、チームの人数を増やしてみる、といったようにだ。
+
+立てたリリース計画を壁に飾ったままにしてはならない。各イテレーションの開始時点で計画を見直して、必要に応じて更新すること。
+
+### 14章 イテレーション計画づくり
+
+> イテレーションプランニングの成果物は、タスクをまとめた単純な1枚のスプレッドシートや、手書きのカードの束で構わない。ただし、それぞれのタスクがどのストーリーに結びついているのかがわかるようにしておくこと。 p159
+
+> イテレーションプランニングで何をするのかを解説する前に、何をしないのかを明確にしておこう。 p161
+
+> イテレーションプランニングでタスクに担当者を割り当てても得るものは何もないのに、大事なものが失われる。 p161
+
+> リリース計画ではユーザーストーリーをストリーポイントか理想日で見積もる。イテレーション計画ではタスクを理想時間で見積もる。 p162
+
+|リリース計画| イテレーション計画       |        |
+|---|-----------------|--------|
+|計画の「水平線」| 3-6か月           | 1-4週間先 |
+|構成要素| ユーザーストーリー       |タスク|
+|見積単位| ストーリーポイントまたは理想日 |理想時間|
+
+```plantuml
+@startuml
+
+title ベロシティ駆動イテレーションプランニング
+
+state fork_state <<fork>>
+[*] --> fork_state : 順番は自由
+fork_state --> 優先順位を調整する
+fork_state --> 目標ベロシティを決める
+state join_state <<join>>
+優先順位を調整する --> join_state
+目標ベロシティを決める --> join_state
+join_state --> イテレーションのゴールを決める
+イテレーションのゴールを決める --> ユーザーストーリーを選ぶ
+ユーザーストーリーを選ぶ --> ユーザーストーリーをタスクに分解する
+ユーザーストーリーをタスクに分解する --> タスクを見積もる
+タスクを見積もる --> [*]
+
+@enduml
+```
+
+> 計画には、ユーザーストーリーをプロダクトに統合して動作させるために必要なすべてのタスクを含めるべきだ。 p167
+
+> スパイクとはイテレーション計画に含めるタスクの一種で、何らかの知見を得たり、疑問を解消することを目的に取り組む作業のことだ。 p170
+
+> ベロシティ駆動が「昨日の天気」を元にストーリーポイントや理想日を見積もるのに対して、コミットメント駆動ではチームは実装対象とするストーリーを1つずつ加えていって、これ以上は完成を確約できないとなったところでイテレーションの内容を確定させる。 p173
+
+```plantuml
+@startuml
+
+title コミットメント駆動のイテレーションプランニング
+
+[*] --> 優先順位を調整する
+優先順位を調整する --> イテレーションのゴールを決める
+state fork_state <<fork>>
+イテレーションのゴールを決める --> fork_state
+fork_state --> ユーザーストーリーを1つ選ぶ
+fork_state --> ストーリーをタスクに分解する
+fork_state --> タスクを見積もる
+state join_state <<join>>
+ユーザーストーリーを1つ選ぶ --> join_state
+ストーリーをタスクに分解する --> join_state
+タスクを見積もる --> join_state
+join_state --> チームにコミットできるかたずねる
+チームにコミットできるかたずねる --> fork_state : 確約できる（まだ追加の余地あり）
+チームにコミットできるかたずねる --> ユーザーストーリーを減らす
+ユーザーストーリーを減らす --> チームにコミットできるかたずねる : 確約できない
+チームにコミットできるかたずねる --> イテレーションプランニングの完了 : 確約できる
+イテレーションプランニングの完了 --> [*]
+
+@enduml
+```
+
+> ベロシティ駆動とコミットメント駆動はどちらも実際に使える手法であるけれえども、私の好みはコミットメント駆動だ。 p177
+
+まとめ
+
+リリース計画とは異なり、イテレーション計画は1回のイテレーションでの具体的な作業を扱う。リリース計画が3か月から6か月の期間を対象とするのに対し、イテレーション計画は1回のイテレーションだけを対象とする。リリース計画で扱う比較的大きなユーザーストーリーを、
+イテレーション計画ではタスクに分解する。ストーリーを分解したタスクは完了までにかかる理想時間を単位として見積もる。
+
+イテレーションプランニングの進め方は大きく分けて2つある。ベロシティ駆動とコミットメント駆動だ。どちらのやり方も手順の多くは共通しているので、できあがったイテレーション計画が似たようなものになることもよくある。
+
+
+### 15章 イテレーションの長さを決める
+
+> 私の大まかな目安は、プロジェクト期間中にこうしたチャンスを少なくとも4,5回は用意することだ。つまりプロジェクト期間が4か月以上なら1回のイテレーションの長さを4週間や1ヶ月にしても構わない。
+> しかしリリースまでの期間がもっと短いなら、それに合わせてイテレーションの長さも短くするほうがプロジェクトのためになる。 p182
+
+> イテレーションで達成するフィーチャをいったんコミットしたならば、そのゴールを変えないことが重要だ。 p183
+
+> 重要な検討ポイントは、よいアイデアが実際に動作するソフトウェアとして結実するまでにかかる時間だ。 p183
+
+```mermaid
+gantt
+    title アイデアがソフトウェアになるまでには平均1.5イテレーションの時間を要する
+    dateFormat YYYY-MM-DD
+    section イテレーション1
+        第1週 :a1, 2014-01-01, 7d
+        第2週(平均すると新しいアイデアはここで思い付き...) :a2, after a1, 7d
+        第3週 :a3, after a2, 7d
+        第4週(...ここでイテレーションに加えられ...) :a4, after a3, 7d
+    section イテレーション2
+        第5週 :b1, 2014-02-01, 7d
+        第6週 :b2, after b1, 7d
+        第7週 :b3, after b2, 7d
+        第8週(...ここで提供される) :b4, after b3, 7d
+```
+
+> 切迫感を出すにはチームが一定のプレッシャーを感じ続けられるようにイテレーションの長さを決めればいい。ただし、チームに強いプレッシャーを与え続けてはいけない（「今日中に納品しろ!」のような）。 p185
+
+> いろいろな長さのイテレーションを試してきた結果、私の好みの長さは2週間で1イテレーションだ。1週間（あるいはそれ以下）の短いイテレーションでは忙しすぎて気疲れする。 p185
+
+> 4週間のイテレーションは、短いイテレーションに比べると、創造的なソリューションを追及する時間的余裕がある。経験豊富なアジャイルチームという前提で、しかもプロジェクトに実験と探求が必要な段階なら、4週間のイテレーションを使いこなせるかもしれない。 p186
+
+まとめ
+
+ほとんどのアジャイルチームでは2週間から4週間のイテレーションを採用している。いつでもどこでも、どんなチームにも適用できるイテレーションの長さというものは存在しない。
+イテレーションの長さは、それぞれのチームが自分たちの状況を踏まえて、自分たちに最適な長さを選ばねばならない。そのために考慮すべき要素は以下の通りである。
+
+- リリースまでの時間
+- 不確定要素の高さ
+- フィードバックの得やすさ
+- 優先順位が安定している期間
+- 外部からのフィードバックの必要性
+- イテレーションのオーバーヘッド
+- 切迫感を感じ始めるまでの時間
+
+### 16章 ベロシティの見積もり
+
+> ベロシティの見積に過去の実績値を使う前に、以下の質問に答えてみること。 p192
+> - 技術は同じか?
+> - 業務分野は同じか?
+> - チームは同じか?
+> - プロダクトオーナーは同じか?
+> - ツールは同じか?
+> - 作業環境は同じか?
+> - 見積もった人は同じか?
+
+> プロジェクトにフルタイムで参加した場合に、そのメンバーがプロジェクトの作業に費やせる時間は1日あたり4時間から6時間だ。 p196
+
+まとめ
+
+ベロシティを見積もるには3つの方法がある。1つ目は、過去の実績値があれば、それを平均して使うというもの。ただし、この方法を使うにあたっては、チームやプロジェクトの性質、採用している技術などに大きな変化がないことを確認しなければならない。
+2つ目は、実際にイテレーションを実施するというものだ。これが最善の選択肢である。3つ目は、ベロシティを予想するというものだ。予想するためには、代表的なストーリーをいくつか選んでタスクに分解し、イテレーションの作業可能時間内に収まるかを調べる。
+この方法はイテレーションプランニングによく似ている。いずれの方法を採用するにせよ、ベロシティの見積には幅を持たせる。見積の幅には見積の不確実性を反映させること。見積りに持たせる幅をどれぐらいにするかを決めるには不確実性コーンが役に立つ。
+
+### 17章 不確実性に備えるバッファ計画
+
+> スケジュールバッファはプロジェクトの安全を保つための余裕であり、個別マージンを取り除いた見積り合計に加えるものである。 p212
+
+まとめ
+
+プロジェクトというものは非常にたくさんの不確実性を抱えている。しかし、この不確実性をきちんと反映したスケジュールが作成されることは稀である。不確実性が大きすぎる場合や、問題が起きた場合の影響が深刻な場合には、プロジェクト期間を見積もるのに工夫が必要になる。
+実際の開始よりもかなり前の時点でプロジェクト計画を立てねばならない場合や、スコープがほぼ固定で厳格な納期が設定されている場合、プロジェクトをアウトソースする場合、要求がごく表面的にしか分かっていない場合、納期を守れなかったときの（財務上、あるいはその他の）影響が甚大である場合などがそうだ。
+
+バッファの持たせ方でよく使われる方法は、フィーチャバッファとスケジュールバッファの2つである。フィーチャバッファは、プロダクトに対する要求が優先順位づけされていて、そのすべてが必ず提供されるわけではないと合意できている場合に用意するバッファである。たとえば、アジャイルプロセスの1つであるDSDMでは、提供されるフィーチャの30%はオプションとみなすことを提案している。
+この30%がプロジェクトのフィーチャバッファである。時間が足りなくなったときには、フィーチャバッファにあるフィーチャを削ることでスケジュールを守るのだ。
+
+一方スケジュールバッファは、スケジュールに適用するバッファである。スケジュールバッファはユーザーストーリーそれぞれの50%見積りと90%見積から導き出される。
+各ユーザーストーリーについて50%見積りと90%見積りの差の平方を求め、その値の合計の平方根を算出することで、適切なスケジュールバッファを見積もれる。
+
+プロジェクトを機能面での不確実性から守るにはフィーチャバッファを用意し、スケジュール面での不確実性からまもるにはスケジュールバッファを用意することだ。フィーチャバッファとスケジュールバッファを組み合わせて使うこともできる。
+むしろ、バッファは組み合わせるほうが望ましい。そのほうが、それぞれのバッファを小さくできるからだ。
+
+### 18章 複数チーム編成プロジェクトの計画づくり
+
+> 理想的な表現をすれば、アジャイルチームとは、要求が曖昧な段階からイテレーションを開始し、イテレーションが終了するまでに、曖昧な要求をテスト済みの動作するソフトウェアへと変換するものだ。 p217
+
+まとめ
+
+アジャイルプロジェクトは、大規模なプロジェクトに対しては、1つのチームを大きくするのではなく、複数の少人数チームを編成することが多い。1つのプロジェクトに複数のチームが関わっていると、互いの作業を連携させる必要が出てくる。この章では1つのプロジェクトに複数のチームが関わっている場合に役立つ4つのテクニックを紹介した。
+
+1つ目は、チームで共有できる見積基準の確立だ。そのためにはまず、すべてのチームが同じ見積もり単位を採用すること。見積単位はストーリーポイントか理想日のどちらかだ。それから、見積基準についての認識を合わせるために、いくつかのストーリーを見積もって、その結果に合意できるようにしておくこと。
+
+2つ目は、複数のチームが同じプロジェクトで作業する場合には、ユーザーストーリーは早い段階で詳細化しておくことだ。これについては、ストーリーに対するプロダクトオーナーの満足条件を明確にするのが最も効果的だ。プロダクトオーナーの満足条件を把握できれば、ストーリーがきちんと期待通りに実装できていることを、実際に動かして確認できる。
+
+3つ目は複数チームによるプロジェクトでは、リリース計画に「移動する先読み範囲」を取り入れると効果的だ。計画における「移動する先読み範囲」とは、今後予定されているイテレーションのいくつか（通常2つか3つ）までの先を見越して計画を立てるということだ。これがあると、近いうちに各チーム間でどういった連携が必要になるかを、情報交換しながら調整できる。
+最後となる4つ目は、チーム間の依存関係が多くて非常に複雑なプロジェクトでは、合流バッファを計画に組み入れると役に立つというものだ。合流バッファは、あるチームの作業の遅れが他のチームの作業開始に影響が及ばないように、プロジェクトに用意する時間的な余裕である。
+
+以上の4つのテクニックは、一般的には紹介した順にプロジェクトに導入するのがよいが、必ずしも順番通りである必要はない。
+
+## 第5部 トラッキングと情報共有
+
+> 計画づくりでは、経過うに対する進捗を把握すること、情報を共有すること、そしてそから得られれた知識にもとづいて計画を見直すことが重要なのだ。 p225
+
+### 19章 リリース計画のモニタリング
+
+> 「完了」しているとは、コードが単にきちんと掛けているだけでない。リファクタリング済みで、レポジトリにチェックインされた状態のきれいなコードになっているということだ。 p228
+
+> 未完成の作業は、仕掛り作業として開発プロセスの流れの途中に積みあがっていくことになる。仕掛り作業が増えれば増えるほど、新しい要求が思い浮かんでから動作するソフトウェアのフィーチャとして開発するまでの所要時間は長くなっていく。
+> これは、やがてはチーム全体のスループットを低下させてしまうのだ。また、仕掛り作業が多くなってくると、開発しているものに対するフィードバックを得るタイミングが遅くなってしまう。ということは、フォードバック結果から学ぶタイミングも遅くなるということだ。 p229
+
+まとめ
+
+ベロシティはチームが1回のイテレーションで完了させた仕事を測定したものだ。ベロシティの算出は、オール・オア・ナッシングだ。すなわち、イテレーション終了時点でストーリーが完了していれば、見積ポイント分すべてをベロシティに加算する。ストーリーに一部でも完了していないところがあれば、その見積数字は一切ベロシティに加算してはならない。
+リリースバーンダウンチャートは、各イテレーションの開始時点で、プロジェクト全体としてストーリーポイント（もたは理想日）がどれだけ残っているのかを把握するためのものだ。チームの残作業のバーンダウンが終始一貫して安定していることはない。見積は不正確だったり、途中で変わることがあるし、そもそもリリースのスコープ自体が変化するからだ。
+イテレーションの途中でバーンダウンチャートがバーンアップすることもある。ある程度は作業を完了指せていたとしても、未着手のストーリーのなかに過少見積りのストーリーがあることに気づくかもしれない。また、プロジェクトのスコープが広がった場合もプロジェクトはバーンアップする。リリースバーンダウンチャートを解釈するうえでのポイントは、チームの総合的な進み具合（正味進捗）が表現されているということだ。
+正味進捗とは、実際に完了させた作業量から、リリースに向けて増加した作業量を引いたものである。
+
+リリースバーンダウンチャートには、スタンダードな折れ線グラフ版の他にも、（場合によっては）より便利な棒グラフ版がある。棒グラフ版はでは、縦棒の下端を伸び縮みさせることで、スコープの増減をあらわす。こうすることで、棒グラフ版のバーンダウンチャートは折れ線グラフ版よりも表現力を増すが、使うに当たっては注意が必要になる。組織によっては、スコープの変動を縦棒の上端（チームの進捗）に反映すべきか、それとも下端（スコープの増減）に反映すべきかでもめることがあるからだ。
+
+パーキングロットチャートも、プロジェクト全体に対するチームの状況を概観するのに役立つ。このチャートでは1枚の紙で、実装予定のテーマ単位ごとに進捗状況を表現できる。
+
+### 20章 イテレーション計画のモニタリング
+
+> タスクボードはチームに2つの便利な仕組みを提供することを目的としている。1つは作業を整理する方法。もう1つは残作業を一目で把握する方法だ。 p238
+
+> 個人のベロシティをトラッキングしてはならない。個人のベロシティをトラッキングするのは、プロジェクト全体の成功を妨げることになる。 p243
+
+> ユーザーストーリーは、ユーザーインファーフェースデザイナ、プログラマ、データベースエンジニア、テスト担当者のそれぞれが協力することなしには実現できないように書くのである。 p244
+
+まとめ
+
+タスクボードは、チームの作業を整理し、可視化する。タスクボードにはホワイトボードやコルクボードを使うことが多いが、壁の片隅でも構わない。タスクボードの列にはそれぞれラベルをつけておき、作業の進行に応じて、対応するタスクカードないしはタスクかんばんをチームメンバー自信が順番に右側の列へと動かしていく。
+
+イテレーションバーンダウンチャートはリリースバーンダウンチャートとよく似ているが、現在のイテレーションの作業をトラッキングするのに使う点が異なる。イテレーションバーンダウンチャートは、縦軸に残作業の合計時間を、横軸にイテレーションの何日目かを取る折れ線グラフである。
+
+タスクの所要時間の見積と実績の比較はしないほうがよい。大抵の場合、予実を追跡することによるリスクと手間が利点を上回ってしまうからだ。
+
+個人単位でベロシティを測定したりトラッキングしてはならない。
+
+### 21章 計画とコミュニケーション
+
+> ガントチャートは悪名高いが、その原因はプロジェクトのタスクの予定とスケジューリング、そして調整するのに使われてきたためだ。ガントチャートに抵抗を感じる人は多いが、イテレーションにフィーチャを割り当てた機能を一覧するうえではとても役立つツールである。 p247
+
+```mermaid
+gantt
+    title イテレーションの内容を示したガントチャート
+    dateFormat YYYY-MM-DD
+    section 第1イテレーション
+        ユーザーとして、私は... :a1, 2014-01-01, 2w
+        ユーザーとして、私は... :a2, 2014-01-01, 2w
+        ユーザーとして、私は... :a3, 2014-01-01, 2w
+    section 第2イテレーション
+        ユーザーとして、私は... :b1, 2014-01-15, 2w
+        ユーザーとして、私は... :b2, 2014-01-15, 2w
+        ユーザーとして、私は... :b3, 2014-01-15, 2w
+```
+
+- 第1の特徴
+    - フィーチャレベルまでしか示しておらず、それより下のタスクレベルは表示していないことだ。
+    - ここで示したものはプロジェクトのフィーチャ分割構成(featrue breakdown structure)であり、作業分割構成ではない(work breakdown structure: WBS)ではない。
+    - プロダクトに価値を与えるのはあくまでフィーチャの完成であって、タスクの完了ではない。だからガントチャートにはフィーチャを載せるべきだ。
+- 第2の特徴
+    - それぞれのフィーチャ線が、割り当てられているイテレーション全体の期間にわたって引いてあることだ。
+    - なぜなら、フィーチャはイテレーションの途中で完成したとしても、イテレーション終了までは組織に見せることができない。ならば、ガントチャートにもそれを反映すべきだ。
+- 第3の特徴
+    - リソース割り当てを一切書いていないことだ。すべてのフィーチャを提供することに責任を持っているのはチーム全体だ。
+    - もちろん、複数のチームでの分担を1枚のガントチャートにしたいなら、各フィーチャには担当するチームがいるはずなので、リソースの列を用意して、フィーチャにチームを割り当てて、チーム名を記載するのは問題ない。
+
+> 私は過去イテレーションの3つの値に注目することにしている。
+> 1. 直近のイテレーションのベロシティ
+> 2. 全イテレーションの平均ベロシティ
+> 3. ワースト3イテレーションの平均ベロシティ p250
+
+| 説明           | ベロシティ | イテレーション数 | 合計ポイント |
+|--------------|-------|----------|--------|
+| ワースト3平均      | 14    | 5        | 70     |
+| 過去8イテレーション平均 | 17    | 5        | 85     |
+| 直近           | 19    | 5        | 95     |
+
+
+イテレーション完了報告書
+
+```markdown
+# プロジェクト概要
+
+## 日程
+
+- イテレーション開始日
+- イテレーション終了日
+- 作業日数
+
+## 要員
+
+|名前|予定作業日数|実績作業日数|
+|---|---|---|
+|A|5|5|
+
+## 指標
+
+### ナイトリービルド結果
+
+|日付|結果|
+|---|---|
+|9月1日(月) |Build failed|
+
+### イテレーションバーンダウン
+
+/```mermaid
+xychart-beta
+    title "リリースバーンダウンチャート"
+    x-axis ["イテレーション1", "イテレーション2", "イテレーション3", "イテレーション4", "イテレーション5", "イテレーション6"]
+    y-axis "残ストーリーポイント" 0 --> 120
+    line [100, 82, 65, 48, 30, 0]
+    line [100, 85, 72, 60, 42, 10]
+/```
+
+### ベロシティ
+
+/```mermaid
+xychart-beta
+    title "イテレーション別ベロシティ"
+    x-axis ["イテレーション1", "イテレーション2", "イテレーション3", "イテレーション4", "イテレーション5", "イテレーション6", "イテレーション7", "イテレーション8"]
+    y-axis "完了したストーリーポイント" 0 --> 25
+    bar [15, 18, 14, 16, 19, 17, 20, 21]
+    line [17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5, 17.5]
+    line [20.5, 20.5, 20.5, 20.5, 20.5, 20.5, 20.5, 20.5]
+/```
+
+## 実施内容と評価
+
+|ストーリー|結果|予定ポイント|ベロシティ加算ポイント|
+|---|---|---|---|
+|ユーザーとして、私は...|完了|5|5|
+|ユーザーとして、私は...|完了|3|3|
+|ユーザーとして、私は...|完了|8|8|
+|合計| |16|16|
+
+### イテレーションレビュー
+
+|アクションアイテム|担当|
+|---|---|
+|ユーザーとして、私は...のレビュー|A|
+
+```
+
+まとめ
+
+見積と計画にまつわるコミュニケーションは、正直で頻繁な、双方向のコミュニケーションでありたい。実は、ガントチャートは計画を伝えるのに役立つツールである。しかし、フィーチャより細かく分解したタスクレベルに使うべきではないし、ガントチャート上でフィーチャより細かく分解したタスクレベルには使うべきではないし、ガントチャート上でフィーチャを割り当てる期間の長さは実装予定のイテレーション全体の期間にすべきだ。
+
+バーンダウンチャートは最も重要な進捗報告ツールだが、バーンダウンチャート以外にも、過去のイテレーションのベロシティをまとめたグラフを用意することが多い。今後のチームのベロシティを予測する場合は、ベロシティを1つの値であらわすのでなく、幅を持たせた方がよい。
+そのためにはベロシティを3つ用意するとよい。すなわち、直近のイテレーション、過去8イテレーションの平均、過去8イテレーションのワースト3の平均、の3つだ。これらの値は、それぞれに対応する状況を表している。つまり、最近の状況、「長期的」平均、起こりうる最悪の事態の3つである。
+
+プロジェクトによっては「イテレーション終了報告」があること便利だ。イテレーション終了報告書があれば、最新情報を報告できる。また、後から過去のイテレーションの記録として参照するために保存しておくこともできる。
+
+## 第6部 なぜアジャイルな計画づくりがうまくいくのか
+### 22章 なぜアジャイルな計画づくりがうまくいくのか
+
+まとめ
+
+アジャイルな計画づくりの目的とは、プロダクト開発全体への問いに対する最適な回答すを見つけ出すことである。
+どんなフィーチャを、どれだけのリソースを投入して、いつまでにつくりあげるのか。
+プロジェクトはこの問いの最適解へ、イテレーションを繰り返しながら近づいていく。アジャイルな見積と計画づくりは、プロジェクトの最適解を見つけられるからこそ成功するのだ。
+そのために、異なるレベルで計画を立て、頻繁に見直す。タスクではなくストーリーを小さくし、仕掛かり作業がイテレーションをまたがないようにする。進捗はチーム全体をトラッキングし、個人の進捗は計測しない。
+不確実性を受け入れ、計画を反映させる。すべてはプロダクト開発全体への問いに答えるためなのだ。
diff --git "a/docs/reference/\343\202\250\343\202\257\343\202\271\343\203\210\343\203\252\343\203\274\343\203\240\343\203\227\343\203\255\343\202\260\343\203\251\343\203\237\343\203\263\343\202\260.md" "b/docs/reference/\343\202\250\343\202\257\343\202\271\343\203\210\343\203\252\343\203\274\343\203\240\343\203\227\343\203\255\343\202\260\343\203\251\343\203\237\343\203\263\343\202\260.md"
new file mode 100644
index 0000000..e92de84
--- /dev/null
+++ "b/docs/reference/\343\202\250\343\202\257\343\202\271\343\203\210\343\203\252\343\203\274\343\203\240\343\203\227\343\203\255\343\202\260\343\203\251\343\203\237\343\203\263\343\202\260.md"
@@ -0,0 +1,554 @@
+---
+title: エクストリームプログラミング
+description: 
+published: true
+date: 2025-03-28T08:18:25.366Z
+tags: 
+editor: markdown
+dateCreated: 2025-03-28T08:18:25.366Z
+---
+
+```plantuml
+@startmindmap
+* XP
+left side
+** XPとは何か
+** 価値
+*** コミュニケーション
+*** シンプリシティ
+*** フィードバック
+*** 勇気
+*** リスペクト
+*** その他の価値
+** 原則
+*** 人間性
+*** 経済性
+*** 相互利益
+*** 自己相似性
+*** 改善
+*** 多様性
+*** ふりかえり
+*** 流れ
+*** 機会
+*** 冗長性
+*** 失敗
+*** 品質
+*** ベイビーステップ
+*** 責任の引き受け
+right side
+** プラクティス
+*** 主要プラクティス
+**** いきいきとした仕事
+**** 計画
+***** 週次サイクル
+***** 四半期サイクル
+***** ストーリー
+***** ゆとり
+**** プログラミング
+***** テストファーストプログラミング
+***** インクリメンタルな設計
+***** ペアプログラミング
+**** 全員同席
+***** チーム全体
+***** 情報満載のワークスペース
+**** インテグレーション
+***** 10分ビルド
+***** 継続的インテグレーション
+*** 導出プラクティス
+**** ビジネス
+***** 交渉によるスコープ契約
+***** 利用都度課金
+***** デイリーデプロイ
+**** インクリメンタルなデプロイ
+**** チーム
+***** 根本原因分析
+***** 本物の顧客参加
+***** チームの継続
+***** チームの縮小
+**** プログラミング
+***** コードの共有
+***** コードとテスト
+***** 単一のコードベース
+** XPチーム全体
+*** テスター
+*** インタクラクションデザイナー
+*** アーキテクト
+*** プロジェクトマネージャー
+*** プロダクトマネージャー
+*** 経営幹部
+*** テクニカルライター
+*** ユーザー
+*** プログラマー
+*** 人事
+*** 役割
+@endmindmap
+```
+
+## 1. XPとは何か
+> XPとは、以前はうまくいっていたかもしれないが、今では最高の仕事の邪魔になっている習慣やパターンを手放すことだ。
+
+- **効果のある習慣を選び取ること**  
+  効果のない技術的・社会的な古い習慣を捨て、効果的な新しい習慣を採用する。
+
+- **今日やるべきことを理解すること**  
+  チームや個人がやるべきことを正確に把握し、目標達成につなげる。
+
+- **自己評価**  
+  チームの目標に貢献した自分の成果を評価し、自己成長につなげる。
+
+- **人間としての欲求を満たすこと**  
+  開発を通じて達成感や協調など、人間的欲求を満たす。
+
+---
+
+## 2. 価値（Values）
+
+```plantuml
+@startmindmap
+* XP
+** 価値
+*** コミュニケーション
+*** シンプリシティ
+*** フィードバック
+*** 勇気
+*** リスペクト
+*** その他の価値
+@endmindmap
+```
+ 
+**価値**とは、ある状況における好き嫌いの根源にあるものだ。
+
+- **コミュニケーション**  
+  コミュニケーションは、チーム感覚や効果的な協力関係を生み出すために重要なものである。だが、効果的なソフトウェア開発に必要なのは、コミュニケーションだけではない。
+
+- **シンプリシティ（単純さ）**
+  価値は、お互いにバランスを取り合ったり、サポートしあったりするものである。
+  たとえばコミュニケーションによって、現状の観点からは必要がない、あるいは時間的猶予がある要件を削除すれば、それがシンプリシティの達成につながる。
+　**シンプリシティ**を達成すれば、必要な**コミュニケーション**も少なくなる。
+
+- **フィードバック**  
+  フィードバックはコミュニケーションに欠かせない。「パフォーマンスは問題になるかな？」「わからないね。パフォーマンス測定用のプロトタイプを作って確認してみよう」。
+　フィードバックはシンプリシティにも影響する。３つの解決策の中で、どれが最もシンプルになるだろうか？そんなときは、３つすべてを試して確認してみよう。
+　同じものを3回実装するのはムダに思えるかもしれない。だが、シンプリシティが備わった納得できる解決差にたどり着くには、こうするのが最も効率的な方法だろう。
+　それと同時に、システムがシンプルになれば、その分だけ**フィードバック**を受け取ることも簡単になる。
+
+- **勇気**  
+  **勇気**のみでは危険だが、他の価値と合わせれば強力だ。**勇気**を持って真実を語れば（たとえそれが不愉快なことであっても）、**コミュニケーション**や信頼が強化されていく。
+  うまくいかない可決策を捨てて、**勇気**を持って新しい解決策を見つければ、**シンプリシティ**が促進される。
+  **勇気**を持って現実の具体的な答えを求めれば、そこから**フィードバック**が生まれる。
+
+- **リスペクト**  
+  チームメンバーがお互いに関心がなく、何をしているかを気にもとめないようであれば、XPはうまくいかない。
+　チームメンバーがプロジェクトを大切にしたいのであれば、何をしたところで救えるはずもない。
+
+- **その他の価値**  
+  最も重要なのは、チームの振る舞いをチームの価値に合わせることである。そうすれば、複数の価値を同時に維持する無駄を最小化することができる。
+
+---
+
+## 3. 原則（Principles）
+
+```plantuml
+@startmindmap
+* XP
+** 原則
+*** 人間性
+*** 経済性
+*** 相互利益
+*** 自己相似性
+*** 改善
+*** 多様性
+*** ふりかえり
+*** 流れ
+*** 機会
+*** 冗長性
+*** 失敗
+*** 品質
+*** ベイビーステップ
+*** 責任の引き受け
+@endmindmap
+```
+
+**原則は**、その分野に特化した活動の指針である。
+
+- **人間性**  
+  XPのプラクティスには、ビジネスニーズと個人の欲求の両方を満たすものを選んでいる。
+
+- **経済性**  
+  ソフトウェア開発に影響を与える経済性には２つの側面がある。貨幣のタイムバリューと、システムやチームのオプションバリューだ。
+  ソフトウェア開発の場合は、早めにお金を稼ぎ、あとでお金を使うほうがバリューが高い。
+  ソフトウェア開発の経済性のもうひとつの源泉は、将来のオプションバリューである。たとえば、メディアのスケジューリングプログラムを開発したとしよう。
+  それを他のスケジューリングのタスクにも再利用できたとすれば、本来の目的だけに使うよりもバリューが高い。 
+
+- **相互利益**  
+  あらゆる活動は、関係者全員の利益にならなければいけない。相互利益とは、最も重要であり、最も実行が難しいXPの原則である。
+
+- **自己相似性**  
+  ソフトウェア開発にも同じ原則が当てはまる。規模が違っていても、解決策の構造を新しい文脈にコピーしようとするからだ。
+  たとえば、先に失敗するテストを書いてから、それを動かすという開発の基本的なリズムがある。このリズムはあらゆる規模作用する。
+  四半期単位では、扱いたいテーマをテーマを一覧にして、ストーリーを使って取り組んでいく。週単位では、扱いたいストーリーを一覧にして、ストーリーを表すテストをを書いて、それを動かすようにする。
+  数時間単位では、書かなければいけないテストを一覧にして、テストを書いて、動かして、別のテストを書いて、その両方を動かして、これをテストの一覧が終わるまで繰り返す。
+
+- **改善**  
+  XPのポイントは、改善によってソフトウェア開発の高みを目指すことだ。改善のライフサイクルでは、明日をよりよくするために必要な気づきや理解を追い求めながら、今日できる最高のことをやる。
+  完璧になるのを待ってから始めるわけではない。
+
+- **多様性**  
+  多様性は**チーム全体**のプラクティスで表現されている。このプラクティスは、多種多様なスキルや視点を持った人たちをチームにまとめるというものだ。
+　異なる視点を持った人たちが、さまざまな計画サイクルを使い、時間内に最もバリューの高いソフトウェアを作り出すという目的を達成するのである。
+
+- **ふりかえり**  
+  優れたチームは単に仕事をしているだけではない。**どうやって**仕事をしているのか、**なぜ**仕事をしているのかを考えている。なぜ成功したのか、なぜ失敗したのかを分析している。
+　自分たちのミスを隠そうとしない。それを明らかにして、そこから学ぼうとするのである。偶然に優秀になれる人などいないのだ。
+
+- **流れ**  
+  流れの原則では、改善のために小さなバリューを何度もデプロイすることを提唱している。
+
+- **機会**  
+  XPの実践を始めると、必ず問題に直面する。エクストリームになるというのは、それぞれの問題を個人の成長、人間関係の深化、ソフトウェアの改善などの機会に意識的に変換することである。
+
+- **冗長性**  
+  ソフトウェア開発の重要で困難な問題は、複数の方法で解決すべきである。ひとつの解決策が完全に失敗しても、その他の解決策で惨事を食い止めることができるからだ。
+　冗長にコストがかかるとしても、惨事から救われるならそのコストは支払うに値する。
+
+- **失敗**  
+  うまく成功できなければ、失敗しよう。何をすべきかわからないときには、失敗のリスクを受け入れることが成功につながる最短で確実な道である。
+
+- **品質**  
+  品質が心配だからといって、何もしないことの言い訳にしてはいけない。きれいに実装する方法がわからなければ、できる限りのことをすればいい。きれいだが時間のかかる方法を知っていれば、今の時間でできるかぎりのことをすればいい。
+  そして、あとからきれいな方法で完成させるのだ。こうしたやり方は、アーキテクチャを進化させるときにもよく使う。
+
+- **ベイビーステップ**  
+  大きな変更が失敗してチームがムダに後退するよりも、小さなステップのオーバヘッドのほうが小さい。
+  ベイビーステップは**テストファーストプログラミング**や**継続的インテグレーション**などのプラクティスで表現されている。
+
+- **責任の引き受け**  
+  責任は割り当てるものではなく、引き受けることしかできない。誰かがあなたに責任を担わせようとしても、責任を持つかどうかを選ぶのはあなたである。
+
+---
+
+## 4. プラクティス（Practices）
+
+```plantuml
+@startmindmap
+* XP
+** プラクティス
+*** 主要プラクティス
+**** いきいきとした仕事
+**** 計画
+***** 週次サイクル
+***** 四半期サイクル
+***** ストーリー
+***** ゆとり
+**** プログラミング
+***** テストファーストプログラミング
+***** インクリメンタルな設計
+***** ペアプログラミング
+**** 全員同席
+***** チーム全体
+***** 情報満載のワークスペース
+**** インテグレーション
+***** 10分ビルド
+***** 継続的インテグレーション
+*** 導出プラクティス
+**** ビジネス
+***** 交渉によるスコープ契約
+***** 利用都度課金
+***** デイリーデプロイ
+**** インクリメンタルなデプロイ
+**** チーム
+***** 根本原因分析
+***** 本物の顧客参加
+***** チームの継続
+***** チームの縮小
+**** プログラミング
+***** コードの共有
+***** コードとテスト
+***** 単一のコードベース
+@endmindmap
+```
+**プラクティス**は、日常的な取り組みである。
+
+### 4.1 主要プラクティス（Primary Practices）
+あなたが他にやっているものとは無関係に役に立つものである。
+すぐに改善につながり、どれからでも安全に始められる。
+
+- **全員同席**  
+  **チーム全体**が入れる十分な広さのオープンスペースで開発すること。近くに小さなプライベート空間を用意するか、別の場所でプライバシーを確保できるように労働時間を制限するなどして、チームメンバーのプライバシーや「自分だけの」スペースといった欲求を満たせるようにすること。
+
+- **チーム全体**  
+  チームの全体感。つまり、成功に必要なすべての資源の準備を整えることが、このプラクティスの目的である。プロジェクトの健全性のために綿密なやりとりが必要なところでは、機能単位ではなく、チーム単位でやり取りすべきだ。
+
+- **情報満載のワークスペース**    
+  仕事の内容がわかるようなワークスペースをつくること。プロジェクトに関心のある人がチームのスペースを見たときに、15秒で状況を把握できるようにすべきである。
+  さらに近づいて見たときには、抱えている問題や潜在的な問題に関する詳しい情報を入手できるようにしておこう。
+
+- **いきいきとした仕事**  
+  生産的になれる時間だけ働くこと。無理なく続けられる時間だけ働くこと。意味もなく燃えてきてしまい、次の２日間の作業が台無しになれば、あなたにとってもチームにとってもよろしくない。
+
+- **ペアプログラミング**  
+  ペアプログラミングとは、2人でプログラミング（および分析、設計、テスト）とプログラムの改良を同時に行うやりとりのことである。ペアプログラミングでは、以下のようなことをする。
+  - お互いにタスクに集中する。
+  - システムの改良について意見を出し合う。
+  - アイデアを明確にする。
+  - パートナーがハマったら主導権を握り、相手の失望感を軽減させる。
+  - お互いにチームのプラクティスの説明責任を果たせるようにする。
+
+- **ストーリー**  
+  顧客に見える機能の単位を使って計画すること。たとえば、「これまでのレスポンスタイムで5倍のトラフィックを処理する」「よく使う番号に2クリックの短縮を提供する」などだ。
+　ストーリーが書けたら、必要な開発工程をすぐに見積もること。XPスタイルの計画づくりの特徴は、ストーリーを書いたらすぐに見積もることだ。こうすることで、最小の投資で最大のリターンを得る方法を考えられる。
+
+- **週次サイクル**  
+  1週間分の仕事の計画をまとめて立てること。そして、週のはじめにミーティングを入れること。ミーティングでは、以下のことを行う。
+  - 先週の進捗が期待していた進捗と合致しているかなど、これまでの進捗状況をレビューする。
+  - 今週実装する1週間分のストーリーを顧客に選んでもらう。
+  - ストーリーをタスクに分解する。チームメンバーはタスクにサインアップして、それぞれのタスクを見積もる。
+
+- **四半期サイクル**  
+  四半期分の計画をまとめて立てること。四半期に一度は、チーム、プロジェクト、進捗、大きなゴールの調整について、ふりかえること。四半期の計画では、以下のことを行う。
+  - ボトルネックを特定する（特にチームの外側で制御されているもの）。
+  - 修正作業に着手する。
+  - 四半期のテーマを計画する。
+  - テーマに取り組むための四半期分のストーリーを選択する。
+  - プロジェクトを組織に適合させる全体像に集中する。
+
+- **ゆとり**  
+  どのような計画にも、遅れたときに外せるような重要度の低いタスクを含めること。あとからストーリーを追加したり、約束より多くのストーリーをデリバリーしたりするのは、いつでもできる。
+  不信感を抱かれたり、約束を破ったりしたときは、やるべきことをきちんと果たすことが重要だ。少しでもやるべきことを果たせば、人間関係の再構築につながるはずである。
+
+- **10分ビルド**  
+  自動的にシステム全体をビルドして、すべてのテストを10分以内に実行させること。ビルドに10分以上かかるようだと使用頻度が減り、フィードバックの機会が失われてしまう。
+
+- **継続的インテグレーション**  
+  数時間以内に変更箇所のインテグレーションとテストをすること。チームプログラミングとは、分割統治の問題ではない。分割、統治、結合（インテグレーション）の問題である。
+
+- **テストファーストプログラミング**  
+  コードを変更する前に、失敗する自動テストを書くこと。テストファーストプログラミングは、以下のような多くの問題を一度に解決する。
+  - スコープクリープ - プログラミングに夢中になって我を忘れてしまうと、「念のため」に余計なコードを追加しがちである。プログラムのあるべき姿を明確に客観的に記述すれば、本来のコーディングに集中できる。どうしてもコードを追加したいなら、手元の作業を終えたあとに別のテストを書くようにしよう。
+  - 結合度と凝集度 - テストを書くのが難しければ、テストの問題ではなく、設計に問題があるのだろう。疎結合で凝集度の高いコードは、テストしやすい。
+  - 信頼 - 動かないコードの作者を信頼するのは難しい。動くきれいなコードを書いて、自動テストで意図を示せば、チームメイトから信頼を得られるはずだ。
+  - リズム - コーディングをすると何時間もさまよいがちである。テストファーストでプログラミングすれば、次に何をすべきか（別のテストを書けばいいのか、それとも失敗したテストを修正すればいいのか）が明確になる。そして、それは自然で効率的な開発のリズム（テスト、コード、リファクタ、テスト、コード、リファクタ）なっていく。
+
+- **インクリメンタルな設計**  
+  システムの設計に毎日手を入れること。システムの設計は、その日のシステムのニーズにうまく合致させること。最適だと思われる設計が理解できなくなってきたら、少しだが着実に、自分の理解できる設計に戻していくこと。
+  小さくて安全なステップで稼働中のシステムを変更する経験を踏み重ねていくと、設計にかける労力を遅延させることができるようになる。そうすれば、システムはシンプルになり、進捗は早くなり、テストが書きやすくなる。システムが小さくなるので、チームのコミュニケーションも軽減できる。
+
+### 4.2 導出プラクティス（Corollary Practices）
+先に主要プラクティスを習得しておかなければ難しいだろう
+
+- **本物の顧客参加**  
+  あなたのシステムによって生活やビジネスに影響を受ける人をチームの一員にすること。明確なビジョンを持った顧客であれば、四半期や週単位の計画づくりに参加できる。
+  そうした顧客は自由に使える予算を持っていることもある。予算は開発で利用可能なキャパシティーの一部だ。競合他社より半年も早く問題に気づくような顧客であれば、その顧客が必要とするシステムを構築することによって、あなたの競合他社に対する優位性にもつながる可能性がある。
+
+- **インクリメンタルなデプロイ**  
+  レガシーシステムをリプレースするときは、プロジェクトの初期段階から少しずつ引継ぎをすること。
+
+- **チームの継続**  
+  優秀なチームは継続させること。大きな組織は、ヒトをモノに抽象化する傾向がある。互換性のあるプログラミングユニットだと考えているのだ。ソフトウェアのバリューは、みんなが知っていることや行っていることだけでなく、人間関係やみんなで一緒に成し遂げることによっても生み出される。
+  要員計画の問題を単純化するためだけに、人間関係や信頼の大切さを無視するのは経済的ではない。
+
+- **チームの縮小**  
+  チームの能力が高まったら、仕事量を維持しながら少しづつチームの規模を縮小すること。
+
+- **根本原因分析**  
+  開発後に欠陥が見つかるたびに、欠陥とその原因を取り除くこと。欠陥の再発防止だけではなく、同じ種類の過ちをチームが二度と犯さないようにすることが目的だ。
+  以下は、欠陥に対処するためのXPのプロセスである。
+  - 欠陥を実証するシステムレベルの自動テストを書く。そこには期待する挙動も含めておく。これは、顧客、顧客サポート、開発者が行える。
+  - 結果を再現する最小限のスコープでユニットテストを書く。
+  - ユニットテストが動くようにシステムを修正する。これにより、システムテストもパスするはずだ。パスしなければ、2へ戻る。
+  - 欠陥を修正出来たら、なぜ欠陥が生み出されたのか、なぜ発見できなかったのかを見極める。今後は同様の欠陥が再発しないように、必要な変更を加える。
+
+- **コードの共有**  
+  チームの誰もが、システムのあらゆる部分をいつでも改善できる。システムに問題があり、その修正が現在作業中のスコープの範囲内なのであれば、遠慮せずに修正すべきである。
+
+- **コードとテスト**  
+  コードとテストだけを永続的な作成物として保守すること。その他のドキュメントについては、コードとテストから生成すること。プロジェクトの重要な履歴の維持については、社会的な仕組みに任せること。
+
+- **単一のコードベース**  
+  コードの流れは一つだけである。一時的なブランチで開発することもできるが、数時間以上も維持してはいけない。
+
+- **デイリーデプロイ**  
+  新しいソフトウェアを毎晩プロダクションに反映すること。プログラマーの手元にあるものとプロダクションにあるものが違うのはリスクだ。プログラマーの意思決定につながる正確なフィードバックが得られない危険性がある。
+
+- **交渉によるスコープ契約**  
+  ソフトウェア開発の契約では、期間、費用、品質を固定すること。システムの明確なスコープについては、継続的に交渉を求めること。長期的なひとつの契約ではなく、短期多岐な契約をいくつも結ぶようにして、リスクを減らすこと。
+
+- **利用都度課金**  
+  利用都度課金システムがあれば、システムが利用されるたびにお金を請求することができる。お金は究極のフィードバックだ。お金には実体があり、これから自分で使うこともできる。お金の流れをソフトウェア開発に直接接続すれば、改善を推進するための正確でタイムリーな情報を得られるはずだ。
+
+---
+
+## 5. XPチーム全体
+
+```plantuml
+
+@startuml
+digraph XPTeam {
+A [label="XPチーム全体"]
+B [label="テスター"]
+C [label="インタラクションデザイナー"]
+D [label="アーキテクト"]
+E [label="プロジェクトマネージャー"]
+F [label="プロダクトマネージャー"]
+G [label="経営幹部"]
+H [label="テクニカルライター"]
+I [label="ユーザー"]
+J [label="プログラマー"]
+
+A -> B
+A -> C
+A -> D
+A -> E
+A -> F
+A -> G
+A -> H
+A -> I
+A -> J
+
+G -> E
+G -> F
+G -> I
+E -> D
+D -> J
+E -> J
+J -> I
+E -> C
+E -> I
+C -> I
+E -> B
+B -> J
+B -> I
+E -> H
+H -> I
+F -> I
+}
+@enduml
+```
+
+- **テスター**  
+  XPチームのテスターは、システムレベルの自動テストの選択や記述について開発前に顧客を支援したり、プログラマーにテスト技法をコーチしたりする。
+
+- **インタラクションデザイナー**  
+  XPチームのインタラクションデザイナーは、システム全体のメタファーを選んだり、**ストーリー**を書いたり、デプロイされたシステムの利用状況を評価して、新しいストーリーの機会を見つけたりする。
+  XPチームでは、インタクラクションデザイナーは顧客と一緒に働いて、ストーリーの記述や明確化を支援する。
+
+- **アーキテクト**  
+  XPチームのアーキテクトは、大規模リファクタリングの調査や実施をしたり、アーキテクチャにストレスを与えるシステムレベルのテストを書いたり、**ストーリー**を実装したりする。
+  XPチームのアーキテクトのもうひとつの仕事は、システムの分割だ。分割は事前に行う一度きりのタスクではない。XPチームは統治分割を行う。分割統治ではない。つまり、小さなチームで小さなシステムを作ってから、自然な切れ目を見つけ、比較的独立した単位に分割して、システムを拡張するのである。
+
+- **プロジェクトマネージャー**  
+  XPチームのプロジェクトマネージャーは、チーム内のコミュニケーションを円滑にしたり、顧客、サプライヤー、その他のチーム外の組織とのコミュニケーションを調整したりする。
+
+- **プロダクトマネージャー**  
+  XPのプロダクトマネージャーは、**ストーリー**を書いたり、**四半期サイクル**のテーマやストーリーを選択したり、**週次サイクル**のストーリーを選択したり、実装によって明らかになったストーリーのあいまいな部分の質問に答えたりする。
+
+- **経営幹部**  
+  経営幹部は、XPチームに勇気、自信、説明責任を提供する。
+
+- **テクニカルライター**  
+  XPチームにおけるテクニカルパブリケーションの役割は、フィーチャーのフィードバックを早期に提供したり、ユーザーとの密接な関係を築いたりすることである。
+
+- **ユーザー**  
+  XPチームのユーザーは、開発中にストーリーの記述や選択の支援をしたり、専門領域の意思決定をしたりする。構築中のシステムと類似したシステムに関する幅広い知識や経験をもっていたり、システムを実際に利用するユーザーコミュニティとの強い関係性を持っていたりすれば、そのユーザーは非常に大切な存在だ。
+
+- **プログラマー**  
+  XPチームのプログラマーは、**ストーリー**やタスクを見積もったり、ストーリーをタスクに分解したり、テストを書いたり、フィーチャーを実装するコードを書いたり、退屈な開発プロセスを自動化したり、システムの設計を少しづつ改善したりする。
+
+- **人事**  
+  XPチームのメンバーを個人として評価するといっても、XP適用前の評価の仕方を大きく変える必要はない。以下は、XPにおける重要性の高い従業員だ。
+  - リスペクトを持って行動できる。
+  - 他人とうまくやれる。
+  - イニシアチブをとれる。
+  - 約束したものデリバリーできる。
+
+- **その他の役割**  
+  必要に応じた追加役割。
+
+---
+
+## 6. チェックリスト
+
+### 主要プラクティス
+
+- [ ] **いきいきとした仕事**
+  - 生産的になれる時間だけ働いていますか？
+
+#### **計画**
+- [ ] **週次サイクル**
+  - 1週間分の計画を作成し、進捗をレビューしていますか？
+  - ストーリーをタスクに分解していますか？
+
+- [ ] **四半期サイクル**
+  - チームの進捗やボトルネックをレビューしていますか？
+  - 四半期ごとの計画テーマを設定していますか？
+
+- [ ] **ストーリー**
+  - ストーリー単位で顧客に機能を提案していますか？
+
+- [ ] **ゆとり**
+  - 計画に重要度の低いタスクを含め、余裕を持っていますか？
+
+#### **プログラミング**
+- [ ] **テストファーストプログラミング**
+  - コードを書く前に失敗するテストを書く習慣がありますか？
+
+- [ ] **インクリメンタルな設計**
+  - 小さい手順でシステムの設計・改善を行っていますか？
+
+- [ ] **ペアプログラミング**
+  - 2人でアイデアを共有しながらコードを書いていますか？
+
+#### **全員同席**
+- [ ] **チーム全体**
+  - 必要なスキルやリソースをチーム全体で共有していますか？
+
+- [ ] **情報満載のワークスペース**
+  - 外部の訪問者が15秒で状況を把握できるように情報を可視化していますか？
+
+#### **インテグレーション**
+- [ ] **10分ビルド**
+  - すべてのテストを含むビルドが10分以内に完了しますか？
+
+- [ ] **継続的インテグレーション**
+  - 数時間おきに変更をマージしてテストを実行していますか？
+
+---
+
+### 導出プラクティス
+
+#### **ビジネス**
+- [ ] **交渉によるスコープ契約**
+  - スコープを柔軟に交渉しながら契約内容を進めていますか？
+
+- [ ] **利用都度課金**
+  - ソフトウェアが使用されるたびに課金モデルを取り入れていますか？
+
+- [ ] **デイリーデプロイ**
+  - 毎日ソフトウェアをプロダクションにデプロイしていますか？
+
+#### **インクリメンタルなデプロイ**
+- [ ] 徐々にレガシーシステムのリプレースを進めていますか？
+
+#### **チーム**
+- [ ] **根本原因分析**
+  - バグの原因を調査し、再発防止策を講じていますか？
+
+- [ ] **本物の顧客参加**
+  - 顧客が計画作成や改善に参加していますか？
+
+- [ ] **チームの継続**
+  - チームメンバーが一貫性を持って協力していますか？
+
+- [ ] **チームの縮小**
+  - チームが成長した段階で規模を縮小して効率化していますか？
+
+#### **プログラミング**
+- [ ] **コードの共有**
+  - メンバー全員がシステムの任意の部分を改善できますか？
+
+- [ ] **コードとテスト**
+  - 永続する作成物としてコードとテストのみを保守していますか？
+
+- [ ] **単一のコードベース**
+  - ブランチを短期間で管理し、コードの中心ラインを保っていますか？
+
diff --git "a/docs/reference/\351\226\213\347\231\272\343\202\254\343\202\244\343\203\211.md" "b/docs/reference/\351\226\213\347\231\272\343\202\254\343\202\244\343\203\211.md"
new file mode 100644
index 0000000..15027cc
--- /dev/null
+++ "b/docs/reference/\351\226\213\347\231\272\343\202\254\343\202\244\343\203\211.md"
@@ -0,0 +1,195 @@
+# 開発ガイド
+
+## ライフサイクル
+
+要件では、アプリケーションの機能や性能、品質、セキュリティ、運用、保守などの要件をまとめる活動を行います。開発では要件を満たすための設計、実装、テストなどの活動を行います。運用では、アプリケーションの運用、保守、改善などの活動を行います。構築では、アプリケーションの環境設定を行います。配置では、アプリケーションのビルドとデプロイを行います。これらの活動は相互に影響し合い、連携して行われるため、それぞれの活動において、開発者が守るべき規則やガイドラインをまとめたドキュメントを参照してください。
+
+```plantuml
+@startuml
+[*] --> 要件
+要件 --> 開発
+要件 -right-> 運用
+運用 -left-> 要件
+開発 -left-> 要件
+開発 --> 運用
+運用 --> 開発
+運用 --> 配置
+運用 -up-> 構築
+構築 --> 配置
+運用 ---> [*]
+
+state 要件 #red
+state 構築 #limegreen
+state 運用 #orange
+state 開発 #purple
+state 配置 #lightblue
+@enduml
+```
+## 開発プロセス
+
+アプリケーション開発は、アジャイル開発手法（XP）に基づいて進めます。
+
+詳細は [エクストリームプログラミング](エクストリームプログラミング) を参照。
+
+### 開発サイクル
+
+```plantuml
+@startuml
+
+[*] --> リリース
+
+state リリース {
+  満足条件1: （ユーザーストーリー、予算、スケジュール)
+  満足条件1 -->リリースプランニング
+  リリースプランニング --> 満足条件1 
+}
+
+state イテレーション {
+  リリースプランニング --> 満足条件2
+  満足条件2: （ユーザーストーリー、予算、スケジュール)
+  満足条件2 --> イテレーションプランニング
+  イテレーションプランニング --> 満足条件2
+  イテレーションプランニング --> 開発
+  開発 --> フィーチャが追加された状態
+  フィーチャが追加された状態 --> 満足条件2 : フィードバック
+  フィーチャが追加された状態 --> 満足条件1 : フィードバック
+}
+
+リリース --> [*]
+
+@enduml
+```
+
+計画づくりの詳細は [アジャイルな見積と計画づくり](アジャイルな見積と計画づくり)	 を参照。
+
+### 開発フロー
+
+```plantuml
+@startuml
+[*] --> リリース計画
+リリース計画 --> イテレーション計画
+イテレーション計画 --> コーディングとテスト
+コーディングとテスト --> イテレーションレビュー
+イテレーションレビュー --> イテレーション計画
+イテレーションレビュー --> [*]
+@enduml
+```
+
+```plantuml
+@startuml
+
+[*] --> イテレーション計画
+イテレーション計画 --> ユーザーストーリー作成
+ユーザーストーリー作成 --> ユースケース作成
+ユースケース作成 --> データモデル設計
+アーキテクチャ設計 --> コーディングとテスト
+コーディングとテスト --> アーキテクチャ設計
+データモデル設計 --> コーディングとテスト
+コーディングとテスト --> データモデル設計
+ドメインモデル設計 --> コーディングとテスト
+コーディングとテスト --> ドメインモデル設計
+コーディングとテスト --> ユーザーインターフェース設計
+ユーザーインターフェース設計 --> コーディングとテスト
+コーディングとテスト --> ユースケース作成
+コーディングとテスト --> イテレーションレビュー
+イテレーションレビュー --> イテレーション計画
+イテレーションレビュー --> [*]
+
+@enduml
+```
+
+## コーディングとテスト
+
+実装は、以下の2つのアプローチを状況に応じて使い分けます：
+
+1. インサイドアウトアプローチ
+- データモデルから実装を開始
+- ドメイン駆動設計に適合
+- テストファーストな開発
+
+2. アウトサイドインアプローチ
+- UIから実装を開始
+- プロトタイプ駆動開発に適合
+- モックを活用した開発
+
+
+```plantuml
+@startuml
+start
+:ユーザーストーリー;
+if (CRUD実装済み?) then (はい)
+  :ドメインモデル;
+  :アウトサイドイン;
+else (いいえ)
+  :貧血ドメインモデル;
+  :インサイドサイドアウト;
+endif
+if (API実装済み?) then (はい)
+  :インサイドサイドアウト;
+else (いいえ)
+  :アウトサイドイン;
+endif
+stop
+@enduml
+```
+#### インサイドアウト
+
+```plantuml
+@startuml
+start
+:データベース;
+:インフラストラクチャ層;
+:ドメイン層;
+:サービス層;
+:プレゼンテーション層;
+stop
+@enduml
+```
+
+```plantuml
+@startuml
+[*] --> コーディングとテスト
+コーディングとテスト --> TODO : TODOリストを作成
+TODO --> Red : 最小限の実装
+Red --> Green : テストを書く
+Green --> Refactor : リファクタリング
+Refactor --> Red : 次の実装
+Red : 動作の確認
+Green : テストが成功
+Refactor : コードの重複を除去してリファクタリング
+Refactor --> TODO : リファクタリングが完了したらTODOリストに戻る
+TODO --> コーディングとテスト : TODOリストが空になるまで繰り返す
+コーディングとテスト --> イテレーションレビュー
+@enduml
+```
+
+#### アウトサイドイン
+
+```plantuml
+@startuml
+start
+:プレゼンテーション層;
+:サービス層;
+:ドメイン層;
+:インフラストラクチャ層;
+:データベース;
+stop
+@enduml
+```
+
+```plantuml
+@startuml
+[*] --> コーディングとテスト
+コーディングとテスト --> TODO : TODOリストを作成
+TODO --> Red : テストを書く
+Red --> Green : 最小限の実装
+Green --> Refactor : リファクタリング
+Refactor --> Red : 次のテストを書く
+Red : テストに失敗
+Green : テストに通る最小限の実装
+Refactor : コードの重複を除去してリファクタリング
+Refactor --> TODO : リファクタリングが完了したらTODOリストに戻る
+TODO --> コーディングとテスト : TODOリストが空になるまで繰り返す
+コーディングとテスト --> イテレーションレビュー
+@enduml
+```
\ No newline at end of file
diff --git a/docs/requirements/.gitkeep b/docs/requirements/.gitkeep
new file mode 100644
index 0000000..e69de29

```

