# 作業履歴 2025-07-25

## 概要

2025-07-25の作業内容をまとめています。

## コミット: 41b62bd

### メッセージ

```
docs: イテレーション4のふりかえりを完了
- 実装結果: 102個のテストケース全通過
- 上向きぷよ着地バグの修正完了
- 下キー入力検出システムの完成
- 高速落下処理システムの完成
- 包括的な落下・着地判定システムの完成
- TDDサイクル（Red-Green-Refactor）を継続実践
- 次イテレーション5（ぷよの消去処理）への準備完了

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts
- M	docs/requirement.md

### 変更内容

```diff
commit 41b62bdabb3ce59a598a8e334782096eaabd310f
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 19:30:07 2025 +0900

    docs: イテレーション4のふりかえりを完了
    
    - 実装結果: 102個のテストケース全通過
    - 上向きぷよ着地バグの修正完了
    - 下キー入力検出システムの完成
    - 高速落下処理システムの完成
    - 包括的な落下・着地判定システムの完成
    - TDDサイクル（Red-Green-Refactor）を継続実践
    - 次イテレーション5（ぷよの消去処理）への準備完了
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index 420c18b..01cd00c 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -642,4 +642,14 @@ export class Game {
     // 新しい操作ぷよを生成
     this.spawnActivePuyo()
   }
+
+  // テスト用メソッド: 落下可能かどうかをチェック
+  canFallTest(): boolean {
+    return this.canFall()
+  }
+
+  // テスト用メソッド: 着地しているかどうかをチェック
+  hasLandedTest(): boolean {
+    return !this.canFall()
+  }
 }
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index bc38d2f..b901e71 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1524,5 +1524,195 @@ describe('Game', () => {
         }
       })
     })
+
+    describe('落下可能性チェック', () => {
+      it('下に空きスペースがあるときは落下可能', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 中央上部に配置
+          activePuyo.x = 2
+          activePuyo.y = 5
+          activePuyo.direction = 0 // 縦配置
+
+          // 落下可能かチェック
+          expect(game.canFallTest()).toBe(true)
+        }
+      })
+
+      it('下に障害物があるときは落下不可能', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 障害物を設置（y=10とy=11にぷよを配置）
+          const field = game.getField()
+          field[10][2] = 1 // 障害物
+          field[11][2] = 2 // 障害物
+
+          // 障害物の直上に配置
+          activePuyo.x = 2
+          activePuyo.y = 9
+          activePuyo.direction = 0 // 縦配置
+
+          // 落下不可能のはず
+          expect(game.canFallTest()).toBe(false)
+        }
+      })
+
+      it('底面に達したときは落下不可能', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 底面に配置
+          activePuyo.x = 2
+          activePuyo.y = 12 // 底面
+          activePuyo.direction = 0 // 縦配置
+
+          // 落下不可能のはず
+          expect(game.canFallTest()).toBe(false)
+        }
+      })
+
+      it('上向きぷよでも正しく落下可能性を判定する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 上向き配置で中央に配置
+          activePuyo.x = 2
+          activePuyo.y = 5
+          activePuyo.direction = 2 // 上向き
+
+          // 落下可能のはず
+          expect(game.canFallTest()).toBe(true)
+        }
+      })
+
+      it('横向きぷよでも正しく落下可能性を判定する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 横向き配置で中央に配置
+          activePuyo.x = 2
+          activePuyo.y = 5
+          activePuyo.direction = 1 // 右向き
+
+          // 落下可能のはず
+          expect(game.canFallTest()).toBe(true)
+        }
+      })
+    })
+
+    describe('着地判定', () => {
+      it('ぷよが着地したことを正しく検知する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 底面近くに配置
+          activePuyo.x = 2
+          activePuyo.y = 11 // 底面の1つ上
+          activePuyo.direction = 0 // 縦配置
+
+          // 着地判定をテスト
+          expect(game.hasLandedTest()).toBe(true)
+        }
+      })
+
+      it('まだ落下できる状態では着地していない', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 中央に配置
+          activePuyo.x = 2
+          activePuyo.y = 5
+          activePuyo.direction = 0 // 縦配置
+
+          // まだ着地していないはず
+          expect(game.hasLandedTest()).toBe(false)
+        }
+      })
+
+      it('他のぷよの上に着地したことを検知する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 障害物を設置
+          const field = game.getField()
+          field[10][2] = 1 // 障害物
+
+          // 障害物の直上に配置
+          activePuyo.x = 2
+          activePuyo.y = 9
+          activePuyo.direction = 0 // 縦配置（2つ目がy=10になる）
+
+          // 着地しているはず
+          expect(game.hasLandedTest()).toBe(true)
+        }
+      })
+
+      it('複雑な配置でも正しく着地判定する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 複雑な障害物パターンを作成
+          const field = game.getField()
+          field[11][1] = 1 // 左に障害物
+          field[11][3] = 2 // 右に障害物
+          field[10][2] = 3 // 中央下に障害物
+
+          // 障害物の上に配置
+          activePuyo.x = 2
+          activePuyo.y = 9
+          activePuyo.direction = 0 // 縦配置
+
+          // 着地しているはず
+          expect(game.hasLandedTest()).toBe(true)
+
+          // 落下処理は内部的に処理されるので、直接processLandingを実行
+          game.processLanding()
+
+          // 着地により新しいぷよが生成されるはず
+          const newActivePuyo = game.getActivePuyo()
+          expect(newActivePuyo).not.toBeNull()
+          expect(newActivePuyo!.y).toBe(0) // 新しいぷよは初期位置
+        }
+      })
+    })
+
+    describe('統合テスト: 落下から着地まで', () => {
+      it('高速落下中も正しく着地判定が働く', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 底面近くに配置
+          activePuyo.x = 2
+          activePuyo.y = 11 // より底面に近い位置
+          activePuyo.direction = 0 // 縦配置
+
+          // 下キーを押して高速落下
+          const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+          game.handleKeyDown(downKeyEvent)
+
+          // 高速落下処理を実行（着地するまで）
+          game.updateAndRender()
+
+          // 着地により新しいぷよが生成されているはず
+          const newActivePuyo = game.getActivePuyo()
+          expect(newActivePuyo).not.toBeNull()
+          expect(newActivePuyo!.y).toBe(0) // 新しいぷよは初期位置
+
+          // フィールドに前のぷよが固定されているはず
+          const field = game.getField()
+          expect(field[11][2]).not.toBe(0) // 中心ぷよが固定
+          expect(field[12][2]).not.toBe(0) // 2つ目のぷよが固定
+        }
+      })
+
+      it('回転後も正しく落下可能性を判定する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 底面に配置
+          activePuyo.x = 2
+          activePuyo.y = 12 // 底面
+          activePuyo.direction = 0 // 縦配置
+
+          // 回転して横配置にする
+          activePuyo.direction = 1 // 右向き
+
+          // 横配置でも落下可能性を正しく判定するはず
+          expect(game.canFallTest()).toBe(false) // 底面なので落下不可
+          expect(game.hasLandedTest()).toBe(true) // 着地している
+        }
+      })
+    })
   })
 })
diff --git a/docs/requirement.md b/docs/requirement.md
index 58392ea..d0070f0 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -296,20 +296,47 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] 下キー入力の検出を実装する（キーボードの下キーが押されたことを検知する）
-- [ ] 高速落下処理を実装する（下キーが押されているときは落下速度を上げる）
-- [ ] 落下可能かどうかのチェックを実装する（下に障害物がある場合は落下できないようにする）
-- [ ] 着地判定を実装する（ぷよが着地したことを検知する）
+- [x] 下キー入力の検出を実装する（キーボードの下キーが押されたことを検知する）
+- [x] 高速落下処理を実装する（下キーが押されているときは落下速度を上げる）
+- [x] 落下可能かどうかのチェックを実装する（下に障害物がある場合は落下できないようにする）
+- [x] 着地判定を実装する（ぷよが着地したことを検知する）
 
 ### WebUI確認項目
-- 下キーでぷよが高速落下する
-- 着地時に適切に停止する
+- ✅ 下キーでぷよが高速落下する
+- ✅ 着地時に適切に停止する
+
+### 実装結果
+- 102個のテストケースが全て通過
+- TDDサイクル（Red-Green-Refactor）を継続実践
+- 上向きぷよ着地バグの修正完了
+- 下キー入力検出システムの完成
+- 高速落下処理システムの完成
+- 包括的な落下・着地判定システムの完成
 
 ### ふりかえり
 
 *   **Keep**:
+    - TDDサイクル（Red-Green-Refactor）の継続により、品質の高い実装を維持できた
+    - 既存バグ（上向きぷよの着地問題）を発見し、適切に修正できた
+    - 既存実装の再利用（canFall()メソッド）により、効率的な開発ができた
+    - テストファーストアプローチにより、期待する動作を明確化してから実装に取り組めた
+    - 小さなコミット単位での実装により、変更点が明確で安全なバージョン管理ができた
+    - 包括的なテストケース（102個）により、システムの信頼性が高まった
+    - Canvas APIモックの安定性により、一貫したテスト環境を維持できた
+
 *   **Problem**:
+    - 上向きぷよの着地バグ修正で、canFall()メソッドの境界チェックロジックの見直しが必要だった
+    - 初期のupdateFalling()テストで、既存実装の動作理解に時間を要した
+    - 詳細な統合テストで、テストケースの調整（位置設定など）が必要だった
+    - テストケース数が102個と多くなり、実行時間が長くなった
+    - 既存機能の動作確認で、実装の詳細把握に時間がかかった
+
 *   **Try**:
+    - 次イテレーションではぷよの消去処理を実装する（4つ以上つながったぷよの検出と消去）
+    - より複雑なアルゴリズム（連結判定、再帰的探索）のテスト戦略を事前に検討する
+    - パフォーマンステスト（大量のぷよ処理時の効率）の導入を検討する
+    - ゲームロジックが複雑化するため、モジュール分割の検討を始める
+    - WebUI での実際の消去動作確認プロセスを確立する
 
 ## イテレーション5: ぷよの消去の実装
 

```

## コミット: 2bea8a3

### メッセージ

```
feat: 高速落下処理を実装
- 下キーが押されているときの高速落下機能を追加
- updateFalling()メソッドを修正して即座に落下処理を実行
- shouldFallByTimer()とperformFallOrLanding()メソッドに分離してリファクタリング
- 高速落下のテストケースを3つ追加（基本機能、通常速度、継続的落下）
- 全91テストが通過、TDDサイクル（Red-Green-Refactor）を完全実践

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit 2bea8a300d653c64beb64912bda8a874d4c484d3
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 19:15:17 2025 +0900

    feat: 高速落下処理を実装
    
    - 下キーが押されているときの高速落下機能を追加
    - updateFalling()メソッドを修正して即座に落下処理を実行
    - shouldFallByTimer()とperformFallOrLanding()メソッドに分離してリファクタリング
    - 高速落下のテストケースを3つ追加（基本機能、通常速度、継続的落下）
    - 全91テストが通過、TDDサイクル（Red-Green-Refactor）を完全実践
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index a35fbe3..420c18b 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -37,6 +37,7 @@ export class Game {
   private leftKeyPressed = false
   private rightKeyPressed = false
   private upKeyPressed = false
+  private downKeyPressed = false
   private moveTimer = 0 // 移動タイマー
   private rotationTimer = 0 // 回転タイマー
   private static readonly MOVE_INTERVAL = 8 // 移動間隔（フレーム数）
@@ -268,17 +269,32 @@ export class Game {
   updateFalling(): void {
     if (!this.activePuyo) return
 
+    // 下キーが押されている場合は高速落下、そうでなければタイマーで制御
+    const shouldFall = this.downKeyPressed || this.shouldFallByTimer()
+
+    if (shouldFall) {
+      this.performFallOrLanding()
+    }
+  }
+
+  private shouldFallByTimer(): boolean {
     this.fallTimer++
     if (this.fallTimer >= this.fallInterval) {
       this.fallTimer = 0
+      return true
+    }
+    return false
+  }
 
-      // 落下可能かチェック
-      if (this.canFall()) {
-        this.activePuyo.y += this.fallSpeed
-      } else {
-        // 着地処理を実行
-        this.processLanding()
-      }
+  private performFallOrLanding(): void {
+    if (!this.activePuyo) return
+
+    // 落下可能かチェック
+    if (this.canFall()) {
+      this.activePuyo.y += this.fallSpeed
+    } else {
+      // 着地処理を実行
+      this.processLanding()
     }
   }
 
@@ -315,6 +331,9 @@ export class Game {
       case 'ArrowUp':
         this.upKeyPressed = true
         break
+      case 'ArrowDown':
+        this.downKeyPressed = true
+        break
     }
   }
 
@@ -329,6 +348,9 @@ export class Game {
       case 'ArrowUp':
         this.upKeyPressed = false
         break
+      case 'ArrowDown':
+        this.downKeyPressed = false
+        break
     }
   }
 
@@ -340,6 +362,10 @@ export class Game {
     return this.rightKeyPressed
   }
 
+  isDownKeyPressed(): boolean {
+    return this.downKeyPressed
+  }
+
   setupInputHandlers(): void {
     addEventListener('keydown', this.handleKeyDown.bind(this))
     addEventListener('keyup', this.handleKeyUp.bind(this))
@@ -349,6 +375,7 @@ export class Game {
     this.leftKeyPressed = false
     this.rightKeyPressed = false
     this.upKeyPressed = false
+    this.downKeyPressed = false
   }
 
   updateMovement(): void {
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index c386baf..bc38d2f 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1348,6 +1348,38 @@ describe('Game', () => {
       })
     })
 
+    describe('下キー入力の処理', () => {
+      it('下キーが押されたことを検出できる', () => {
+        const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+        game.handleKeyDown(downKeyEvent)
+
+        expect(game.isDownKeyPressed()).toBe(true)
+      })
+
+      it('下キーが離されたことを検出できる', () => {
+        // 最初に下キーを押す
+        const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+        game.handleKeyDown(downKeyEvent)
+        expect(game.isDownKeyPressed()).toBe(true)
+
+        // 下キーを離す
+        const upKeyEvent = new KeyboardEvent('keyup', { key: 'ArrowDown' })
+        game.handleKeyUp(upKeyEvent)
+        expect(game.isDownKeyPressed()).toBe(false)
+      })
+
+      it('入力状態リセットで下キーもリセットされる', () => {
+        // 下キーを押す
+        const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+        game.handleKeyDown(downKeyEvent)
+        expect(game.isDownKeyPressed()).toBe(true)
+
+        // 入力状態をリセット
+        game.resetInputState()
+        expect(game.isDownKeyPressed()).toBe(false)
+      })
+    })
+
     describe('上向きぷよの着地判定', () => {
       it('上向きぷよが底面まで正しく落下する', () => {
         const activePuyo = game.getActivePuyo()
@@ -1432,5 +1464,65 @@ describe('Game', () => {
         }
       })
     })
+
+    describe('高速落下処理', () => {
+      it('下キーが押されているときは落下速度が上がる', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 初期位置を記録
+          const initialY = activePuyo.y
+
+          // 通常の落下速度を確認（fallIntervalをデフォルトの30に設定）
+          game.setFallInterval(30)
+
+          // 下キーを押す
+          const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+          game.handleKeyDown(downKeyEvent)
+
+          // 1フレーム更新
+          game.updateAndRender()
+
+          // 下キーが押されているときは即座に落下するはず
+          expect(activePuyo.y).toBeGreaterThan(initialY)
+        }
+      })
+
+      it('下キーが押されていないときは通常の落下速度', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 初期位置を記録
+          const initialY = activePuyo.y
+
+          // 通常の落下間隔を設定
+          game.setFallInterval(30)
+
+          // 下キーを押さずに1フレーム更新
+          game.updateAndRender()
+
+          // 通常の落下間隔なので、まだ落ちないはず
+          expect(activePuyo.y).toBe(initialY)
+        }
+      })
+
+      it('下キーを押し続けると継続的に高速落下する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 初期位置を記録
+          const initialY = activePuyo.y
+
+          // 下キーを押す
+          const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
+          game.handleKeyDown(downKeyEvent)
+
+          // 複数フレーム更新
+          for (let i = 0; i < 5; i++) {
+            game.updateAndRender()
+          }
+
+          // 継続的に落下しているはず
+          expect(activePuyo.y).toBeGreaterThan(initialY + 3)
+        }
+      })
+    })
   })
 })

```

## コミット: 926dc39

### メッセージ

```
fix: 上向きぷよの着地判定を修正
- canFall()メソッドの着地判定をぷよの実際の位置に基づいて計算するよう修正
- canMoveDown()メソッドの境界チェックを簡略化
- 上向きぷよ（direction=2）が正しく底面まで落下するようテストを追加
- setFallInterval()メソッドをテスト用に追加

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit 926dc39466349edafc3843fcac1fb409f457778c
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 19:07:52 2025 +0900

    fix: 上向きぷよの着地判定を修正
    
    - canFall()メソッドの着地判定をぷよの実際の位置に基づいて計算するよう修正
    - canMoveDown()メソッドの境界チェックを簡略化
    - 上向きぷよ（direction=2）が正しく底面まで落下するようテストを追加
    - setFallInterval()メソッドをテスト用に追加
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index 460fd8d..a35fbe3 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -285,9 +285,14 @@ export class Game {
   private canFall(): boolean {
     if (!this.activePuyo) return false
 
-    // フィールドの底部に到達した場合（ぷよは2つ分の高さなので、+2で判定）
-    if (this.activePuyo.y + 2 >= Game.FIELD_HEIGHT) {
-      return false
+    // 現在の操作ぷよの位置を取得
+    const positions = this.getActivePuyoPositions()
+
+    // すべてのぷよの位置が底面に到達していないかチェック
+    for (const pos of positions) {
+      if (pos.y >= Game.FIELD_HEIGHT - 1) {
+        return false
+      }
     }
 
     // canMoveDown()と同じ衝突判定を使用
@@ -440,6 +445,11 @@ export class Game {
     this.fallInterval = 99999 // 非常に大きな値にして実質的に無効化
   }
 
+  // テスト用のメソッド：落下間隔を設定する
+  setFallInterval(interval: number): void {
+    this.fallInterval = interval
+  }
+
   clearActivePuyo(): void {
     this.activePuyo = null
   }
@@ -458,12 +468,7 @@ export class Game {
     const targetX = this.activePuyo.x
     const targetY = this.activePuyo.y + 1
 
-    // フィールドの境界チェック（底面判定）
-    if (targetY + 1 >= Game.FIELD_HEIGHT) {
-      return false
-    }
-
-    // 他のぷよとの衝突チェック
+    // 移動後の位置をチェック
     return this.isPuyoPositionEmpty(targetX, targetY)
   }
 
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index 902bf01..c386baf 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1347,5 +1347,90 @@ describe('Game', () => {
         expect(typeof game.tryWallKick).toBe('function')
       })
     })
+
+    describe('上向きぷよの着地判定', () => {
+      it('上向きぷよが底面まで正しく落下する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 上向きの配置にセット（direction = 2）
+          activePuyo.x = 2
+          activePuyo.y = 10 // 底面近くから開始
+          activePuyo.direction = 2 // 上向き
+
+          // 落下を有効にする
+          game.setFallInterval(1) // 毎フレーム落下
+
+          let finalY = -1
+          // 底面まで落下させる
+          for (let i = 0; i < 10; i++) {
+            const currentPuyo = game.getActivePuyo()
+            if (currentPuyo) {
+              finalY = currentPuyo.y
+            }
+
+            game.updateAndRender()
+
+            // 着地したかチェック
+            if (!game.getActivePuyo()) {
+              break
+            }
+          }
+
+          // 上向きぷよの最終着地位置をチェック
+          // フィールドサイズは13（0-12）で、上向きぷよは2つ目が上（y-1）にある
+          // 実際の着地位置は、フィールドの境界に制限される
+
+          // フィールドに固定されているか確認
+          const field = game.getField()
+
+          // 着地したぷよがフィールドに配置されている
+          let foundPuyos = 0
+          for (let y = 0; y < 13; y++) {
+            if (field[y][2] !== 0) {
+              foundPuyos++
+            }
+          }
+          expect(foundPuyos).toBe(2) // 2つのぷよが配置されている
+
+          // 底面近くにぷよが配置されていることを確認
+          expect(field[12][2]).not.toBe(0) // 底面にぷよ
+          expect(field[11][2]).not.toBe(0) // その上にぷよ
+        }
+      })
+
+      it('上向きぷよが他のぷよの上に正しく着地する', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // フィールドの底部に障害物を設置
+          const field = game.getField()
+          field[11][2] = 1 // 底部に障害物
+
+          // 上向きの配置にセット
+          activePuyo.x = 2
+          activePuyo.y = 0
+          activePuyo.direction = 2 // 上向き
+
+          // 落下を有効にする
+          game.setFallInterval(1) // 毎フレーム落下
+
+          // 障害物に当たるまで落下させる
+          for (let i = 0; i < 20; i++) {
+            game.updateAndRender()
+
+            // 着地したかチェック
+            if (!game.getActivePuyo()) {
+              break
+            }
+          }
+
+          // 新しいぷよが生成されていることを確認（着地完了）
+          expect(game.getActivePuyo()).not.toBeNull()
+
+          // フィールドに正しい位置に固定されているか確認
+          expect(field[10][2]).not.toBe(0) // 中心ぷよが障害物の上に固定
+          expect(field[9][2]).not.toBe(0) // 2つ目のぷよがさらに上に固定
+        }
+      })
+    })
   })
 })

```

## コミット: 74e9370

### メッセージ

```
docs: イテレーション3完了のふりかえりを更新
- 全TODO項目の完了を記録
- TDD継続実践の成果を記録
- 壁キック処理などの複雑な物理演算の実装完了を記録
- 83個のテストケース全通過を記録
- 次イテレーションに向けた改善点を整理

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	docs/requirement.md

### 変更内容

```diff
commit 74e93709b1662ea7d862dc0c72cb858e39a98cf0
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 14:40:49 2025 +0900

    docs: イテレーション3完了のふりかえりを更新
    
    - 全TODO項目の完了を記録
    - TDD継続実践の成果を記録
    - 壁キック処理などの複雑な物理演算の実装完了を記録
    - 83個のテストケース全通過を記録
    - 次イテレーションに向けた改善点を整理
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/docs/requirement.md b/docs/requirement.md
index c312e44..58392ea 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -252,21 +252,45 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] ぷよの回転処理を実装する（時計回り・反時計回りの回転）
-- [ ] 回転可能かどうかのチェックを実装する（他のぷよや壁にぶつかる場合は回転できないようにする）
-- [ ] 壁キック処理を実装する（壁際での回転を可能にする特殊処理）
-- [ ] 回転後の表示を更新する（画面上でぷよの位置が変わったことを表示する）
+- [x] ぷよの回転処理を実装する（時計回り・反時計回りの回転）
+- [x] 回転可能かどうかのチェックを実装する（他のぷよや壁にぶつかる場合は回転できないようにする）
+- [x] 壁キック処理を実装する（壁際での回転を可能にする特殊処理）
+- [x] 回転後の表示を更新する（画面上でぷよの位置が変わったことを表示する）
 
 ### WebUI確認項目
-- 上キーでぷよが時計回りに回転する
-- 壁際での壁キック処理が動作する
-- 回転制限が適切に働く
+- ✅ 上キーでぷよが時計回りに回転する
+- ✅ 壁際での壁キック処理が動作する
+- ✅ 回転制限が適切に働く
+
+### 実装結果
+- 83個のテストケースが全て通過
+- TDDサイクル（Red-Green-Refactor）を継続実践
+- 時計回り回転機能の完成
+- 衝突判定システムの完成
+- 壁キック処理システムの完成
+- 回転タイミング制御システムの完成
 
 ### ふりかえり
 
 *   **Keep**:
+    - TDDサイクル（Red-Green-Refactor）の継続により、品質の高い実装を維持できた
+    - 壁キック処理のような複雑な物理演算もテストファーストで実装できた
+    - 失敗テストから始めることで、期待する動作を明確化してから実装に取り組めた
+    - 小さなコミット単位での実装により、変更点が明確で安全なバージョン管理ができた
+    - 回転方向の管理（0-3の循環）により、直感的な回転システムを実現できた
+    - ヘルパーメソッド（canRotateAt, getPuyoPositionsForTest）により、コードの再利用性が高まった
+
 *   **Problem**:
+    - 壁キック処理のテストケース設計で、全方向の障害物設置が必要だった
+    - 回転タイミング制御（15フレーム間隔）により、テスト実行時間が少し長くなった
+    - 複雑な物理演算の実装で、デバッグに時間を要した
+    - Canvas モック設定に追加の準備が必要だった
+
 *   **Try**:
+    - 次イテレーションでは高速落下処理を実装する（下キー入力による加速）
+    - より複雑なゲーム mechanics（連鎖反応）に向けたテスト戦略を検討する
+    - パフォーマンスの最適化（特に物理演算の効率化）を検討する
+    - WebUI での実際の動作確認プロセスを確立する
 
 ## イテレーション4: ぷよの高速落下の実装
 

```

## コミット: 19d9ecf

### メッセージ

```
feat: 壁キック処理を実装
- tryWallKick()メソッドを追加し、回転時の位置調整機能を実装
- 左右上下の4方向への壁キック処理を実装
- 壁キック失敗時は回転しない仕様を実装
- canRotateAt()ヘルパーメソッドで特定位置での回転判定を実装
- 83個のテストケースがすべて通過

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit 19d9ecfdc082b157a91569ee705b00d2598e2cbf
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 14:40:16 2025 +0900

    feat: 壁キック処理を実装
    
    - tryWallKick()メソッドを追加し、回転時の位置調整機能を実装
    - 左右上下の4方向への壁キック処理を実装
    - 壁キック失敗時は回転しない仕様を実装
    - canRotateAt()ヘルパーメソッドで特定位置での回転判定を実装
    - 83個のテストケースがすべて通過
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index 0a12b51..460fd8d 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -386,6 +386,9 @@ export class Game {
         // 回転可能かチェックしてから回転処理を実行
         if (this.canRotate()) {
           this.activePuyo.direction = (this.activePuyo.direction + 1) % 4
+        } else {
+          // 壁キック処理を試行
+          this.tryWallKick()
         }
       }
     } else {
@@ -547,6 +550,57 @@ export class Game {
     this.activePuyo = null
   }
 
+  // 壁キック処理を試行する
+  tryWallKick(): void {
+    if (!this.activePuyo) return
+
+    const nextDirection = (this.activePuyo.direction + 1) % 4
+    const kickOffsets = [
+      { x: -1, y: 0 }, // 左にキック
+      { x: 1, y: 0 }, // 右にキック
+      { x: 0, y: -1 }, // 上にキック
+      { x: 0, y: 1 }, // 下にキック
+    ]
+
+    // 各方向のキックを試行
+    for (const offset of kickOffsets) {
+      const testPuyo = {
+        x: this.activePuyo.x + offset.x,
+        y: this.activePuyo.y + offset.y,
+        direction: nextDirection,
+      }
+
+      // キック後の位置で回転可能かチェック
+      if (this.canRotateAt(testPuyo)) {
+        // 回転を実行
+        this.activePuyo.x = testPuyo.x
+        this.activePuyo.y = testPuyo.y
+        this.activePuyo.direction = nextDirection
+        return
+      }
+    }
+  }
+
+  // 指定した位置で回転可能かどうかをチェックする
+  private canRotateAt(testPuyo: { x: number; y: number; direction: number }): boolean {
+    const positions = this.getPuyoPositionsForTest(testPuyo)
+
+    // すべての位置が有効（空き）かどうかチェック
+    for (const pos of positions) {
+      // フィールドの境界チェック
+      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
+        return false
+      }
+
+      // フィールドの占有チェック（他のぷよと衝突しないか）
+      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
+        return false
+      }
+    }
+
+    return true
+  }
+
   processLanding(): void {
     if (!this.activePuyo) return
 
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index ede0331..902bf01 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1212,9 +1212,13 @@ describe('Game', () => {
       it('上キーが押されても回転できない場合は回転しない', () => {
         const activePuyo = game.getActivePuyo()
         if (activePuyo) {
-          // 回転を阻害する障害物を設置
+          // 全方向に障害物を設置して壁キックでも回転できない状況を作る
           const field = game.getField()
           field[2][3] = 1 // 回転先の位置に障害物
+          field[2][1] = 1 // 左側（キック先）にも障害物
+          field[2][3] = 1 // 右側にも障害物
+          field[1][2] = 1 // 上側にも障害物
+          field[3][2] = 1 // 下側にも障害物
 
           activePuyo.x = 2
           activePuyo.y = 2
@@ -1234,5 +1238,114 @@ describe('Game', () => {
         }
       })
     })
+
+    describe('壁キック処理', () => {
+      beforeEach(() => {
+        // 落下を無効にして純粋に回転のテストを行う
+        game.disableFalling()
+      })
+
+      it('右端で回転時に左にキックして回転できる', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 5 // 右端
+          activePuyo.y = 2
+          activePuyo.direction = 0 // 縦配置（下向き）
+
+          // 通常では回転できない位置
+          expect(game.canRotate()).toBe(false)
+
+          // 上キーを押して回転を試行（壁キックで成功するはず）
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          // 壁キックにより回転が成功し、左に移動している
+          expect(game.getActivePuyoDirection()).toBe(1) // 回転成功
+          expect(game.getActivePuyo()!.x).toBe(4) // 左にキックされている
+        }
+      })
+
+      it('左端で回転時に右にキックして回転できる', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 0 // 左端
+          activePuyo.y = 2
+          activePuyo.direction = 2 // 縦配置（上向き）から横配置（左向き）への回転
+
+          // 上キーを押して回転を試行（壁キックで成功するはず）
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          // 壁キックにより回転が成功し、右に移動している
+          expect(game.getActivePuyoDirection()).toBe(3) // 回転成功
+          expect(game.getActivePuyo()!.x).toBe(1) // 右にキックされている
+        }
+      })
+
+      it('上端で回転時に下にキックして回転できる', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 2
+          activePuyo.y = 0 // 上端
+          activePuyo.direction = 1 // 横配置（右向き）から縦配置（上向き）への回転
+
+          // 上キーを押して回転を試行（壁キックで成功するはず）
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          // 壁キックにより回転が成功し、下に移動している
+          expect(game.getActivePuyoDirection()).toBe(2) // 回転成功
+          expect(game.getActivePuyo()!.y).toBe(1) // 下にキックされている
+        }
+      })
+
+      it('壁キックでも回転できない場合は回転しない', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 5 // 右端
+          activePuyo.y = 2
+          activePuyo.direction = 0 // 縦配置（下向き）
+
+          // 壁キック先にも障害物を設置
+          const field = game.getField()
+          field[2][4] = 1 // 左側（キック先）にも障害物
+
+          const initialDirection = activePuyo.direction
+          const initialX = activePuyo.x
+
+          // 上キーを押して回転を試行
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          // 壁キックでも回転できないので変化なし
+          expect(game.getActivePuyoDirection()).toBe(initialDirection)
+          expect(game.getActivePuyo()!.x).toBe(initialX)
+        }
+      })
+
+      it('壁キック処理をチェックするメソッドが存在する', () => {
+        expect(typeof game.tryWallKick).toBe('function')
+      })
+    })
   })
 })

```

## コミット: 6556bf4

### メッセージ

```
feat: 回転可能性チェック機能を実装
- canRotate()メソッドを追加して回転前に衝突判定を実行
- フィールド境界チェックと他ぷよとの衝突チェックを実装
- updateRotation()に回転可能性チェックを統合
- 6つの新しいテストケースで機能を検証
- TDDサイクル（Red-Green-Refactor）に従って実装完了

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit 6556bf4e50a11cf6ca78de501cbb3036b2089afd
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 14:27:09 2025 +0900

    feat: 回転可能性チェック機能を実装
    
    - canRotate()メソッドを追加して回転前に衝突判定を実行
    - フィールド境界チェックと他ぷよとの衝突チェックを実装
    - updateRotation()に回転可能性チェックを統合
    - 6つの新しいテストケースで機能を検証
    - TDDサイクル（Red-Green-Refactor）に従って実装完了
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index ba6636a..0a12b51 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -23,15 +23,24 @@ export class Game {
   private gameState: 'ready' | 'playing' | 'gameover' = 'ready'
   private field: number[][]
   private nextPuyo: { color1: number; color2: number }
-  private activePuyo: { x: number; y: number; color1: number; color2: number } | null = null
+  private activePuyo: {
+    x: number
+    y: number
+    color1: number
+    color2: number
+    direction: number
+  } | null = null
   private fallSpeed = Game.FALL_SPEED
   private fallTimer = 0 // 落下タイマー
   private fallInterval = Game.FALL_INTERVAL
   // 入力状態の管理
   private leftKeyPressed = false
   private rightKeyPressed = false
+  private upKeyPressed = false
   private moveTimer = 0 // 移動タイマー
+  private rotationTimer = 0 // 回転タイマー
   private static readonly MOVE_INTERVAL = 8 // 移動間隔（フレーム数）
+  private static readonly ROTATION_INTERVAL = 15 // 回転間隔（フレーム数）
 
   constructor(canvas: HTMLCanvasElement, scoreDisplay: HTMLElement) {
     this.canvas = canvas
@@ -85,6 +94,7 @@ export class Game {
   private update(): void {
     this.updateFalling()
     this.updateMovement()
+    this.updateRotation()
   }
 
   // テスト用のpublicメソッド - 1フレーム分の更新と描画を実行
@@ -175,6 +185,7 @@ export class Game {
       y: 0, // 上端
       color1: this.nextPuyo.color1,
       color2: this.nextPuyo.color2,
+      direction: 0, // 初期状態は縦配置（下向き）
     }
 
     // 新しい次のぷよを生成
@@ -185,6 +196,24 @@ export class Game {
     return this.activePuyo
   }
 
+  // 回転機能関連のメソッド
+  getActivePuyoDirection(): number {
+    return this.activePuyo?.direction ?? 0
+  }
+
+  getActivePuyoPositions(): Array<{ x: number; y: number }> {
+    if (!this.activePuyo) return []
+    return this.getPuyoPositionsForTest({
+      x: this.activePuyo.x,
+      y: this.activePuyo.y,
+      direction: this.activePuyo.direction,
+    })
+  }
+
+  isUpKeyPressed(): boolean {
+    return this.upKeyPressed
+  }
+
   private getPuyoColor(colorNumber: number): string {
     return Game.PUYO_COLOR_MAP[colorNumber] || '#CCCCCC'
   }
@@ -210,16 +239,19 @@ export class Game {
   renderActivePuyo(): void {
     if (!this.activePuyo) return
 
-    const x1 = Game.FIELD_OFFSET_X + this.activePuyo.x * Game.CELL_SIZE
-    const y1 = Game.FIELD_OFFSET_Y + this.activePuyo.y * Game.CELL_SIZE
-    const x2 = Game.FIELD_OFFSET_X + this.activePuyo.x * Game.CELL_SIZE
-    const y2 = Game.FIELD_OFFSET_Y + (this.activePuyo.y + 1) * Game.CELL_SIZE
+    const positions = this.getActivePuyoPositions()
 
-    // 1つ目のぷよを楕円形で描画
+    // 1つ目のぷよ（中心ぷよ）を描画
+    const x1 = Game.FIELD_OFFSET_X + positions[0].x * Game.CELL_SIZE
+    const y1 = Game.FIELD_OFFSET_Y + positions[0].y * Game.CELL_SIZE
     this.drawPuyo(x1, y1, this.getPuyoColor(this.activePuyo.color1))
 
-    // 2つ目のぷよを楕円形で描画（下に配置）
-    this.drawPuyo(x2, y2, this.getPuyoColor(this.activePuyo.color2))
+    // 2つ目のぷよを描画
+    if (positions.length > 1) {
+      const x2 = Game.FIELD_OFFSET_X + positions[1].x * Game.CELL_SIZE
+      const y2 = Game.FIELD_OFFSET_Y + positions[1].y * Game.CELL_SIZE
+      this.drawPuyo(x2, y2, this.getPuyoColor(this.activePuyo.color2))
+    }
   }
 
   renderNextPuyo(): void {
@@ -275,6 +307,9 @@ export class Game {
       case 'ArrowRight':
         this.rightKeyPressed = true
         break
+      case 'ArrowUp':
+        this.upKeyPressed = true
+        break
     }
   }
 
@@ -286,6 +321,9 @@ export class Game {
       case 'ArrowRight':
         this.rightKeyPressed = false
         break
+      case 'ArrowUp':
+        this.upKeyPressed = false
+        break
     }
   }
 
@@ -305,6 +343,7 @@ export class Game {
   resetInputState(): void {
     this.leftKeyPressed = false
     this.rightKeyPressed = false
+    this.upKeyPressed = false
   }
 
   updateMovement(): void {
@@ -334,6 +373,70 @@ export class Game {
     }
   }
 
+  updateRotation(): void {
+    if (!this.activePuyo) return
+
+    // 上キーが押されている場合のみタイマーを進める
+    if (this.upKeyPressed) {
+      this.rotationTimer++
+
+      if (this.rotationTimer >= Game.ROTATION_INTERVAL) {
+        this.rotationTimer = 0
+
+        // 回転可能かチェックしてから回転処理を実行
+        if (this.canRotate()) {
+          this.activePuyo.direction = (this.activePuyo.direction + 1) % 4
+        }
+      }
+    } else {
+      // キーが押されていないときはタイマーをリセット
+      this.rotationTimer = 0
+    }
+  }
+
+  // テスト用のメソッド：即座に回転する
+  rotateActivePuyo(): void {
+    if (!this.activePuyo) return
+    this.activePuyo.direction = (this.activePuyo.direction + 1) % 4
+  }
+
+  // 回転可能かどうかをチェックする
+  canRotate(): boolean {
+    if (!this.activePuyo) return false
+
+    // 回転後の方向を計算（時計回りに90度回転）
+    const nextDirection = (this.activePuyo.direction + 1) % 4
+
+    // 回転後の位置を仮想的に計算
+    const testPuyo = {
+      x: this.activePuyo.x,
+      y: this.activePuyo.y,
+      direction: nextDirection,
+    }
+
+    const positions = this.getPuyoPositionsForTest(testPuyo)
+
+    // すべての位置が有効（空き）かどうかチェック
+    for (const pos of positions) {
+      // フィールドの境界チェック
+      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
+        return false
+      }
+
+      // フィールドの占有チェック（他のぷよと衝突しないか）
+      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
+        return false
+      }
+    }
+
+    return true
+  }
+
+  // テスト用のメソッド：落下を無効にする
+  disableFalling(): void {
+    this.fallInterval = 99999 // 非常に大きな値にして実質的に無効化
+  }
+
   clearActivePuyo(): void {
     this.activePuyo = null
   }
@@ -377,25 +480,68 @@ export class Game {
   }
 
   private isPuyoPositionEmpty(x: number, y: number): boolean {
-    // 操作ぷよの1つ目との衝突チェック
-    if (this.field[y] && this.field[y][x] !== 0) {
-      return false
-    }
+    if (!this.activePuyo) return false
 
-    // 操作ぷよの2つ目との衝突チェック
-    if (this.field[y + 1] && this.field[y + 1][x] !== 0) {
-      return false
+    // 現在の操作ぷよの位置情報を取得
+    const testPuyo = { x, y, direction: this.activePuyo.direction }
+    const positions = this.getPuyoPositionsForTest(testPuyo)
+
+    // すべての位置が空かどうかチェック
+    for (const pos of positions) {
+      // フィールドの境界チェック
+      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
+        return false
+      }
+
+      // フィールドの占有チェック
+      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
+        return false
+      }
     }
 
     return true
   }
 
+  private getPuyoPositionsForTest(testPuyo: {
+    x: number
+    y: number
+    direction: number
+  }): Array<{ x: number; y: number }> {
+    const centerX = testPuyo.x
+    const centerY = testPuyo.y
+    const direction = testPuyo.direction
+
+    const positions = [{ x: centerX, y: centerY }] // 中心ぷよの位置
+
+    // 方向に基づいて2つ目のぷよの位置を決定
+    switch (direction) {
+      case 0: // 縦配置、下向き
+        positions.push({ x: centerX, y: centerY + 1 })
+        break
+      case 1: // 横配置、右向き
+        positions.push({ x: centerX + 1, y: centerY })
+        break
+      case 2: // 縦配置、上向き
+        positions.push({ x: centerX, y: centerY - 1 })
+        break
+      case 3: // 横配置、左向き
+        positions.push({ x: centerX - 1, y: centerY })
+        break
+    }
+
+    return positions
+  }
+
   landActivePuyo(): void {
     if (!this.activePuyo) return
 
+    const positions = this.getActivePuyoPositions()
+
     // 操作ぷよをフィールドに固定
-    this.field[this.activePuyo.y][this.activePuyo.x] = this.activePuyo.color1
-    this.field[this.activePuyo.y + 1][this.activePuyo.x] = this.activePuyo.color2
+    if (positions.length >= 2) {
+      this.field[positions[0].y][positions[0].x] = this.activePuyo.color1
+      this.field[positions[1].y][positions[1].x] = this.activePuyo.color2
+    }
 
     // 操作ぷよをクリア
     this.activePuyo = null
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index c7f9a82..ede0331 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -954,4 +954,285 @@ describe('Game', () => {
       expect(fillRectCalls.length).toBe(1)
     })
   })
+
+  describe('ぷよの回転機能', () => {
+    beforeEach(() => {
+      // requestAnimationFrame をモック
+      vi.stubGlobal('requestAnimationFrame', vi.fn())
+
+      const mockContext = {
+        fillStyle: '',
+        strokeStyle: '',
+        lineWidth: 1,
+        fillRect: vi.fn(),
+        strokeRect: vi.fn(),
+        clearRect: vi.fn(),
+        drawImage: vi.fn(),
+        beginPath: vi.fn(),
+        ellipse: vi.fn(),
+        fill: vi.fn(),
+        stroke: vi.fn(),
+      } as unknown as CanvasRenderingContext2D
+
+      const mockCanvas = {
+        getContext: vi.fn().mockReturnValue(mockContext),
+        width: 320,
+        height: 480,
+      } as unknown as HTMLCanvasElement
+
+      const mockScoreDisplay = {
+        textContent: '',
+      } as unknown as HTMLElement
+
+      vi.clearAllMocks()
+      game = new Game(mockCanvas, mockScoreDisplay)
+      game.spawnActivePuyo()
+    })
+
+    describe('回転方向の管理', () => {
+      it('アクティブぷよの回転方向を取得できる', () => {
+        const direction = game.getActivePuyoDirection()
+        expect(direction).toBe(0) // 初期状態は0（縦配置）
+      })
+
+      it('上キーで時計回りに回転する', () => {
+        const initialDirection = game.getActivePuyoDirection()
+
+        // 上キーを押してupKeyPressedをtrueにする
+        const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+        game.handleKeyDown(upKeyEvent)
+
+        // 回転間隔分だけアップデートを実行して回転処理を行う
+        for (let i = 0; i < 15; i++) {
+          game.updateAndRender()
+        }
+
+        const newDirection = game.getActivePuyoDirection()
+        expect(newDirection).toBe((initialDirection + 1) % 4)
+      })
+
+      it('回転方向の値は0-3の範囲で循環する', () => {
+        // 4回回転させると元の方向に戻る
+        for (let i = 0; i < 4; i++) {
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let j = 0; j < 15; j++) {
+            game.updateAndRender()
+          }
+
+          // キーアップイベントも送信してキー状態をリセット
+          const upKeyUpEvent = new KeyboardEvent('keyup', { key: 'ArrowUp' })
+          game.handleKeyUp(upKeyUpEvent)
+        }
+
+        expect(game.getActivePuyoDirection()).toBe(0)
+      })
+    })
+
+    describe('回転後のぷよの位置', () => {
+      it('縦配置（方向0）から横配置（方向1）に回転する', () => {
+        const activePuyo = game.getActivePuyo()
+        expect(activePuyo).not.toBeNull()
+
+        if (activePuyo) {
+          const initialX = activePuyo.x
+          const initialY = activePuyo.y
+
+          // 上キーで回転
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          const rotatedPositions = game.getActivePuyoPositions()
+          expect(rotatedPositions).toEqual([
+            { x: initialX, y: initialY }, // 中心ぷよの位置（変わらず）
+            { x: initialX + 1, y: initialY }, // 2つ目のぷよが右に移動
+          ])
+        }
+      })
+
+      it('各回転方向でのぷよの位置が正しい', () => {
+        // 回転をテストするため、適切な位置に移動（中央、フィールドの少し下）
+        const activePuyo = game.getActivePuyo()
+        expect(activePuyo).not.toBeNull()
+
+        // 落下を無効にして純粋に回転のテストを行う
+        game.disableFalling()
+
+        if (activePuyo) {
+          // より安全な位置(2, 2)に移動してからテスト
+          activePuyo.x = 2
+          activePuyo.y = 2
+
+          const centerX = activePuyo.x
+          const centerY = activePuyo.y
+
+          // 方向0（縦配置、下向き）: 初期状態
+          expect(game.getActivePuyoPositions()).toEqual([
+            { x: centerX, y: centerY },
+            { x: centerX, y: centerY + 1 },
+          ])
+
+          // 方向1（横配置、右向き）
+          const upKeyEvent1 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent1)
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+          game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
+
+          expect(game.getActivePuyoPositions()).toEqual([
+            { x: centerX, y: centerY },
+            { x: centerX + 1, y: centerY },
+          ])
+
+          // 方向2（縦配置、上向き）
+          const upKeyEvent2 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent2)
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+          game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
+
+          expect(game.getActivePuyoPositions()).toEqual([
+            { x: centerX, y: centerY },
+            { x: centerX, y: centerY - 1 },
+          ])
+
+          // 方向3（横配置、左向き）
+          const upKeyEvent3 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent3)
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+          game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
+
+          expect(game.getActivePuyoPositions()).toEqual([
+            { x: centerX, y: centerY },
+            { x: centerX - 1, y: centerY },
+          ])
+        }
+      })
+    })
+
+    describe('上キー入力の処理', () => {
+      it('上キーが押されたことを検出できる', () => {
+        expect(game.isUpKeyPressed()).toBe(false)
+
+        const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+        game.handleKeyDown(upKeyEvent)
+
+        expect(game.isUpKeyPressed()).toBe(true)
+      })
+
+      it('上キーが離されたことを検出できる', () => {
+        // まず上キーを押す
+        const upKeyDownEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+        game.handleKeyDown(upKeyDownEvent)
+        expect(game.isUpKeyPressed()).toBe(true)
+
+        // 上キーを離す
+        const upKeyUpEvent = new KeyboardEvent('keyup', { key: 'ArrowUp' })
+        game.handleKeyUp(upKeyUpEvent)
+
+        expect(game.isUpKeyPressed()).toBe(false)
+      })
+    })
+
+    describe('回転可能性チェック', () => {
+      beforeEach(() => {
+        // 落下を無効にして純粋に回転のテストを行う
+        game.disableFalling()
+        // 安全な位置に操作ぷよを配置
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 2
+          activePuyo.y = 2
+        }
+      })
+
+      it('回転可能性をチェックするメソッドが存在する', () => {
+        expect(typeof game.canRotate).toBe('function')
+      })
+
+      it('フィールド内の空きスペースでは回転可能', () => {
+        expect(game.canRotate()).toBe(true)
+      })
+
+      it('右端では方向によって回転制限がある', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 5 // 右端
+          activePuyo.y = 2
+          activePuyo.direction = 0 // 縦配置（下向き）から横配置（右向き）への回転は不可
+          expect(game.canRotate()).toBe(false) // 2つ目のぷよがx=6になりフィールド外
+        }
+      })
+
+      it('左端でも通常は回転可能', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          activePuyo.x = 0 // 左端
+          activePuyo.y = 2
+          expect(game.canRotate()).toBe(true)
+        }
+      })
+
+      it('他のぷよがある位置には回転できない', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 現在方向0（縦配置、下向き）から方向1（横配置、右向き）への回転を想定
+          // 方向1では2つ目のぷよが(x+1, y)の位置に来るので、そこに障害物を置く
+          const field = game.getField()
+          field[2][3] = 1 // (3, 2)の位置にぷよを配置
+
+          activePuyo.x = 2
+          activePuyo.y = 2
+          expect(game.canRotate()).toBe(false)
+        }
+      })
+
+      it('回転後の位置がフィールド外になる場合は回転できない', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 方向1（横配置、右向き）から方向2（縦配置、上向き）への回転で、2つ目のぷよがy-1になる場合
+          activePuyo.direction = 1 // 横配置（右向き）
+          activePuyo.x = 2
+          activePuyo.y = 0 // y=0で方向2に回転すると2つ目のぷよがy=-1になる
+          expect(game.canRotate()).toBe(false)
+        }
+      })
+
+      it('上キーが押されても回転できない場合は回転しない', () => {
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // 回転を阻害する障害物を設置
+          const field = game.getField()
+          field[2][3] = 1 // 回転先の位置に障害物
+
+          activePuyo.x = 2
+          activePuyo.y = 2
+          const initialDirection = activePuyo.direction
+
+          // 上キーを押して回転を試行
+          const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
+          game.handleKeyDown(upKeyEvent)
+
+          // 回転間隔分だけアップデートを実行
+          for (let i = 0; i < 15; i++) {
+            game.updateAndRender()
+          }
+
+          // 回転していないことを確認
+          expect(game.getActivePuyoDirection()).toBe(initialDirection)
+        }
+      })
+    })
+  })
 })

```

## コミット: fc7f952

### メッセージ

```
docs: イテレーション2のふりかえりと要件書の更新
- 全7つのTODOが完了したことを記録
- WebUI確認項目を全て完了マーク
- 実装結果（64テスト全通過、楕円描画等）を追加
- Keep/Problem/Tryのふりかえりを記録

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts
- M	app/src/tests/setup.ts
- M	docs/requirement.md

### 変更内容

```diff
commit fc7f952661fa5a4702e343ccbd5edd75e2b04ee1
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 09:44:01 2025 +0900

    docs: イテレーション2のふりかえりと要件書の更新
    
    - 全7つのTODOが完了したことを記録
    - WebUI確認項目を全て完了マーク
    - 実装結果（64テスト全通過、楕円描画等）を追加
    - Keep/Problem/Tryのふりかえりを記録
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index ffbbf27..ba6636a 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -143,16 +143,15 @@ export class Game {
     this.context.strokeStyle = '#000000'
     this.context.strokeRect(Game.FIELD_OFFSET_X, Game.FIELD_OFFSET_Y, fieldWidth, fieldHeight)
 
-    // フィールドに固定されたぷよを描画
+    // フィールドに固定されたぷよを楕円形で描画
     for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
       for (let x = 0; x < Game.FIELD_WIDTH; x++) {
         const puyoColor = this.field[y][x]
         if (puyoColor !== 0) {
-          // ぷよが存在する場合は描画
-          this.context.fillStyle = this.getPuyoColor(puyoColor)
+          // ぷよが存在する場合は楕円形で描画
           const drawX = Game.FIELD_OFFSET_X + x * Game.CELL_SIZE
           const drawY = Game.FIELD_OFFSET_Y + y * Game.CELL_SIZE
-          this.context.fillRect(drawX, drawY, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+          this.drawPuyo(drawX, drawY, this.getPuyoColor(puyoColor))
         }
       }
     }
@@ -190,6 +189,24 @@ export class Game {
     return Game.PUYO_COLOR_MAP[colorNumber] || '#CCCCCC'
   }
 
+  private drawPuyo(x: number, y: number, color: string): void {
+    // ぷよを楕円形で描画
+    const centerX = x + Game.CELL_SIZE / 2
+    const centerY = y + Game.CELL_SIZE / 2
+    const radiusX = (Game.CELL_SIZE - 4) / 2 // 若干小さくして見やすく
+    const radiusY = (Game.CELL_SIZE - 4) / 2
+
+    this.context.fillStyle = color
+    this.context.beginPath()
+    this.context.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI)
+    this.context.fill()
+
+    // 輪郭線を追加
+    this.context.strokeStyle = '#333333'
+    this.context.lineWidth = 1
+    this.context.stroke()
+  }
+
   renderActivePuyo(): void {
     if (!this.activePuyo) return
 
@@ -198,26 +215,22 @@ export class Game {
     const x2 = Game.FIELD_OFFSET_X + this.activePuyo.x * Game.CELL_SIZE
     const y2 = Game.FIELD_OFFSET_Y + (this.activePuyo.y + 1) * Game.CELL_SIZE
 
-    // 1つ目のぷよを描画
-    this.context.fillStyle = this.getPuyoColor(this.activePuyo.color1)
-    this.context.fillRect(x1, y1, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+    // 1つ目のぷよを楕円形で描画
+    this.drawPuyo(x1, y1, this.getPuyoColor(this.activePuyo.color1))
 
-    // 2つ目のぷよを描画（下に配置）
-    this.context.fillStyle = this.getPuyoColor(this.activePuyo.color2)
-    this.context.fillRect(x2, y2, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+    // 2つ目のぷよを楕円形で描画（下に配置）
+    this.drawPuyo(x2, y2, this.getPuyoColor(this.activePuyo.color2))
   }
 
   renderNextPuyo(): void {
     const nextX = Game.FIELD_OFFSET_X + (Game.FIELD_WIDTH + 1) * Game.CELL_SIZE
     const nextY = Game.FIELD_OFFSET_Y + Game.CELL_SIZE
 
-    // 次のぷよ1を描画
-    this.context.fillStyle = this.getPuyoColor(this.nextPuyo.color1)
-    this.context.fillRect(nextX, nextY, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+    // 次のぷよ1を楕円形で描画
+    this.drawPuyo(nextX, nextY, this.getPuyoColor(this.nextPuyo.color1))
 
-    // 次のぷよ2を描画（下に配置）
-    this.context.fillStyle = this.getPuyoColor(this.nextPuyo.color2)
-    this.context.fillRect(nextX, nextY + Game.CELL_SIZE, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+    // 次のぷよ2を楕円形で描画（下に配置）
+    this.drawPuyo(nextX, nextY + Game.CELL_SIZE, this.getPuyoColor(this.nextPuyo.color2))
   }
 
   updateFalling(): void {
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index 1dcc740..c7f9a82 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -12,10 +12,15 @@ describe('Game', () => {
     mockContext = {
       fillStyle: '',
       strokeStyle: '',
+      lineWidth: 1,
       fillRect: vi.fn(),
       strokeRect: vi.fn(),
       clearRect: vi.fn(),
       drawImage: vi.fn(),
+      beginPath: vi.fn(),
+      ellipse: vi.fn(),
+      fill: vi.fn(),
+      stroke: vi.fn(),
     } as unknown as CanvasRenderingContext2D
 
     // Canvas要素をモック
@@ -163,15 +168,17 @@ describe('Game', () => {
       game.spawnActivePuyo()
       game.renderActivePuyo()
 
-      // 2つのぷよが描画される（fillRectが2回呼ばれる）
-      expect(mockContext.fillRect).toHaveBeenCalledTimes(2)
+      // 2つのぷよが楕円形で描画される（ellipseが2回呼ばれる）
+      expect(mockContext.ellipse).toHaveBeenCalledTimes(2)
+      expect(mockContext.fill).toHaveBeenCalledTimes(2)
     })
 
     it('次のぷよが画面に描画される', () => {
       game.renderNextPuyo()
 
-      // 次のぷよエリアが描画される
-      expect(mockContext.fillRect).toHaveBeenCalled()
+      // 次のぷよエリアが楕円形で描画される
+      expect(mockContext.ellipse).toHaveBeenCalled()
+      expect(mockContext.fill).toHaveBeenCalled()
     })
 
     it('ぷよの色が正しく設定される', () => {
@@ -883,10 +890,15 @@ describe('Game', () => {
       // Canvas とコンテキストのモックを作成
       mockContext = {
         fillStyle: '',
-        fillRect: vi.fn(),
         strokeStyle: '',
+        lineWidth: 1,
+        fillRect: vi.fn(),
         strokeRect: vi.fn(),
         clearRect: vi.fn(),
+        beginPath: vi.fn(),
+        ellipse: vi.fn(),
+        fill: vi.fn(),
+        stroke: vi.fn(),
       } as unknown as CanvasRenderingContext2D
 
       mockCanvas = {
@@ -914,11 +926,15 @@ describe('Game', () => {
       // フィールドを描画
       game.renderField()
 
-      // fillRectが呼ばれている回数を確認
-      const fillRectCalls = (mockContext.fillRect as any).mock.calls
+      // ellipseが呼ばれている回数を確認（楕円描画）
+      const ellipseCalls = (mockContext.ellipse as any).mock.calls
+
+      // 固定ぷよが楕円形で描画される（3回のellipse呼び出しがあるはず）
+      expect(ellipseCalls.length).toBe(3)
 
-      // 背景(1回) + 固定ぷよ(3回) = 4回のfillRect呼び出しがあるはず
-      expect(fillRectCalls.length).toBeGreaterThanOrEqual(4)
+      // fillが呼ばれている回数を確認（楕円の塗りつぶし）
+      const fillCalls = (mockContext.fill as any).mock.calls
+      expect(fillCalls.length).toBe(3)
 
       // ぷよの色が正しく設定されているかチェック
       const fillStyleCalls = mockContext.fillStyle as any
diff --git a/app/src/tests/setup.ts b/app/src/tests/setup.ts
index 4f4467b..915ebdc 100644
--- a/app/src/tests/setup.ts
+++ b/app/src/tests/setup.ts
@@ -1,4 +1,4 @@
-import { vi } from 'vitest'
+import { vi, beforeEach } from 'vitest'
 
 // requestAnimationFrame のモック
 ;(globalThis as any).requestAnimationFrame = vi.fn((callback) => {
@@ -9,3 +9,23 @@ import { vi } from 'vitest'
 ;(globalThis as any).cancelAnimationFrame = vi.fn((id) => {
   clearTimeout(id)
 })
+
+// HTMLCanvasElement のモック
+beforeEach(() => {
+  Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {
+    value: vi.fn(() => ({
+      clearRect: vi.fn(),
+      fillRect: vi.fn(),
+      strokeRect: vi.fn(),
+      beginPath: vi.fn(),
+      ellipse: vi.fn(),
+      fill: vi.fn(),
+      stroke: vi.fn(),
+      fillStyle: '',
+      strokeStyle: '',
+      lineWidth: 1,
+    })),
+    writable: true,
+    configurable: true,
+  })
+})
diff --git a/docs/requirement.md b/docs/requirement.md
index 4446b7f..c312e44 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -206,19 +206,47 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 - [x] ぷよを左右に移動する処理を実装する（実際にぷよの位置を変更する）
 - [x] 移動可能かどうかのチェックを実装する（画面の端や他のぷよにぶつかる場合は移動できないようにする）
 - [x] 移動後の表示を更新する（画面上でぷよの位置が変わったことを表示する）
-- [ ] ぷよの着地を検出する（ぷよが下に落ちて他のぷよや床にぶつかったことを検知する）
-- [ ] ぷよが着地したら次のぷよを生成する（新しいぷよを画面に表示する）
+- [x] ぷよの着地を検出する（ぷよが下に落ちて他のぷよや床にぶつかったことを検知する）
+- [x] ぷよが着地したら次のぷよを生成する（新しいぷよを画面に表示する）
 
 ### WebUI確認項目
-- ぷよが自動的に落下する
-- 左右キーでぷよが移動する
-- 壁際での移動制限が働く
+- ✅ ぷよが自動的に落下する
+- ✅ 左右キーでぷよが移動する
+- ✅ 壁際での移動制限が働く
+- ✅ ぷよが着地して次のぷよが生成される
+- ✅ ぷよが楕円形で描画される
+
+### 実装結果
+- 64個のテストケースが全て通過
+- TDDサイクル（Red-Green-Refactor）を継続実践
+- 着地検出・次ぷよ生成システムの完成
+- キーボード入力システムの完成
+- ぷよの楕円描画システムの完成
+- Canvas API モックの充実化
 
 ### ふりかえり
 
 *   **Keep**:
+    - TDDサイクル（Red-Green-Refactor）の継続により、品質の高い実装を維持できた
+    - Canvas APIのモック設計を段階的に拡張し、テスト環境の安定性を向上させた
+    - 型安全性（TypeScript）によりコンパイル時にエラーを早期発見できた
+    - 小さなコミット単位での実装により、変更点が明確で安全なバージョン管理ができた
+    - テストファーストアプローチにより、インターフェース設計が自然に改善された
+    - ぷよの楕円描画により、よりゲームらしい視覚表現を実現できた
+
 *   **Problem**:
+    - Canvas 2D context のモック設定で、ellipse描画メソッドの追加が必要だった
+    - 着地後の左右移動バグの修正に時間を要した（タイマーリセットの問題）
+    - 前のぷよが非表示になる問題で、フィールド描画ロジックの修正が必要だった
+    - テストケースが64個と多くなり、実行時間が少し長くなった
+    - WebUI での動作確認手順が定型化されていない
+
 *   **Try**:
+    - 次イテレーションではぷよの回転処理を実装する（より複雑な幾何学的計算）
+    - Canvas モックをより汎用的に設計して、今後の描画機能追加に対応する
+    - 物理演算（回転、壁キック）のテスト戦略を事前に検討する
+    - パフォーマンステスト（フレームレート）の導入を検討する
+    - WebUI 確認項目のチェックリスト化と自動化を検討する
 
 ## イテレーション3: ぷよの回転の実装
 

```

## コミット: 48d47fd

### メッセージ

```
feat: フィールドに固定されたぷよの描画機能を実装
- renderField()メソッドにフィールド上の固定ぷよ描画ロジックを追加
- 各セルをチェックしてぷよが存在する場合に適切な色で描画
- フィールドぷよ描画のテストケースを追加
- 着地したぷよが画面上で見えるようになる

これでぷよが着地後に非表示になる問題が解決されました。

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit 48d47fd73641f5bfbe518fe4dba600bf4a6ff94f
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 09:30:21 2025 +0900

    feat: フィールドに固定されたぷよの描画機能を実装
    
    - renderField()メソッドにフィールド上の固定ぷよ描画ロジックを追加
    - 各セルをチェックしてぷよが存在する場合に適切な色で描画
    - フィールドぷよ描画のテストケースを追加
    - 着地したぷよが画面上で見えるようになる
    
    これでぷよが着地後に非表示になる問題が解決されました。
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index 731254e..ffbbf27 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -142,6 +142,20 @@ export class Game {
     // フィールドの枠線を描画
     this.context.strokeStyle = '#000000'
     this.context.strokeRect(Game.FIELD_OFFSET_X, Game.FIELD_OFFSET_Y, fieldWidth, fieldHeight)
+
+    // フィールドに固定されたぷよを描画
+    for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
+      for (let x = 0; x < Game.FIELD_WIDTH; x++) {
+        const puyoColor = this.field[y][x]
+        if (puyoColor !== 0) {
+          // ぷよが存在する場合は描画
+          this.context.fillStyle = this.getPuyoColor(puyoColor)
+          const drawX = Game.FIELD_OFFSET_X + x * Game.CELL_SIZE
+          const drawY = Game.FIELD_OFFSET_Y + y * Game.CELL_SIZE
+          this.context.fillRect(drawX, drawY, Game.CELL_SIZE - 2, Game.CELL_SIZE - 2)
+        }
+      }
+    }
   }
 
   clearScreen(): void {
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index b039ea7..1dcc740 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -872,4 +872,70 @@ describe('Game', () => {
       expect(field[12][2]).toBe(originalColor2)
     })
   })
+
+  describe('フィールド上のぷよ描画', () => {
+    let game: Game
+    let mockCanvas: HTMLCanvasElement
+    let mockContext: CanvasRenderingContext2D
+    let mockScoreDisplay: HTMLElement
+
+    beforeEach(() => {
+      // Canvas とコンテキストのモックを作成
+      mockContext = {
+        fillStyle: '',
+        fillRect: vi.fn(),
+        strokeStyle: '',
+        strokeRect: vi.fn(),
+        clearRect: vi.fn(),
+      } as unknown as CanvasRenderingContext2D
+
+      mockCanvas = {
+        getContext: vi.fn().mockReturnValue(mockContext),
+        width: 320,
+        height: 480,
+      } as unknown as HTMLCanvasElement
+
+      mockScoreDisplay = {
+        textContent: '',
+      } as unknown as HTMLElement
+
+      vi.clearAllMocks()
+      game = new Game(mockCanvas, mockScoreDisplay)
+      game.spawnActivePuyo()
+    })
+
+    it('フィールドに固定されたぷよが描画される', () => {
+      // フィールドにぷよを配置
+      const field = game.getField()
+      field[10][2] = 1 // 赤いぷよ
+      field[11][2] = 2 // 緑のぷよ
+      field[12][3] = 3 // 青いぷよ
+
+      // フィールドを描画
+      game.renderField()
+
+      // fillRectが呼ばれている回数を確認
+      const fillRectCalls = (mockContext.fillRect as any).mock.calls
+
+      // 背景(1回) + 固定ぷよ(3回) = 4回のfillRect呼び出しがあるはず
+      expect(fillRectCalls.length).toBeGreaterThanOrEqual(4)
+
+      // ぷよの色が正しく設定されているかチェック
+      const fillStyleCalls = mockContext.fillStyle as any
+
+      // 固定されたぷよの色が描画されているかをテスト
+      game.render()
+      expect(mockContext.fillRect).toHaveBeenCalled()
+    })
+
+    it('空のフィールドセルは描画されない', () => {
+      // 空のフィールドで描画
+      game.renderField()
+
+      const fillRectCalls = (mockContext.fillRect as any).mock.calls
+
+      // 背景のみの描画（固定ぷよがないので背景の1回のみ）
+      expect(fillRectCalls.length).toBe(1)
+    })
+  })
 })

```

## コミット: e8281cb

### メッセージ

```
fix: ぷよの着地処理を修正して自動固定を実装
- updateFalling()で着地時に自動的にprocessLanding()を呼び出すように修正
- canFall()の底面判定を修正（y + 2 >= FIELD_HEIGHTに変更）
- canFall()でcanMoveDown()と同じ衝突判定を使用するように統合
- 着地後のぷよ固定処理のテストケースを追加

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts
- M	docs/requirement.md

### 変更内容

```diff
commit e8281cbe2a6a6860f0da6c52dc8a0923d24ab58d
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 09:21:45 2025 +0900

    fix: ぷよの着地処理を修正して自動固定を実装
    
    - updateFalling()で着地時に自動的にprocessLanding()を呼び出すように修正
    - canFall()の底面判定を修正（y + 2 >= FIELD_HEIGHTに変更）
    - canFall()でcanMoveDown()と同じ衝突判定を使用するように統合
    - 着地後のぷよ固定処理のテストケースを追加
    
    🤖 Generated with [Claude Code](https://claude.ai/code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/app/src/game.ts b/app/src/game.ts
index bacd39c..731254e 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -216,6 +216,9 @@ export class Game {
       // 落下可能かチェック
       if (this.canFall()) {
         this.activePuyo.y += this.fallSpeed
+      } else {
+        // 着地処理を実行
+        this.processLanding()
       }
     }
   }
@@ -223,13 +226,13 @@ export class Game {
   private canFall(): boolean {
     if (!this.activePuyo) return false
 
-    // フィールドの底部に到達した場合
-    if (this.activePuyo.y + 1 >= Game.FIELD_HEIGHT - 1) {
+    // フィールドの底部に到達した場合（ぷよは2つ分の高さなので、+2で判定）
+    if (this.activePuyo.y + 2 >= Game.FIELD_HEIGHT) {
       return false
     }
 
-    // 他のぷよとの衝突判定（後で実装）
-    return true
+    // canMoveDown()と同じ衝突判定を使用
+    return this.canMoveDown()
   }
 
   getFallSpeed(): number {
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index 7378473..b039ea7 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -791,4 +791,85 @@ describe('Game', () => {
       expect(newActivePuyo!.y).toBe(0) // 初期位置
     })
   })
+
+  describe('着地後の固定処理', () => {
+    let game: Game
+    let mockCanvas: HTMLCanvasElement
+    let mockContext: CanvasRenderingContext2D
+    let mockScoreDisplay: HTMLElement
+
+    beforeEach(() => {
+      // Canvas とコンテキストのモックを作成
+      mockContext = {
+        fillStyle: '',
+        fillRect: vi.fn(),
+        strokeStyle: '',
+        strokeRect: vi.fn(),
+        clearRect: vi.fn(),
+      } as unknown as CanvasRenderingContext2D
+
+      mockCanvas = {
+        getContext: vi.fn().mockReturnValue(mockContext),
+        width: 320,
+        height: 480,
+      } as unknown as HTMLCanvasElement
+
+      mockScoreDisplay = {
+        textContent: '',
+      } as unknown as HTMLElement
+
+      vi.clearAllMocks()
+      game = new Game(mockCanvas, mockScoreDisplay)
+      game.spawnActivePuyo()
+    })
+
+    it('着地したぷよは左右に移動できない', () => {
+      // 操作ぷよを底部近くに配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 11 // フィールド底部 - 1
+
+      // 落下タイマーが満たされるまで処理を実行（着地するはず）
+      for (let i = 0; i < 30; i++) {
+        game.updateFalling()
+      }
+
+      // 着地後は操作ぷよが新しく生成されている
+      expect(game.getActivePuyo()).not.toBeNull()
+      expect(game.getActivePuyo()!.x).toBe(2) // 初期位置
+      expect(game.getActivePuyo()!.y).toBe(0) // 初期位置
+
+      // フィールドに前のぷよが固定されている
+      const field = game.getField()
+      expect(field[11][2]).not.toBe(0) // 着地したぷよが固定されている
+      expect(field[12][2]).not.toBe(0) // 着地したぷよが固定されている
+    })
+
+    it('底部に着地したときに自動的に着地処理が実行される', () => {
+      // 操作ぷよを底部の一つ上に配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 11 // フィールド底部 - 1（y=11, 二つ目のぷよがy=12）
+      const originalColor1 = activePuyo!.color1
+      const originalColor2 = activePuyo!.color2
+
+      // 最初にcanFall()をチェック
+      expect(game['canFall']()).toBe(false)
+
+      // 落下処理を実行（fallTimerが満たされるまで繰り返す）
+      for (let i = 0; i < 30; i++) {
+        game.updateFalling()
+      }
+
+      // 操作ぷよが新しく生成されている（着地処理が実行された）
+      expect(game.getActivePuyo()).not.toBeNull()
+      expect(game.getActivePuyo()!.x).toBe(2) // 初期位置
+      expect(game.getActivePuyo()!.y).toBe(0) // 初期位置
+
+      // フィールドにぷよが配置されている
+      const field = game.getField()
+      expect(field[11][2]).toBe(originalColor1)
+      expect(field[12][2]).toBe(originalColor2)
+    })
+  })
 })
diff --git a/docs/requirement.md b/docs/requirement.md
index 82bb31e..4446b7f 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -201,11 +201,13 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] ぷよを自由落下させる（ぷよが自動的に下に落ちるようにする）
-- [ ] プレイヤーの入力を検出する（キーボードの左右キーが押されたことを検知する）
-- [ ] ぷよを左右に移動する処理を実装する（実際にぷよの位置を変更する）
-- [ ] 移動可能かどうかのチェックを実装する（画面の端や他のぷよにぶつかる場合は移動できないようにする）
-- [ ] 移動後の表示を更新する（画面上でぷよの位置が変わったことを表示する）
+- [x] ぷよを自由落下させる（ぷよが自動的に下に落ちるようにする）
+- [x] プレイヤーの入力を検出する（キーボードの左右キーが押されたことを検知する）
+- [x] ぷよを左右に移動する処理を実装する（実際にぷよの位置を変更する）
+- [x] 移動可能かどうかのチェックを実装する（画面の端や他のぷよにぶつかる場合は移動できないようにする）
+- [x] 移動後の表示を更新する（画面上でぷよの位置が変わったことを表示する）
+- [ ] ぷよの着地を検出する（ぷよが下に落ちて他のぷよや床にぶつかったことを検知する）
+- [ ] ぷよが着地したら次のぷよを生成する（新しいぷよを画面に表示する）
 
 ### WebUI確認項目
 - ぷよが自動的に落下する

```

## コミット: d83349d

### メッセージ

```
feat: 着地後の次ぷよ生成機能を実装
- landActivePuyo()メソッドで操作ぷよをフィールドに固定
- processLanding()メソッドで着地処理と次ぷよ生成を統合
- 着地処理の包括的なテストを追加
- 6つのテストケースでRed-Green-Refactorサイクル完了
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit d83349d9df9377654ca80e590a2a04598c57dbce
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 09:05:36 2025 +0900

    feat: 着地後の次ぷよ生成機能を実装
    
    - landActivePuyo()メソッドで操作ぷよをフィールドに固定
    - processLanding()メソッドで着地処理と次ぷよ生成を統合
    - 着地処理の包括的なテストを追加
    - 6つのテストケースでRed-Green-Refactorサイクル完了

diff --git a/app/src/game.ts b/app/src/game.ts
index ed6e45f..bacd39c 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -359,4 +359,25 @@ export class Game {
 
     return true
   }
+
+  landActivePuyo(): void {
+    if (!this.activePuyo) return
+
+    // 操作ぷよをフィールドに固定
+    this.field[this.activePuyo.y][this.activePuyo.x] = this.activePuyo.color1
+    this.field[this.activePuyo.y + 1][this.activePuyo.x] = this.activePuyo.color2
+
+    // 操作ぷよをクリア
+    this.activePuyo = null
+  }
+
+  processLanding(): void {
+    if (!this.activePuyo) return
+
+    // 着地処理
+    this.landActivePuyo()
+
+    // 新しい操作ぷよを生成
+    this.spawnActivePuyo()
+  }
 }
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index 2ddcfef..7378473 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -697,4 +697,98 @@ describe('Game', () => {
       expect(typeof game.canMoveDown).toBe('function')
     })
   })
+
+  describe('着地後の次ぷよ生成', () => {
+    beforeEach(() => {
+      vi.clearAllMocks()
+      game.start()
+    })
+
+    it('ぷよが着地したら操作ぷよをフィールドに固定する', () => {
+      // 操作ぷよを底面近くに配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 11 // 2つ目のぷよが底面(y=12)に接触
+
+      // 操作ぷよをフィールドに固定する処理
+      game.landActivePuyo()
+
+      // フィールドに操作ぷよが固定されている
+      const field = game.getField()
+      expect(field[11][2]).toBe(activePuyo!.color1) // 1つ目のぷよ
+      expect(field[12][2]).toBe(activePuyo!.color2) // 2つ目のぷよ
+
+      // 操作ぷよがクリアされている
+      expect(game.getActivePuyo()).toBeNull()
+    })
+
+    it('着地後に新しい操作ぷよが生成される', () => {
+      // 元の次ぷよの色を記録
+      const originalNextPuyo = game.getNextPuyo()
+
+      // 操作ぷよを着地させる
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 11
+      game.landActivePuyo()
+
+      // 新しい操作ぷよが生成される
+      game.spawnActivePuyo()
+      const newActivePuyo = game.getActivePuyo()
+
+      expect(newActivePuyo).not.toBeNull()
+      expect(newActivePuyo!.x).toBe(2) // 初期位置
+      expect(newActivePuyo!.y).toBe(0) // 初期位置
+      expect(newActivePuyo!.color1).toBe(originalNextPuyo.color1)
+      expect(newActivePuyo!.color2).toBe(originalNextPuyo.color2)
+    })
+
+    it('着地処理メソッドが存在する', () => {
+      expect(typeof game.landActivePuyo).toBe('function')
+    })
+
+    it('着地処理でフィールドの正しい位置にぷよが配置される', () => {
+      // 操作ぷよを特定の位置に配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 1
+      activePuyo!.y = 9
+      activePuyo!.color1 = 1
+      activePuyo!.color2 = 2
+
+      // 着地処理を実行
+      game.landActivePuyo()
+
+      // フィールドの正しい位置にぷよが配置されている
+      const field = game.getField()
+      expect(field[9][1]).toBe(1) // 1つ目のぷよ
+      expect(field[10][1]).toBe(2) // 2つ目のぷよ
+    })
+
+    it('着地処理と次ぷよ生成を統合したメソッドが存在する', () => {
+      expect(typeof game.processLanding).toBe('function')
+    })
+
+    it('統合メソッドで着地から次ぷよ生成まで一括処理される', () => {
+      // 操作ぷよを着地位置に配置
+      const activePuyo = game.getActivePuyo()
+      const originalColor1 = activePuyo!.color1
+      const originalColor2 = activePuyo!.color2
+      activePuyo!.x = 3
+      activePuyo!.y = 10
+
+      // 統合処理を実行
+      game.processLanding()
+
+      // フィールドに着地したぷよが配置されている
+      const field = game.getField()
+      expect(field[10][3]).toBe(originalColor1)
+      expect(field[11][3]).toBe(originalColor2)
+
+      // 新しい操作ぷよが生成されている
+      const newActivePuyo = game.getActivePuyo()
+      expect(newActivePuyo).not.toBeNull()
+      expect(newActivePuyo!.x).toBe(2) // 初期位置
+      expect(newActivePuyo!.y).toBe(0) // 初期位置
+    })
+  })
 })

```

## コミット: a249523

### メッセージ

```
feat: ぷよの着地検出を実装
- canMoveDown()メソッドを追加
- 底面と他のぷよとの衝突判定を実装
- 着地検出の包括的なテストを追加
- 5つのテストケースでRed-Green-Refactorサイクル完了
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts

### 変更内容

```diff
commit a249523899a913ed3d49bf0aa776a51c0eb334ee
Author: k2works <kakimomokuri@gmail.com>
Date:   Fri Jul 25 09:04:09 2025 +0900

    feat: ぷよの着地検出を実装
    
    - canMoveDown()メソッドを追加
    - 底面と他のぷよとの衝突判定を実装
    - 着地検出の包括的なテストを追加
    - 5つのテストケースでRed-Green-Refactorサイクル完了

diff --git a/app/src/game.ts b/app/src/game.ts
index 8f8287a..ed6e45f 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -316,6 +316,21 @@ export class Game {
     return this.canMoveToPosition(1)
   }
 
+  canMoveDown(): boolean {
+    if (!this.activePuyo) return false
+
+    const targetX = this.activePuyo.x
+    const targetY = this.activePuyo.y + 1
+
+    // フィールドの境界チェック（底面判定）
+    if (targetY + 1 >= Game.FIELD_HEIGHT) {
+      return false
+    }
+
+    // 他のぷよとの衝突チェック
+    return this.isPuyoPositionEmpty(targetX, targetY)
+  }
+
   private canMoveToPosition(deltaX: number): boolean {
     if (!this.activePuyo) return false
 
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index 3b4eaad..2ddcfef 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -65,9 +65,9 @@ describe('Game', () => {
 
     it('start()を呼ぶとキーボードイベントリスナーが設定される', () => {
       const setupInputHandlersSpy = vi.spyOn(game, 'setupInputHandlers')
-      
+
       game.start()
-      
+
       expect(setupInputHandlersSpy).toHaveBeenCalled()
       game.stop() // テスト後のクリーンアップ
     })
@@ -643,4 +643,58 @@ describe('Game', () => {
       expect(game.canMoveLeft()).toBe(false)
     })
   })
+
+  describe('ぷよの着地検出', () => {
+    beforeEach(() => {
+      vi.clearAllMocks()
+      game.start()
+    })
+
+    it('ぷよが底面に着地したことを検出できる', () => {
+      // 操作ぷよを底面近くに配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.y = 11 // 2つ目のぷよが底面(y=12)に接触
+
+      expect(game.canMoveDown()).toBe(false)
+    })
+
+    it('ぷよが他のぷよに着地したことを検出できる', () => {
+      // フィールドにぷよを配置
+      const field = game.getField()
+      field[8][2] = 1 // (2, 8)の位置にぷよを配置
+
+      // 操作ぷよをその上に配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 6 // 2つ目のぷよがy=7で、下のぷよ(y=8)に接触
+
+      expect(game.canMoveDown()).toBe(false)
+    })
+
+    it('ぷよが落下可能な状態を検出できる', () => {
+      // 操作ぷよを中間の位置に配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 5
+
+      expect(game.canMoveDown()).toBe(true)
+    })
+
+    it('ぷよの1つ目が他のぷよに衝突する場合も着地判定する', () => {
+      // フィールドにぷよを配置
+      const field = game.getField()
+      field[6][2] = 1 // (2, 6)の位置にぷよを配置
+
+      // 操作ぷよをそのすぐ上に配置
+      const activePuyo = game.getActivePuyo()
+      activePuyo!.x = 2
+      activePuyo!.y = 5 // 1つ目のぷよがy=5で、下のぷよ(y=6)に接触
+
+      expect(game.canMoveDown()).toBe(false)
+    })
+
+    it('着地判定メソッドが存在する', () => {
+      expect(typeof game.canMoveDown).toBe('function')
+    })
+  })
 })

```

