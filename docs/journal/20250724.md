# 作業履歴 2025-07-24

## 概要

2025-07-24の作業内容をまとめています。

## コミット: d55cf22

### メッセージ

```
feat: implement restart functionality and complete iteration 8
```

### 変更されたファイル

- M	app/src/game.ts
- M	docs/requirement.md

### 変更内容

```diff
commit d55cf22674841d0ac881b6c38eee07f5de3ca871
Author: k2works <kakimomokuri@gmail.com>
Date:   Thu Jul 24 00:11:49 2025 +0000

    feat: implement restart functionality and complete iteration 8

diff --git a/app/src/game.ts b/app/src/game.ts
index f214699..3518a5f 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -149,6 +149,9 @@ export class Game {
       case "batankyu":
         this.puyoImage.batankyu(this.frame);
         this.player.batankyu();
+        if (this.player.keyStatus.up) {
+          this.initialize();
+        }
         break;
     }
     this.frame++;
diff --git a/docs/requirement.md b/docs/requirement.md
index 9a6c514..ccdd417 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -233,9 +233,16 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] ゲームオーバー判定を実装する（新しいぷよを配置できない状態を検出する）
-- [ ] ゲームオーバー演出を実装する（ゲームオーバー時に特別な表示や効果を追加する）
-- [ ] リスタート機能を実装する（ゲームオーバー後に新しいゲームを始められるようにする）
+- [x] ゲームオーバー判定を実装する（新しいぷよを配置できない状態を検出する）
+- [x] ゲームオーバー演出を実装する（ゲームオーバー時に特別な表示や効果を追加する）
+- [x] リスタート機能を実装する（ゲームオーバー後に新しいゲームを始められるようにする）
 
 ### ふりかえり
 
+*   **Keep**:
+    *   既存のゲームオーバー判定と演出の仕組みを活かしつつ、リスタート機能という新しい要件をスムーズに追加できた。
+*   **Problem**:
+    *   リスタートのトリガーを何にするか（キー入力、クリックなど）の仕様が明確でなかったため、一旦「上キー」で実装した。よりユーザーフレンドリーな方法を検討する余地がある。
+*   **Try**:
+    *   要件が曖昧な場合は、複数の選択肢を検討し、最も一般的、あるいは実装が容易な方法から試すアプローチを継続する。
+

```

## コミット: cee112c

### メッセージ

```
docs: complete iteration 7 and add retrospective
```

### 変更されたファイル

- M	docs/requirement.md

### 変更内容

```diff
commit cee112c92db3cc0edcba88d4453c0a0c1e0488f8
Author: k2works <kakimomokuri@gmail.com>
Date:   Thu Jul 24 00:11:05 2025 +0000

    docs: complete iteration 7 and add retrospective

diff --git a/docs/requirement.md b/docs/requirement.md
index 776e7d5..9a6c514 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -216,12 +216,19 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] 全消し判定を実装する（盤面上のぷよがすべて消えたかどうかを判定する）
-- [ ] 全消しボーナスの計算を実装する（全消し時に加算するボーナス点を計算する）
-- [ ] 全消し演出を実装する（全消し時に特別な演出を表示する）
+- [x] 全消し判定を実装する（盤面上のぷよがすべて消えたかどうかを判定する）
+- [x] 全消しボーナスの計算を実装する（全消し時に加算するボーナス点を計算する）
+- [x] 全消し演出を実装する（全消し時に特別な演出を表示する）
 
 ### ふりかえり
 
+*   **Keep**:
+    *   以前のイテレーションで実装されていた`puyoCount`プロパティや`showZenkeshi`メソッドが、本イテレーションの要件を満たす上で効果的に機能した。
+*   **Problem**:
+    *   特になし。
+*   **Try**:
+    *   今後も、既存の機能をうまく再利用して効率的に開発を進める。
+
 ## イテレーション8: ゲームオーバーの実装
 
 ### TODO

```

## コミット: d8c734b

### メッセージ

```
docs: complete iteration 6 and add retrospective
```

### 変更されたファイル

- M	docs/requirement.md

### 変更内容

```diff
commit d8c734bb727acfe73aeda9dd7a2c47fb600371c0
Author: k2works <kakimomokuri@gmail.com>
Date:   Thu Jul 24 00:10:31 2025 +0000

    docs: complete iteration 6 and add retrospective

diff --git a/docs/requirement.md b/docs/requirement.md
index 44aff78..776e7d5 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -198,13 +198,20 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] 連鎖判定を実装する（ぷよが消えた後に新たな消去パターンがあるかを判定する）
-- [ ] 連鎖カウントを実装する（何連鎖目かをカウントする）
-- [ ] 連鎖ボーナスの計算を実装する（連鎖数に応じたボーナス点を計算する）
-- [ ] スコア表示を実装する（プレイヤーに現在のスコアを表示する）
+- [x] 連鎖判定を実装する（ぷよが消えた後に新たな消去パターンがあるかを判定する）
+- [x] 連鎖カウントを実装する（何連鎖目かをカウントする）
+- [x] 連鎖ボーナスの計算を実装する（連鎖数に応じたボーナス点を計算する）
+- [x] スコア表示を実装する（プレイヤーに現在のスコアを表示する）
 
 ### ふりかえり
 
+*   **Keep**:
+    *   これまでのイテレーションで構築したゲームループとスコア計算の仕組みがうまく機能し、本イテレーションの要件がほぼ実装済みであることを確認できた。
+*   **Problem**:
+    *   特になし。
+*   **Try**:
+    *   今後も、機能追加の前に既存コードで要件を満たせないかを確認するプロセスを継続する。
+
 ## イテレーション7: 全消しボーナスの実装
 
 ### TODO

```

## コミット: d31fa3a

### メッセージ

```
feat: implement puyo erasing and refactor connection check
```

### 変更されたファイル

- M	GEMINI.md
- M	app/src/stage.ts
- M	app/src/tests/stage.test.ts
- M	docs/requirement.md

### 変更内容

```diff
commit d31fa3a6eb6ee67afbad3ac88a7971612598e96b
Author: k2works <kakimomokuri@gmail.com>
Date:   Thu Jul 24 00:09:26 2025 +0000

    feat: implement puyo erasing and refactor connection check

diff --git a/GEMINI.md b/GEMINI.md
index 2f19d02..8365e85 100644
--- a/GEMINI.md
+++ b/GEMINI.md
@@ -31,4 +31,15 @@ docs/requirement のイテレーションごとのTODOを基にアプリケー
 - 各イテレーションごとにふりかえりを実施して docs/requirement.md の内容を更新する フォーマットは
   - Keep: 続けること
   - Problem: 問題点
-  - Try: 試すこと
\ No newline at end of file
+  - Try: 試すこと
+
+## Phase 4: ぷよぷよアプリケーションのドキュメント
+
+docs/journal/20250722.md 20250723.md からアプリケーションをどのように作ったか学習する
+- architecture.md を作成してアプリケーションのアーキテクチャをまとめる
+- design.md を作成してアプリケーションの設計をまとめる
+- implementation.md を作成してアプリケーションの実装をまとめる
+- mkdocs.yml を更新してドキュメントを生成できるようにする
+- docs/index.md も構成に合わせて更新する
+
+最後に次回同様の手順を再現で器用にしたいため replay.md を作成する
\ No newline at end of file
diff --git a/app/src/stage.ts b/app/src/stage.ts
index 6f1269b..351cf66 100644
--- a/app/src/stage.ts
+++ b/app/src/stage.ts
@@ -178,101 +178,101 @@ export class Stage {
         return isFalling;
     }
 
+    public checkConnections(x: number, y: number): { x: number, y: number }[] {
+        const targetPuyo = this.board[y][x];
+        if (!targetPuyo) {
+            return [];
+        }
 
-    // 消せるかどうか判定する
-    public checkErase(startFrame: number): EraseResult | null {
-        this.eraseStartFrame = startFrame;
-        this.erasingPuyoInfoList.length = 0;
+        const puyoColor = targetPuyo.puyo;
+        const visited: boolean[][] = Array(this.config.stageRows)
+            .fill(false)
+            .map(() => Array(this.config.stageCols).fill(false));
+        const connectedPuyos: { x: number, y: number }[] = [];
+        const queue: { x: number, y: number }[] = [{x, y}];
 
-        // 何色のぷよを消したかを記録する
-        const erasedPuyoColor: Record<string, boolean> = {};
+        visited[y][x] = true;
 
-        // 隣接ぷよを確認する関数内関数を作成
-        const sequencePuyoInfoList: PuyoInfo[] = [];
-        const existingPuyoInfoList: PuyoInfo[] = [];
-        const checkSequentialPuyo = (x: number, y: number): void => {
-            // ぷよがあるか確認する
-            const orig = this.board[y][x];
-            if (!orig) {
-                // ないなら何もしない
-                return;
-            }
-            // あるなら一旦退避して、メモリ上から消す
-            const puyo = this.board[y][x]!.puyo;
-            sequencePuyoInfoList.push({
-                x: x,
-                y: y,
-                cell: this.board[y][x] as PuyoCell,
-            });
-            this.board[y][x] = null;
-
-            // 四方向の周囲ぷよを確認する
-            const direction = [
-                [0, 1],
-                [1, 0],
-                [0, -1],
-                [-1, 0],
+        while (queue.length > 0) {
+            const current = queue.shift()!;
+            connectedPuyos.push({x: current.x, y: current.y});
+
+            const directions = [
+                {x: 0, y: 1},
+                {x: 0, y: -1},
+                {x: 1, y: 0},
+                {x: -1, y: 0},
             ];
-            for (let i = 0; i < direction.length; i++) {
-                const dx = x + direction[i][0];
-                const dy = y + direction[i][1];
+
+            for (const dir of directions) {
+                const nextX = current.x + dir.x;
+                const nextY = current.y + dir.y;
+
                 if (
-                    dx < 0 ||
-                    dy < 0 ||
-                    dx >= this.config.stageCols ||
-                    dy >= this.config.stageRows
+                    nextX >= 0 &&
+                    nextX < this.config.stageCols &&
+                    nextY >= 0 &&
+                    nextY < this.config.stageRows &&
+                    !visited[nextY][nextX]
                 ) {
-                    // ステージの外にはみ出た
-                    continue;
-                }
-                const cell = this.board[dy][dx];
-                if (!cell || cell.puyo !== puyo) {
-                    // ぷよの色が違う
-                    continue;
+                    visited[nextY][nextX] = true;
+                    const nextPuyo = this.board[nextY][nextX];
+                    if (nextPuyo && nextPuyo.puyo === puyoColor) {
+                        queue.push({x: nextX, y: nextY});
+                    }
                 }
-                // そのまわりのぷよも消せるか確認する
-                checkSequentialPuyo(dx, dy);
             }
-        };
+        }
+
+        return connectedPuyos;
+    }
+
+
+    // 消せるかどうか判定する
+    public checkErase(startFrame: number): EraseResult | null {
+        this.eraseStartFrame = startFrame;
+        this.erasingPuyoInfoList.length = 0;
+        const erasedPuyoColor: Record<string, boolean> = {};
+        const checkedPuyos: boolean[][] = Array(this.config.stageRows)
+            .fill(false)
+            .map(() => Array(this.config.stageCols).fill(false));
 
-        // 実際に削除できるかの確認を行う
         for (let y = 0; y < this.config.stageRows; y++) {
             for (let x = 0; x < this.config.stageCols; x++) {
-                sequencePuyoInfoList.length = 0;
-                const puyoColor = this.board[y][x] && this.board[y][x]!.puyo;
-                checkSequentialPuyo(x, y);
-                if (
-                    sequencePuyoInfoList.length == 0 ||
-                    sequencePuyoInfoList.length < this.config.erasePuyoCount
-                ) {
-                    // 連続して並んでいる数が足りなかったので消さない
-                    if (sequencePuyoInfoList.length) {
-                        // 退避していたぷよを消さないリストに追加する
-                        existingPuyoInfoList.push(...sequencePuyoInfoList);
-                    }
-                } else {
-                    // これらは消して良いので消すリストに追加する
-                    this.erasingPuyoInfoList.push(...sequencePuyoInfoList);
-                    if (puyoColor !== null && puyoColor !== undefined) {
-                        erasedPuyoColor[puyoColor] = true;
+                if (checkedPuyos[y][x] || !this.board[y][x]) {
+                    continue;
+                }
+
+                const connectedPuyos = this.checkConnections(x, y);
+
+                if (connectedPuyos.length >= this.config.erasePuyoCount) {
+                    const puyoColor = this.board[y][x]!.puyo;
+                    erasedPuyoColor[puyoColor] = true;
+
+                    for (const puyo of connectedPuyos) {
+                        this.erasingPuyoInfoList.push({
+                            x: puyo.x,
+                            y: puyo.y,
+                            cell: this.board[puyo.y][puyo.x] as PuyoCell,
+                        });
+                        this.board[puyo.y][puyo.x] = null;
                     }
                 }
-            }
-        }
-        this.puyoCount -= this.erasingPuyoInfoList.length;
 
-        // 消さないリストに入っていたぷよをメモリに復帰させる
-        for (const info of existingPuyoInfoList) {
-            this.board[info.y][info.x] = info.cell;
+                for (const puyo of connectedPuyos) {
+                    checkedPuyos[puyo.y][puyo.x] = true;
+                }
+            }
         }
 
-        if (this.erasingPuyoInfoList.length) {
-            // もし消せるならば、消えるぷよの個数と色の情報をまとめて返す
+        if (this.erasingPuyoInfoList.length > 0) {
+            this.puyoCount -= this.erasingPuyoInfoList.length;
             return {
                 piece: this.erasingPuyoInfoList.length,
                 color: parseInt(Object.keys(erasedPuyoColor)[0], 10),
             };
         }
+
         return null;
     }
 
diff --git a/app/src/tests/stage.test.ts b/app/src/tests/stage.test.ts
index bdf1f7f..a4c037d 100644
--- a/app/src/tests/stage.test.ts
+++ b/app/src/tests/stage.test.ts
@@ -145,7 +145,27 @@ import {Score} from "../score";
             expect(result).toBe(null);
         });
 
-        
+        describe("ぷよの接続判定を実装する", () => {
+            it("隣接する同じ色のぷよを検出する", () => {
+                // 準備: 盤面にぷよを配置
+                stage.setPuyo(0, 0, 1); // (0,0) に緑ぷよ
+                stage.setPuyo(0, 1, 1); // (0,1) に緑ぷよ
+                stage.setPuyo(1, 0, 2); // (1,0) に青ぷよ
+
+                // 実行: (0,0)のぷよから接続判定を開始
+                const connectedPuyos = stage.checkConnections(0, 0);
+
+                // 検証: 接続されているぷよの数が正しいか
+                expect(connectedPuyos.length).toBe(2);
+                // 検証: 接続されているぷよの位置が正しいか
+                expect(connectedPuyos).toEqual(
+                    expect.arrayContaining([
+                        {x: 0, y: 0},
+                        {x: 0, y: 1},
+                    ])
+                );
+            });
+        });
 
         describe("四方向周囲ぷよを確認する", () => {
             it("ステージの外にはみ出た", () => {
diff --git a/docs/requirement.md b/docs/requirement.md
index 008422f..44aff78 100644
--- a/docs/requirement.md
+++ b/docs/requirement.md
@@ -179,13 +179,21 @@ GameOverCheck ..> GameOverAnimation : <<include>>
 
 ### TODO
 
-- [ ] ぷよの接続判定を実装する（隣接する同じ色のぷよを検出する）
-- [ ] 4つ以上つながったぷよの検出を実装する（消去対象となるぷよのグループを特定する）
-- [ ] ぷよの消去処理を実装する（消去対象のぷよを実際に消す）
-- [ ] 消去後の落下処理を実装する（消去された後の空きスペースにぷよが落ちてくる）
+- [x] ぷよの接続判定を実装する（隣接する同じ色のぷよを検出する）
+- [x] 4つ以上つながったぷよの検出を実装する（消去対象となるぷよのグループを特定する）
+- [x] ぷよの消去処理を実装する（消去対象のぷよを実際に消す）
+- [x] 消去後の落下処理を実装する（消去された後の空きスペースにぷよが落ちてくる）
 
 ### ふりかえり
 
+*   **Keep**:
+    *   TDD（テスト駆動開発）のサイクルに従い、まずテストを作成してから実装を進めることで、自信を持ってリファクタリングに取り組めた。
+    *   `checkConnections`のように、責務を単一にするメソッドを切り出すことで、既存の`checkErase`メソッドがシンプルになり、コードの可読性と保守性が向上した。
+*   **Problem**:
+    *   ルートディレクトリで`npm test`を実行してしまい、エラーが発生した。`app`ディレクトリに移動して実行する必要があった。
+*   **Try**:
+    *   プロジェクトの構造をより意識し、コマンドを実行する前に正しいディレクトリにいることを確認する。
+
 ## イテレーション6: 連鎖反応の実装
 
 ### TODO

```

