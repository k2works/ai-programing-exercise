# 作業履歴 2025-07-29

## 概要

2025-07-29の作業内容をまとめています。

## コミット: d0b0e3a

### メッセージ

```
test: グローバルモックの参照をglobalからglobalThisに変更
```

### 変更されたファイル

- M	app/src/tests/puyoimage.test.ts
- M	app/src/tests/setup.ts

### 変更内容

```diff
commit d0b0e3ae0f7be19c982d286342cdea7b181f8ba4
Author: k2works <kakimomokuri@gmail.com>
Date:   Tue Jul 29 14:46:13 2025 +0900

    test: グローバルモックの参照をglobalからglobalThisに変更

diff --git a/app/src/tests/puyoimage.test.ts b/app/src/tests/puyoimage.test.ts
index 125569f..e4a9c60 100644
--- a/app/src/tests/puyoimage.test.ts
+++ b/app/src/tests/puyoimage.test.ts
@@ -8,7 +8,7 @@ describe('PuyoImage', () => {
 
   beforeEach(() => {
     // setup.tsで定義されたグローバルモックを使用
-    const createMockContext = (global as any).createMockContext
+    const createMockContext = (globalThis as any).createMockContext
     if (createMockContext) {
       mockContext = createMockContext()
     } else {
@@ -23,27 +23,27 @@ describe('PuyoImage', () => {
         stroke: vi.fn(),
         save: vi.fn(),
         restore: vi.fn(),
-        set fillStyle(value: string) {},
+        set fillStyle(_value: string) {},
         get fillStyle() {
           return '#000000'
         },
-        set strokeStyle(value: string) {},
+        set strokeStyle(_value: string) {},
         get strokeStyle() {
           return '#000000'
         },
-        set lineWidth(value: number) {},
+        set lineWidth(_value: number) {},
         get lineWidth() {
           return 1
         },
-        set font(value: string) {},
+        set font(_value: string) {},
         get font() {
           return '10px sans-serif'
         },
-        set textAlign(value: string) {},
+        set textAlign(_value: string) {},
         get textAlign() {
           return 'start'
         },
-        set textBaseline(value: string) {},
+        set textBaseline(_value: string) {},
         get textBaseline() {
           return 'alphabetic'
         },
diff --git a/app/src/tests/setup.ts b/app/src/tests/setup.ts
index 7d83307..c77b684 100644
--- a/app/src/tests/setup.ts
+++ b/app/src/tests/setup.ts
@@ -72,4 +72,4 @@ beforeEach(() => {
 })
 
 // グローバルにcanvas contextモックを利用可能にする
-;(global as any).createMockContext = createMockContext
+;(globalThis as any).createMockContext = createMockContext

```

## コミット: 411adfd

### メッセージ

```
test: Gameクラスのテスト用ラッパーメソッドを追加しテストコードを修正
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/tests/game.test.ts
- M	app/tsconfig.json

### 変更内容

```diff
commit 411adfd47f6c4f1d7cc6cf75bc39854a36acc686
Author: k2works <kakimomokuri@gmail.com>
Date:   Tue Jul 29 14:45:50 2025 +0900

    test: Gameクラスのテスト用ラッパーメソッドを追加しテストコードを修正

diff --git a/app/src/game.ts b/app/src/game.ts
index c310463..1849730 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -696,4 +696,29 @@ export class Game {
       this.stage.stopZenkeshiEffect()
     }
   }
+
+  // テスト用メソッド: 新しいアクティブぷよを生成（private spawnActivePuyo のラッパー）
+  createNewActivePuyo(): void {
+    this.spawnActivePuyo()
+  }
+
+  // テスト用メソッド: 落下処理をシミュレート（private updateFalling のラッパー）
+  simulateFalling(): void {
+    this.updateFalling()
+  }
+
+  // テスト用メソッド: 1フレームの更新と描画をシミュレート（private updateAndRender のラッパー）
+  simulateFrame(): void {
+    this.updateAndRender()
+  }
+
+  // テスト用メソッド: 着地処理をシミュレート（private processLanding のラッパー）
+  simulateLanding(): void {
+    this.processLanding()
+  }
+
+  // テスト用メソッド: 壁キック処理をシミュレート（private tryWallKick のラッパー）
+  simulateWallKick(): void {
+    this.tryWallKick()
+  }
 }
\ No newline at end of file
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index ddd436e..cf09b6e 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1,6 +1,5 @@
 import { describe, it, expect, beforeEach, vi } from 'vitest'
 import { Game } from '../game'
-import { PuyoImage } from '../puyoimage'
 
 // PuyoImageクラスをモック化
 const mockPuyoImageInstance = {
@@ -173,7 +172,7 @@ describe('Game', () => {
     })
 
     it('操作ぷよが初期位置に配置される', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const activePuyo = game.getActivePuyo()
 
       expect(activePuyo).toBeDefined()
@@ -182,7 +181,7 @@ describe('Game', () => {
     })
 
     it('次のぷよが更新される', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const newNext = game.getNextPuyo()
 
       // 次のぷよが新しく必ず生成される
@@ -201,7 +200,7 @@ describe('Game', () => {
     })
 
     it('操作ぷよが画面に描画される', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       game.renderActivePuyo()
 
       // PuyoImageのrenderActivePuyoメソッドが呼ばれる
@@ -216,7 +215,7 @@ describe('Game', () => {
     })
 
     it('ぷよの色が正しく設定される', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       game.renderActivePuyo()
 
       // fillStyleが設定される
@@ -230,13 +229,13 @@ describe('Game', () => {
     })
 
     it('操作ぷよが自動的に落下する', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const initialPuyo = game.getActivePuyo()
       const initialY = initialPuyo!.y
 
       // 落下間隔分だけ時間を進めて落下処理を実行
       for (let i = 0; i < 30; i++) {
-        game.updateFalling()
+        game.simulateFalling()
       }
 
       const updatedPuyo = game.getActivePuyo()
@@ -244,14 +243,14 @@ describe('Game', () => {
     })
 
     it('操作ぷよが下に障害物があるときは落下しない', () => {
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       // フィールドの底部に到達した状態をシミュレート
       const activePuyo = game.getActivePuyo()
       activePuyo!.y = 11 // フィールドの下の方
 
       // 落下間隔分だけ時間を進める
       for (let i = 0; i < 30; i++) {
-        game.updateFalling()
+        game.simulateFalling()
       }
 
       // 底部に到達しているので位置が変わらない
@@ -330,7 +329,7 @@ describe('Game', () => {
     beforeEach(() => {
       vi.clearAllMocks()
       // 操作ぷよを生成しておく
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     it('左キーが押されたときぷよが左に移動する', () => {
@@ -463,7 +462,7 @@ describe('Game', () => {
   describe('移動後の表示更新', () => {
     beforeEach(() => {
       vi.clearAllMocks()
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     it('移動後にrenderが呼ばれて表示が更新される', () => {
@@ -475,7 +474,7 @@ describe('Game', () => {
       game.handleKeyDown(leftKeyEvent)
 
       // ゲームループを1回実行
-      game.updateAndRender()
+      game.simulateFrame()
 
       // renderが呼ばれることを確認
       expect(renderSpy).toHaveBeenCalled()
@@ -486,7 +485,7 @@ describe('Game', () => {
       const renderSpy = vi.spyOn(game, 'render')
 
       // キーを押さずにゲームループを実行
-      game.updateAndRender()
+      game.simulateFrame()
 
       // renderが呼ばれることを確認
       expect(renderSpy).toHaveBeenCalled()
@@ -543,7 +542,7 @@ describe('Game', () => {
   describe('移動可能性チェック', () => {
     beforeEach(() => {
       vi.clearAllMocks()
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     it('左端（x=0）でさらに左に移動しようとしても移動できない', () => {
@@ -779,7 +778,7 @@ describe('Game', () => {
       game.landActivePuyo()
 
       // 新しい操作ぷよが生成される
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const newActivePuyo = game.getActivePuyo()
 
       expect(newActivePuyo).not.toBeNull()
@@ -811,7 +810,7 @@ describe('Game', () => {
     })
 
     it('着地処理と次ぷよ生成を統合したメソッドが存在する', () => {
-      expect(typeof game.processLanding).toBe('function')
+      expect(typeof game.simulateLanding).toBe('function')
     })
 
     it('統合メソッドで着地から次ぷよ生成まで一括処理される', () => {
@@ -824,7 +823,7 @@ describe('Game', () => {
       activePuyo!.direction = 0
 
       // 統合処理を実行
-      game.processLanding()
+      game.simulateLanding()
 
       // フィールドに着地したぷよが配置されている（重力処理により底に配置される）
       const field = game.getField()
@@ -867,7 +866,7 @@ describe('Game', () => {
 
       vi.clearAllMocks()
       game = new Game(mockCanvas, mockScoreDisplay)
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     it('着地したぷよは左右に移動できない', () => {
@@ -878,7 +877,7 @@ describe('Game', () => {
 
       // 落下タイマーが満たされるまで処理を実行（着地するはず）
       for (let i = 0; i < 30; i++) {
-        game.updateFalling()
+        game.simulateFalling()
       }
 
       // 着地後は操作ぷよが新しく生成されている
@@ -905,7 +904,7 @@ describe('Game', () => {
 
       // 落下処理を実行（fallTimerが満たされるまで繰り返す）
       for (let i = 0; i < 30; i++) {
-        game.updateFalling()
+        game.simulateFalling()
       }
 
       // 操作ぷよが新しく生成されている（着地処理が実行された）
@@ -937,7 +936,7 @@ describe('Game', () => {
 
       vi.clearAllMocks()
       game = new Game(mockCanvas, mockScoreDisplay)
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     it('フィールドに固定されたぷよが描画される', () => {
@@ -994,7 +993,7 @@ describe('Game', () => {
 
       vi.clearAllMocks()
       game = new Game(mockCanvas, mockScoreDisplay)
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
     })
 
     describe('回転方向の管理', () => {
@@ -1012,7 +1011,7 @@ describe('Game', () => {
 
         // 回転間隔分だけアップデートを実行して回転処理を行う
         for (let i = 0; i < 15; i++) {
-          game.updateAndRender()
+          game.simulateFrame()
         }
 
         const newDirection = game.getActivePuyoDirection()
@@ -1034,7 +1033,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let j = 0; j < 15; j++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // キーアップイベントも送信してキー状態をリセット
@@ -1061,7 +1060,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           const rotatedPositions = game.getActivePuyoPositions()
@@ -1098,7 +1097,7 @@ describe('Game', () => {
           const upKeyEvent1 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
           game.handleKeyDown(upKeyEvent1)
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
           game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
 
@@ -1111,7 +1110,7 @@ describe('Game', () => {
           const upKeyEvent2 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
           game.handleKeyDown(upKeyEvent2)
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
           game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
 
@@ -1124,7 +1123,7 @@ describe('Game', () => {
           const upKeyEvent3 = new KeyboardEvent('keydown', { key: 'ArrowUp' })
           game.handleKeyDown(upKeyEvent3)
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
           game.handleKeyUp(new KeyboardEvent('keyup', { key: 'ArrowUp' }))
 
@@ -1245,7 +1244,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 回転していないことを確認
@@ -1276,7 +1275,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 壁キックにより回転が成功し、左に移動している
@@ -1298,7 +1297,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 壁キックにより回転が成功し、右に移動している
@@ -1320,7 +1319,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 壁キックにより回転が成功し、下に移動している
@@ -1349,7 +1348,7 @@ describe('Game', () => {
 
           // 回転間隔分だけアップデートを実行
           for (let i = 0; i < 15; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 壁キックでも回転できないので変化なし
@@ -1359,7 +1358,7 @@ describe('Game', () => {
       })
 
       it('壁キック処理をチェックするメソッドが存在する', () => {
-        expect(typeof game.tryWallKick).toBe('function')
+        expect(typeof game.simulateWallKick).toBe('function')
       })
     })
 
@@ -1407,15 +1406,12 @@ describe('Game', () => {
           // 落下を有効にする
           game.setFallInterval(1) // 毎フレーム落下
 
-          let finalY = -1
           // 底面まで落下させる
           for (let i = 0; i < 10; i++) {
             const currentPuyo = game.getActivePuyo()
-            if (currentPuyo) {
-              finalY = currentPuyo.y
-            }
+            if (!currentPuyo) break
 
-            game.updateAndRender()
+            game.simulateFrame()
 
             // 着地したかチェック
             if (!game.getActivePuyo()) {
@@ -1462,7 +1458,7 @@ describe('Game', () => {
 
           // 障害物に当たるまで落下させる
           for (let i = 0; i < 20; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
 
             // 着地したかチェック
             if (!game.getActivePuyo()) {
@@ -1496,7 +1492,7 @@ describe('Game', () => {
 
           // 高速落下間隔（3フレーム）まで更新
           for (let i = 0; i < 3; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 下キーが押されているときは高速落下するはず
@@ -1514,7 +1510,7 @@ describe('Game', () => {
           game.setFallInterval(30)
 
           // 下キーを押さずに1フレーム更新
-          game.updateAndRender()
+          game.simulateFrame()
 
           // 通常の落下間隔なので、まだ落ちないはず
           expect(activePuyo.y).toBe(initialY)
@@ -1533,7 +1529,7 @@ describe('Game', () => {
 
           // 十分なフレーム数更新（2回の高速落下が発生するよう6フレーム）
           for (let i = 0; i < 6; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 継続的に落下しているはず（2回落下して2ピクセル下に）
@@ -1675,8 +1671,8 @@ describe('Game', () => {
           // 着地しているはず
           expect(game.hasLandedTest()).toBe(true)
 
-          // 落下処理は内部的に処理されるので、直接processLandingを実行
-          game.processLanding()
+          // 落下処理は内部的に処理されるので、直接simulateLandingを実行
+          game.simulateLanding()
 
           // 着地により新しいぷよが生成されるはず
           const newActivePuyo = game.getActivePuyo()
@@ -1701,7 +1697,7 @@ describe('Game', () => {
 
           // 高速落下処理を実行（3フレーム必要）
           for (let i = 0; i < 3; i++) {
-            game.updateAndRender()
+            game.simulateFrame()
           }
 
           // 着地により新しいぷよが生成されているはず
@@ -1870,7 +1866,7 @@ describe('Game', () => {
         field[11][2] = 1 // 赤（上）
         field[10][2] = 1 // 赤（上）
 
-        // 3つでは消去対象にならない
+        // 3つは消去対象にならない
         const eliminateGroups = game.findEliminateGroups()
         expect(eliminateGroups).toHaveLength(0)
       })
@@ -2391,7 +2387,7 @@ describe('Game', () => {
         field[12][1] = field[12][2] = field[12][3] = field[12][4] = 1
 
         // 操作ぷよとして赤ぷよを設定（着地すると5つになって消去される）
-        game.spawnActivePuyo()
+        game.createNewActivePuyo()
         const activePuyo = game.getActivePuyo()
         if (activePuyo) {
           activePuyo.x = 0
@@ -2404,7 +2400,7 @@ describe('Game', () => {
         const initialScore = game.getScore()
 
         // 着地処理を実行（この時点で連鎖処理も自動実行されるべき）
-        game.processLanding()
+        game.simulateLanding()
 
         // 連鎖が発生してスコアが上がっていることを確認
         expect(game.getScore()).toBeGreaterThan(initialScore)
@@ -2428,7 +2424,7 @@ describe('Game', () => {
         field[12][2] = 1
 
         // 操作ぷよとして青ぷよを設定
-        game.spawnActivePuyo()
+        game.createNewActivePuyo()
         const activePuyo = game.getActivePuyo()
         if (activePuyo) {
           activePuyo.x = 1
@@ -2441,7 +2437,7 @@ describe('Game', () => {
         const initialScore = game.getScore()
 
         // 着地処理を実行
-        game.processLanding()
+        game.simulateLanding()
 
         // スコアは変わらない（連鎖が発生していない）
         expect(game.getScore()).toBe(initialScore)
@@ -2508,7 +2504,7 @@ describe('Game', () => {
       field[12][2] = 2 // 緑ぷよが底にある（間にfield[11][2]が空）
 
       // 操作ぷよを別の場所に配置して着地させる
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const activePuyo = game.getActivePuyo()
       if (activePuyo) {
         activePuyo.x = 0
@@ -2519,7 +2515,7 @@ describe('Game', () => {
       }
 
       // 着地処理を実行（実際のゲームプレイを模擬）
-      game.processLanding()
+      game.simulateLanding()
 
       // 操作ぷよの着地とは関係なく、浮いていたぷよが落下していることを確認
       expect(field[10][2]).toBe(0) // 元の位置は空
@@ -2537,7 +2533,7 @@ describe('Game', () => {
       field[12][3] = 3 // 青（間にfield[11][3]が空）
 
       // 操作ぷよを別の場所で着地させる
-      game.spawnActivePuyo()
+      game.createNewActivePuyo()
       const activePuyo = game.getActivePuyo()
       if (activePuyo) {
         activePuyo.x = 0
@@ -2548,7 +2544,7 @@ describe('Game', () => {
       }
 
       // 着地処理を実行
-      game.processLanding()
+      game.simulateLanding()
 
       // すべてのぷよが正しく落下していることを確認
       expect(field[8][3]).toBe(0) // 元の位置は空
@@ -2895,7 +2891,7 @@ describe('Game', () => {
         field[1][2] = 2 // 2つ目のぷよの位置
 
         // ぷよ生成を試行
-        game.spawnActivePuyo()
+        game.createNewActivePuyo()
 
         // ゲームオーバー演出が自動的に開始されることを確認
         expect(game.isGameOverEffectActive()).toBe(true)
diff --git a/app/tsconfig.json b/app/tsconfig.json
index ae5481b..f8c2c79 100644
--- a/app/tsconfig.json
+++ b/app/tsconfig.json
@@ -17,6 +17,5 @@
     "noUnusedParameters": true,
     "noFallthroughCasesInSwitch": true
   },
-  "include": ["src"],
-  "exclude": ["src/tests/**/*", "**/*.test.ts"]
+  "include": ["src"]
 }

```

## コミット: c3bb23e

### メッセージ

```
refactor: Gameクラスを大幅リファクタリングし、描画・状態管理・入力処理を各クラスに分離
```

### 変更されたファイル

- M	app/src/game.ts
- M	app/src/player.ts
- M	app/src/puyo.ts
- M	app/src/puyoimage.ts
- M	app/src/stage.ts
- M	app/src/tests/game.test.ts
- M	app/src/tests/player.test.ts
- M	app/src/tests/puyoimage.test.ts
- M	app/src/tests/setup.ts

### 変更内容

```diff
commit c3bb23e59e445bbc4716035f5a26876d96f04666
Author: k2works <kakimomokuri@gmail.com>
Date:   Tue Jul 29 14:26:08 2025 +0900

    refactor: Gameクラスを大幅リファクタリングし、描画・状態管理・入力処理を各クラスに分離

diff --git a/app/src/game.ts b/app/src/game.ts
index 4134879..c310463 100644
--- a/app/src/game.ts
+++ b/app/src/game.ts
@@ -1,70 +1,56 @@
+import { Puyo } from './puyo'
+import { Stage } from './stage'
+import { Player } from './player'
+import { PuyoImage } from './puyoimage'
+
+/**
+ * ゲーム全体の制御とメインループを担当するクラス
+ *
+ * 責務:
+ * - ゲームループの管理
+ * - クラス間の連携とオーケストレーション
+ * - ゲーム状態の管理
+ * - 外部インターフェース（スコア表示など）の管理
+ */
 export class Game {
-  private static readonly FIELD_WIDTH = 6
-  private static readonly FIELD_HEIGHT = 13
-  private static readonly CELL_SIZE = 30
-  private static readonly FIELD_OFFSET_X = 10
-  private static readonly FIELD_OFFSET_Y = 10
-  private static readonly PUYO_COLORS = 4 // 1-4の色を使用
-  private static readonly PUYO_COLOR_MAP = [
-    '', // 0は使用しない
-    '#FF0000', // 1: 赤
-    '#00FF00', // 2: 緑
-    '#0000FF', // 3: 青
-    '#FFFF00', // 4: 黄
-  ]
   private static readonly FALL_SPEED = 1 // 落下速度
   private static readonly FALL_INTERVAL = 30 // 落下間隔（フレーム数）
 
-  private canvas: HTMLCanvasElement
-  private context: CanvasRenderingContext2D
+  // 依存クラス
+  private puyo: Puyo
+  private stage: Stage
+  private player: Player
+  private puyoImage: PuyoImage
+
+  // ゲーム状態
   private scoreDisplay: HTMLElement
   private isRunning = false
-  private score = 0
   private gameState: 'ready' | 'playing' | 'gameover' = 'ready'
-  private field: number[][]
-  private nextPuyo: { color1: number; color2: number }
-  private activePuyo: {
-    x: number
-    y: number
-    color1: number
-    color2: number
-    direction: number
-  } | null = null
+
+  // 落下制御
   private fallSpeed = Game.FALL_SPEED
-  private fallTimer = 0 // 落下タイマー
+  private fallTimer = 0
   private fallInterval = Game.FALL_INTERVAL
-  // 入力状態の管理
-  private leftKeyPressed = false
-  private rightKeyPressed = false
-  private upKeyPressed = false
-  private downKeyPressed = false
-  private moveTimer = 0 // 移動タイマー
-  private rotationTimer = 0 // 回転タイマー
-  private static readonly MOVE_INTERVAL = 8 // 移動間隔（フレーム数）
-  private static readonly ROTATION_INTERVAL = 15 // 回転間隔（フレーム数）
 
   constructor(canvas: HTMLCanvasElement, scoreDisplay: HTMLElement) {
-    this.canvas = canvas
     this.scoreDisplay = scoreDisplay
 
-    const context = canvas.getContext('2d')
-    if (!context) {
-      throw new Error('Could not get 2D context from canvas')
-    }
-    this.context = context
-
-    // ゲームフィールドの初期化
-    this.field = Array(Game.FIELD_HEIGHT)
-      .fill(null)
-      .map(() => Array(Game.FIELD_WIDTH).fill(0))
+    // 依存クラスの初期化
+    this.puyo = new Puyo()
+    this.stage = new Stage()
+    this.player = new Player()
+    this.puyoImage = new PuyoImage(canvas)
 
-    // 次のぷよの初期化
-    this.nextPuyo = this.generateNewPuyoPair()
+    // プレイヤー操作のコールバック設定
+    this.setupPlayerCallbacks()
 
     // 初期スコア表示の設定
     this.updateScoreDisplay()
   }
 
+  /**
+   * ゲーム開始
+   */
   start(): void {
     if (this.isRunning) return
 
@@ -74,19 +60,29 @@ export class Game {
     this.gameLoop()
   }
 
+  /**
+   * ゲーム停止
+   */
   stop(): void {
     this.isRunning = false
   }
 
+  /**
+   * ゲーム初期化
+   */
   private initialize(): void {
-    this.score = 0
+    this.stage.resetScore()
+    this.stage.resetField()
     this.updateScoreDisplay()
-    this.clearCanvas()
+    this.puyoImage.clearCanvas()
 
     // 最初の操作ぷよを生成
     this.spawnActivePuyo()
   }
 
+  /**
+   * メインゲームループ
+   */
   private gameLoop(): void {
     if (!this.isRunning) return
 
@@ -95,1044 +91,609 @@ export class Game {
     requestAnimationFrame(() => this.gameLoop())
   }
 
+  /**
+   * 更新と描画の統合処理
+   */
+  private updateAndRender(): void {
+    this.update()
+    this.render()
+  }
+
+  /**
+   * ゲーム状態の更新
+   */
   private update(): void {
     this.updateFalling()
     this.updateMovement()
     this.updateRotation()
+    this.player.updateTimers()
   }
 
-  // テスト用のpublicメソッド - 1フレーム分の更新と描画を実行
-  updateAndRender(): void {
-    this.update()
-    this.render()
-  }
-
-  // renderメソッドをpublicにして外部からテスト可能にする
+  /**
+   * 描画処理
+   */
   render(): void {
-    this.clearCanvas()
-    this.renderField()
-    this.renderActivePuyo()
-    this.renderNextPuyo()
-    this.renderZenkeshiEffect()
-    this.renderGameOverEffect()
-  }
-
-  private clearCanvas(): void {
-    this.context.fillStyle = '#000000'
-    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)
-  }
-
-  private updateScoreDisplay(): void {
-    this.scoreDisplay.textContent = `スコア: ${this.score}`
-  }
-
-  // テスト用のpublicメソッド
-  getScore(): number {
-    return this.score
-  }
+    this.puyoImage.clearCanvas()
+    this.puyoImage.renderField(this.stage.getField())
 
-  isGameRunning(): boolean {
-    return this.isRunning
-  }
-
-  getGameState(): string {
-    return this.gameState
-  }
-
-  getField(): number[][] {
-    return this.field
-  }
-
-  getNextPuyo(): { color1: number; color2: number } {
-    return this.nextPuyo
-  }
-
-  renderField(): void {
-    const fieldWidth = Game.FIELD_WIDTH * Game.CELL_SIZE
-    const fieldHeight = Game.FIELD_HEIGHT * Game.CELL_SIZE
-
-    // フィールドの背景を描画
-    this.context.fillStyle = '#f0f0f0'
-    this.context.fillRect(Game.FIELD_OFFSET_X, Game.FIELD_OFFSET_Y, fieldWidth, fieldHeight)
-
-    // フィールドの枠線を描画
-    this.context.strokeStyle = '#000000'
-    this.context.strokeRect(Game.FIELD_OFFSET_X, Game.FIELD_OFFSET_Y, fieldWidth, fieldHeight)
-
-    // フィールドに固定されたぷよを楕円形で描画
-    for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
-      for (let x = 0; x < Game.FIELD_WIDTH; x++) {
-        const puyoColor = this.field[y][x]
-        if (puyoColor !== 0) {
-          // ぷよが存在する場合は楕円形で描画
-          const drawX = Game.FIELD_OFFSET_X + x * Game.CELL_SIZE
-          const drawY = Game.FIELD_OFFSET_Y + y * Game.CELL_SIZE
-          this.drawPuyo(drawX, drawY, this.getPuyoColor(puyoColor))
-        }
-      }
+    // アクティブぷよの描画
+    const activePuyo = this.puyo.getActivePuyo()
+    if (activePuyo) {
+      this.puyoImage.renderActivePuyo(activePuyo)
     }
-  }
 
-  clearScreen(): void {
-    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
-  }
+    // 次のぷよの描画
+    this.puyoImage.renderNextPuyo(this.puyo.getNextPuyo())
 
-  generateNewPuyoPair(): { color1: number; color2: number } {
-    return {
-      color1: Math.floor(Math.random() * Game.PUYO_COLORS) + 1,
-      color2: Math.floor(Math.random() * Game.PUYO_COLORS) + 1,
+    // 演出の描画
+    if (this.stage.isZenkeshiEffectActive()) {
+      this.puyoImage.renderZenkeshiEffect()
     }
-  }
 
-  spawnActivePuyo(): void {
-    // ゲームオーバー判定: 新しいぷよを配置できるかチェック
-    if (this.isGameOver()) {
-      // ゲームオーバーの場合は演出を開始し、アクティブぷよは生成しない
-      this.triggerGameOver()
-      this.activePuyo = null
-      return
+    if (this.stage.isGameOverEffectActive()) {
+      this.puyoImage.renderGameOverEffect()
     }
-
-    // 現在の次のぷよを操作ぷよとして配置
-    this.activePuyo = {
-      x: 2, // フィールド中央
-      y: 0, // 上端
-      color1: this.nextPuyo.color1,
-      color2: this.nextPuyo.color2,
-      direction: 0, // 初期状態は縦配置（下向き）
-    }
-
-    // 新しい次のぷよを生成
-    this.nextPuyo = this.generateNewPuyoPair()
-  }
-
-  getActivePuyo(): { x: number; y: number; color1: number; color2: number } | null {
-    return this.activePuyo
-  }
-
-  // 回転機能関連のメソッド
-  getActivePuyoDirection(): number {
-    return this.activePuyo?.direction ?? 0
   }
 
-  getActivePuyoPositions(): Array<{ x: number; y: number }> {
-    if (!this.activePuyo) return []
-    return this.getPuyoPositionsForTest({
-      x: this.activePuyo.x,
-      y: this.activePuyo.y,
-      direction: this.activePuyo.direction,
-    })
-  }
+  /**
+   * 落下処理の更新
+   */
+  private updateFalling(): void {
+    if (!this.puyo.hasActivePuyo()) return
 
-  isUpKeyPressed(): boolean {
-    return this.upKeyPressed
-  }
-
-  private getPuyoColor(colorNumber: number): string {
-    return Game.PUYO_COLOR_MAP[colorNumber] || '#CCCCCC'
-  }
+    this.fallTimer++
 
-  private drawPuyo(x: number, y: number, color: string): void {
-    // ぷよを楕円形で描画
-    const centerX = x + Game.CELL_SIZE / 2
-    const centerY = y + Game.CELL_SIZE / 2
-    const radiusX = (Game.CELL_SIZE - 4) / 2 // 若干小さくして見やすく
-    const radiusY = (Game.CELL_SIZE - 4) / 2
+    // 下キーが押されている場合は高速落下
+    const currentInterval = this.player.isDownKeyPressed() ? 3 : this.fallInterval
 
-    this.context.fillStyle = color
-    this.context.beginPath()
-    this.context.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI)
-    this.context.fill()
+    if (this.fallTimer >= currentInterval) {
+      this.fallTimer = 0
 
-    // 輪郭線を追加
-    this.context.strokeStyle = '#333333'
-    this.context.lineWidth = 1
-    this.context.stroke()
+      if (this.canFall()) {
+        this.puyo.updateActivePuyoPosition(0, this.fallSpeed)
+      } else {
+        // 着地処理
+        this.processLanding()
+      }
+    }
   }
 
-  renderActivePuyo(): void {
-    if (!this.activePuyo) return
-
-    const positions = this.getActivePuyoPositions()
-
-    // 1つ目のぷよ（中心ぷよ）を描画
-    const x1 = Game.FIELD_OFFSET_X + positions[0].x * Game.CELL_SIZE
-    const y1 = Game.FIELD_OFFSET_Y + positions[0].y * Game.CELL_SIZE
-    this.drawPuyo(x1, y1, this.getPuyoColor(this.activePuyo.color1))
-
-    // 2つ目のぷよを描画
-    if (positions.length > 1) {
-      const x2 = Game.FIELD_OFFSET_X + positions[1].x * Game.CELL_SIZE
-      const y2 = Game.FIELD_OFFSET_Y + positions[1].y * Game.CELL_SIZE
-      this.drawPuyo(x2, y2, this.getPuyoColor(this.activePuyo.color2))
-    }
+  /**
+   * 落下可能かチェック
+   */
+  private canFall(): boolean {
+    return this.puyo.canMoveTo(0, this.fallSpeed, (positions) =>
+      this.stage.arePositionsValid(positions)
+    )
   }
 
-  renderNextPuyo(): void {
-    const nextX = Game.FIELD_OFFSET_X + (Game.FIELD_WIDTH + 1) * Game.CELL_SIZE
-    const nextY = Game.FIELD_OFFSET_Y + Game.CELL_SIZE
+  /**
+   * 着地処理
+   */
+  private processLanding(): void {
+    const activePuyo = this.puyo.getActivePuyo()
+    if (!activePuyo) return
 
-    // 次のぷよ1を楕円形で描画
-    this.drawPuyo(nextX, nextY, this.getPuyoColor(this.nextPuyo.color1))
+    // アクティブぷよをフィールドに配置
+    const positions = this.puyo.getActivePuyoPositions()
+    this.stage.landActivePuyo(positions, activePuyo.color1, activePuyo.color2)
 
-    // 次のぷよ2を楕円形で描画（下に配置）
-    this.drawPuyo(nextX, nextY + Game.CELL_SIZE, this.getPuyoColor(this.nextPuyo.color2))
-  }
+    // アクティブぷよをクリア
+    this.puyo.clearActivePuyo()
 
-  updateFalling(): void {
-    if (!this.activePuyo) return
+    // まず重力処理を実行（浮いているぷよを落下）
+    this.stage.dropAfterElimination()
 
-    // 下キーが押されている場合は高速落下、そうでなければタイマーで制御
-    const shouldFall = this.downKeyPressed || this.shouldFallByTimer()
+    // 連鎖処理を実行
+    this.stage.processChainWithScore()
+    this.updateScoreDisplay()
 
-    if (shouldFall) {
-      this.performFallOrLanding()
-    }
+    // 次のぷよを生成
+    this.spawnActivePuyo()
   }
 
-  private shouldFallByTimer(): boolean {
-    this.fallTimer++
-    if (this.fallTimer >= this.fallInterval) {
-      this.fallTimer = 0
-      return true
+  /**
+   * 新しいアクティブぷよを生成
+   */
+  private spawnActivePuyo(): void {
+    const gameOverCallback = () => {
+      return this.stage.isGameOver((x, y, direction) =>
+        this.puyo.calculatePuyoPositions(x, y, direction)
+      )
     }
-    return false
-  }
-
-  private performFallOrLanding(): void {
-    if (!this.activePuyo) return
 
-    // 落下可能かチェック
-    if (this.canFall()) {
-      this.activePuyo.y += this.fallSpeed
+    const spawned = this.puyo.spawnActivePuyo(gameOverCallback)
+    
+    if (!spawned) {
+      // ゲームオーバー
+      this.stage.triggerGameOver()
+      this.gameState = 'gameover'
     } else {
-      // 着地処理を実行
-      this.processLanding()
+      this.gameState = 'playing'
     }
   }
 
-  private canFall(): boolean {
-    if (!this.activePuyo) return false
-
-    // 現在の操作ぷよの位置を取得
-    const positions = this.getActivePuyoPositions()
+  /**
+   * プレイヤー操作のコールバック設定
+   */
+  private setupPlayerCallbacks(): void {
+    // 左移動
+    this.player.onLeftKeyPress(() => {
+      if (this.puyo.canMoveTo(-1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.updateActivePuyoPosition(-1, 0)
+        this.player.handleMovement() // 移動成功時にタイマーをセット
+      }
+    })
 
-    // すべてのぷよの位置が底面に到達していないかチェック
-    for (const pos of positions) {
-      if (pos.y >= Game.FIELD_HEIGHT - 1) {
-        return false
+    // 右移動
+    this.player.onRightKeyPress(() => {
+      if (this.puyo.canMoveTo(1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.updateActivePuyoPosition(1, 0)
+        this.player.handleMovement() // 移動成功時にタイマーをセット
       }
-    }
+    })
 
-    // canMoveDown()と同じ衝突判定を使用
-    return this.canMoveDown()
+    // 回転
+    this.player.onUpKeyPress(() => {
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation() // 回転成功時にタイマーをセット
+      } else {
+        // 壁キック処理を試行
+        this.tryWallKick()
+      }
+    })
   }
 
-  getFallSpeed(): number {
-    return this.fallSpeed
-  }
+  /**
+   * 壁キック処理
+   */
+  private tryWallKick(): void {
+    const activePuyo = this.puyo.getActivePuyo()
+    if (!activePuyo) return
 
-  // プレイヤー入力の検出
-  handleKeyDown(event: KeyboardEvent): void {
-    // ゲームオーバー時のリスタート機能
-    if (this.isGameOverEffectActiveFlag && (event.key === 'r' || event.key === ' ')) {
-      this.restart()
-      return
+    // 左へのキック
+    if (this.puyo.canMoveTo(-1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+      this.puyo.updateActivePuyoPosition(-1, 0)
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation() // 回転成功時にタイマーをセット
+        return
+      }
+      // 戻す
+      this.puyo.updateActivePuyoPosition(1, 0)
     }
 
-    switch (event.key) {
-      case 'ArrowLeft':
-        this.leftKeyPressed = true
-        break
-      case 'ArrowRight':
-        this.rightKeyPressed = true
-        break
-      case 'ArrowUp':
-        this.upKeyPressed = true
-        break
-      case 'ArrowDown':
-        this.downKeyPressed = true
-        break
+    // 右へのキック
+    if (this.puyo.canMoveTo(1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+      this.puyo.updateActivePuyoPosition(1, 0)
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation() // 回転成功時にタイマーをセット
+        return
+      }
+      // 戻す
+      this.puyo.updateActivePuyoPosition(-1, 0)
     }
-  }
 
-  handleKeyUp(event: KeyboardEvent): void {
-    switch (event.key) {
-      case 'ArrowLeft':
-        this.leftKeyPressed = false
-        break
-      case 'ArrowRight':
-        this.rightKeyPressed = false
-        break
-      case 'ArrowUp':
-        this.upKeyPressed = false
-        break
-      case 'ArrowDown':
-        this.downKeyPressed = false
-        break
+    // 上へのキック
+    if (this.puyo.canMoveTo(0, -1, (positions) => this.stage.arePositionsValid(positions))) {
+      this.puyo.updateActivePuyoPosition(0, -1)
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation() // 回転成功時にタイマーをセット
+        return
+      }
+      // 戻す
+      this.puyo.updateActivePuyoPosition(0, 1)
     }
-  }
-
-  isLeftKeyPressed(): boolean {
-    return this.leftKeyPressed
-  }
 
-  isRightKeyPressed(): boolean {
-    return this.rightKeyPressed
-  }
-
-  isDownKeyPressed(): boolean {
-    return this.downKeyPressed
+    // 下へのキック
+    if (this.puyo.canMoveTo(0, 1, (positions) => this.stage.arePositionsValid(positions))) {
+      this.puyo.updateActivePuyoPosition(0, 1)
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation() // 回転成功時にタイマーをセット
+        return
+      }
+      // 戻す
+      this.puyo.updateActivePuyoPosition(0, -1)
+    }
   }
 
+  /**
+   * 入力ハンドラの設定
+   */
   setupInputHandlers(): void {
-    addEventListener('keydown', this.handleKeyDown.bind(this))
-    addEventListener('keyup', this.handleKeyUp.bind(this))
+    // プレイヤーにイベントリスナーを設定
+    this.player.setupKeyListeners(globalThis as any)
+
+    // リスタート用のキーハンドラ（R、スペース）
+    ;(globalThis as any).addEventListener('keydown', (event: KeyboardEvent) => {
+      if (this.gameState === 'gameover') {
+        if (event.code === 'KeyR' || event.code === 'Space') {
+          this.restart()
+        }
+      }
+    })
   }
 
-  resetInputState(): void {
-    this.leftKeyPressed = false
-    this.rightKeyPressed = false
-    this.upKeyPressed = false
-    this.downKeyPressed = false
+  /**
+   * スコア表示の更新
+   */
+  private updateScoreDisplay(): void {
+    this.scoreDisplay.textContent = `スコア: ${this.stage.getScore()}`
   }
 
-  updateMovement(): void {
-    if (!this.activePuyo) return
+  /**
+   * ゲームリスタート
+   */
+  restart(): void {
+    // ゲーム状態をリセット（ゲームオーバー判定に影響するため最初に実行）
+    this.gameState = 'playing'
 
-    // 左右のキーが同時に押されている場合は移動しない
-    if (this.leftKeyPressed && this.rightKeyPressed) {
-      return
-    }
+    // ステージをリセット
+    this.stage.resetScore()
+    this.stage.resetField()
+    this.stage.stopAllEffects()
 
-    // キーが押されている場合のみタイマーを進める
-    if (this.leftKeyPressed || this.rightKeyPressed) {
-      this.moveTimer++
+    // プレイヤーをリセット
+    this.player.reset()
 
-      if (this.moveTimer >= Game.MOVE_INTERVAL) {
-        this.moveTimer = 0
+    // 新しいぷよを生成
+    this.puyo = new Puyo()
+    this.spawnActivePuyo()
 
-        if (this.leftKeyPressed && this.canMoveLeft()) {
-          this.activePuyo.x -= 1
-        } else if (this.rightKeyPressed && this.canMoveRight()) {
-          this.activePuyo.x += 1
-        }
-      }
-    } else {
-      // キーが押されていないときはタイマーをリセット
-      this.moveTimer = 0
-    }
+    // 表示を更新
+    this.updateScoreDisplay()
   }
 
-  updateRotation(): void {
-    if (!this.activePuyo) return
+  // テスト用メソッド群
+  getScore(): number {
+    return this.stage.getScore()
+  }
 
-    // 上キーが押されている場合のみタイマーを進める
-    if (this.upKeyPressed) {
-      this.rotationTimer++
+  addScore(points: number): void {
+    this.stage.addScore(points)
+    this.updateScoreDisplay()
+  }
 
-      if (this.rotationTimer >= Game.ROTATION_INTERVAL) {
-        this.rotationTimer = 0
+  getField(): number[][] {
+    return this.stage.getField()
+  }
 
-        // 回転可能かチェックしてから回転処理を実行
-        if (this.canRotate()) {
-          this.activePuyo.direction = (this.activePuyo.direction + 1) % 4
-        } else {
-          // 壁キック処理を試行
-          this.tryWallKick()
-        }
-      }
-    } else {
-      // キーが押されていないときはタイマーをリセット
-      this.rotationTimer = 0
-    }
+  getActivePuyo(): { x: number; y: number; color1: number; color2: number; direction: number } | null {
+    return this.puyo.getActivePuyo()
   }
 
-  // テスト用のメソッド：即座に回転する
-  rotateActivePuyo(): void {
-    if (!this.activePuyo) return
-    this.activePuyo.direction = (this.activePuyo.direction + 1) % 4
+  getNextPuyo(): { color1: number; color2: number } {
+    return this.puyo.getNextPuyo()
   }
 
-  // 回転可能かどうかをチェックする
-  canRotate(): boolean {
-    if (!this.activePuyo) return false
+  getActivePuyoDirection(): number {
+    return this.puyo.getActivePuyoDirection()
+  }
 
-    // 回転後の方向を計算（時計回りに90度回転）
-    const nextDirection = (this.activePuyo.direction + 1) % 4
+  getActivePuyoPositions(): Array<{ x: number; y: number }> {
+    return this.puyo.getActivePuyoPositions()
+  }
 
-    // 回転後の位置を仮想的に計算
-    const testPuyo = {
-      x: this.activePuyo.x,
-      y: this.activePuyo.y,
-      direction: nextDirection,
-    }
+  isZenkeshiEffectActive(): boolean {
+    return this.stage.isZenkeshiEffectActive()
+  }
 
-    const positions = this.getPuyoPositionsForTest(testPuyo)
+  isGameOverEffectActive(): boolean {
+    return this.stage.isGameOverEffectActive()
+  }
 
-    // すべての位置が有効（空き）かどうかチェック
-    for (const pos of positions) {
-      // フィールドの境界チェック
-      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
-        return false
-      }
+  isGameOver(): boolean {
+    return this.stage.isGameOver((x, y, direction) =>
+      this.puyo.calculatePuyoPositions(x, y, direction)
+    )
+  }
 
-      // フィールドの占有チェック（他のぷよと衝突しないか）
-      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
-        return false
-      }
-    }
+  triggerGameOver(): void {
+    this.stage.triggerGameOver()
+    this.gameState = 'gameover'
+  }
 
-    return true
+  isDownKeyPressed(): boolean {
+    return this.player.isDownKeyPressed()
   }
 
-  // テスト用のメソッド：落下を無効にする
+  // 既存のテストとの互換性のためのメソッド群
   disableFalling(): void {
     this.fallInterval = 99999 // 非常に大きな値にして実質的に無効化
   }
 
-  // テスト用のメソッド：落下間隔を設定する
   setFallInterval(interval: number): void {
     this.fallInterval = interval
   }
 
   clearActivePuyo(): void {
-    this.activePuyo = null
+    this.puyo.clearActivePuyo()
+  }
+
+  rotateActivePuyo(): void {
+    this.puyo.rotateActivePuyo()
   }
 
   canMoveLeft(): boolean {
-    return this.canMoveToPosition(-1)
+    return this.puyo.canMoveTo(-1, 0, (positions) => this.stage.arePositionsValid(positions))
   }
 
   canMoveRight(): boolean {
-    return this.canMoveToPosition(1)
+    return this.puyo.canMoveTo(1, 0, (positions) => this.stage.arePositionsValid(positions))
   }
 
   canMoveDown(): boolean {
-    if (!this.activePuyo) return false
-
-    const targetX = this.activePuyo.x
-    const targetY = this.activePuyo.y + 1
-
-    // 移動後の位置をチェック
-    return this.isPuyoPositionEmpty(targetX, targetY)
+    return this.puyo.canMoveTo(0, 1, (positions) => this.stage.arePositionsValid(positions))
   }
 
-  private canMoveToPosition(deltaX: number): boolean {
-    if (!this.activePuyo) return false
-
-    const targetX = this.activePuyo.x + deltaX
-    const targetY = this.activePuyo.y
-
-    // フィールドの境界チェック
-    if (targetX < 0 || targetX >= Game.FIELD_WIDTH) {
-      return false
-    }
-
-    // 他のぷよとの衝突チェック
-    return this.isPuyoPositionEmpty(targetX, targetY)
+  clearScreen(): void {
+    this.puyoImage.clearCanvas()
   }
 
-  private isPuyoPositionEmpty(x: number, y: number): boolean {
-    if (!this.activePuyo) return false
-
-    // 現在の操作ぷよの位置情報を取得
-    const testPuyo = { x, y, direction: this.activePuyo.direction }
-    const positions = this.getPuyoPositionsForTest(testPuyo)
-
-    // すべての位置が空かどうかチェック
-    for (const pos of positions) {
-      // フィールドの境界チェック
-      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
-        return false
-      }
-
-      // フィールドの占有チェック
-      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
-        return false
-      }
-    }
-
-    return true
+  renderField(): void {
+    this.puyoImage.renderField(this.stage.getField())
   }
 
-  private getPuyoPositionsForTest(testPuyo: {
-    x: number
-    y: number
-    direction: number
-  }): Array<{ x: number; y: number }> {
-    const centerX = testPuyo.x
-    const centerY = testPuyo.y
-    const direction = testPuyo.direction
-
-    const positions = [{ x: centerX, y: centerY }] // 中心ぷよの位置
-
-    // 方向に基づいて2つ目のぷよの位置を決定
-    switch (direction) {
-      case 0: // 縦配置、下向き
-        positions.push({ x: centerX, y: centerY + 1 })
-        break
-      case 1: // 横配置、右向き
-        positions.push({ x: centerX + 1, y: centerY })
-        break
-      case 2: // 縦配置、上向き
-        positions.push({ x: centerX, y: centerY - 1 })
-        break
-      case 3: // 横配置、左向き
-        positions.push({ x: centerX - 1, y: centerY })
-        break
+  renderActivePuyo(): void {
+    const activePuyo = this.puyo.getActivePuyo()
+    if (activePuyo) {
+      this.puyoImage.renderActivePuyo(activePuyo)
     }
+  }
 
-    return positions
+  renderNextPuyo(): void {
+    this.puyoImage.renderNextPuyo(this.puyo.getNextPuyo())
   }
 
   landActivePuyo(): void {
-    if (!this.activePuyo) return
+    const activePuyo = this.puyo.getActivePuyo()
+    if (!activePuyo) return
 
-    const positions = this.getActivePuyoPositions()
-
-    // 操作ぷよをフィールドに固定
-    if (positions.length >= 2) {
-      this.field[positions[0].y][positions[0].x] = this.activePuyo.color1
-      this.field[positions[1].y][positions[1].x] = this.activePuyo.color2
-    }
-
-    // 操作ぷよをクリア
-    this.activePuyo = null
+    const positions = this.puyo.getActivePuyoPositions()
+    this.stage.landActivePuyo(positions, activePuyo.color1, activePuyo.color2)
+    this.puyo.clearActivePuyo()
   }
 
-  // 壁キック処理を試行する
-  tryWallKick(): void {
-    if (!this.activePuyo) return
-
-    const nextDirection = (this.activePuyo.direction + 1) % 4
-    const kickOffsets = [
-      { x: -1, y: 0 }, // 左にキック
-      { x: 1, y: 0 }, // 右にキック
-      { x: 0, y: -1 }, // 上にキック
-      { x: 0, y: 1 }, // 下にキック
-    ]
+  // テストとの互換性のための追加メソッド群
+  isGameRunning(): boolean {
+    return this.isRunning
+  }
 
-    // 各方向のキックを試行
-    for (const offset of kickOffsets) {
-      const testPuyo = {
-        x: this.activePuyo.x + offset.x,
-        y: this.activePuyo.y + offset.y,
-        direction: nextDirection,
-      }
+  getGameState(): string {
+    return this.gameState
+  }
 
-      // キック後の位置で回転可能かチェック
-      if (this.canRotateAt(testPuyo)) {
-        // 回転を実行
-        this.activePuyo.x = testPuyo.x
-        this.activePuyo.y = testPuyo.y
-        this.activePuyo.direction = nextDirection
-        return
-      }
-    }
+  generateNewPuyoPair(): { color1: number; color2: number } {
+    return this.puyo.generateNewPuyoPair()
   }
 
-  // 指定した位置で回転可能かどうかをチェックする
-  private canRotateAt(testPuyo: { x: number; y: number; direction: number }): boolean {
-    const positions = this.getPuyoPositionsForTest(testPuyo)
 
-    // すべての位置が有効（空き）かどうかチェック
-    for (const pos of positions) {
-      // フィールドの境界チェック
-      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
-        return false
+  updateMovement(): void {
+    if (!this.puyo.hasActivePuyo()) return
+    
+    // 移動可能な場合のみ処理
+    if (this.player.canMove()) {
+      const isLeftPressed = this.player.isLeftKeyPressed()
+      const isRightPressed = this.player.isRightKeyPressed()
+      
+      // 左右キーが同時に押されている場合は移動しない
+      if (isLeftPressed && isRightPressed) {
+        return
       }
-
-      // フィールドの占有チェック（他のぷよと衝突しないか）
-      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
-        return false
+      
+      if (isLeftPressed) {
+        if (this.puyo.canMoveTo(-1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+          this.puyo.updateActivePuyoPosition(-1, 0)
+          this.player.handleMovement()
+        }
+      } else if (isRightPressed) {
+        if (this.puyo.canMoveTo(1, 0, (positions) => this.stage.arePositionsValid(positions))) {
+          this.puyo.updateActivePuyoPosition(1, 0)
+          this.player.handleMovement()
+        }
       }
     }
-
-    return true
   }
 
-  processLanding(): void {
-    if (!this.activePuyo) return
-
-    // 着地処理
-    this.landActivePuyo()
-
-    // 常時重力処理を実行（消去の有無に関係なく、浮いているぷよを落下させる）
-    this.dropAfterElimination()
-
-    // 連鎖処理を実行
-    this.processChainWithScore()
-
-    // 新しい操作ぷよを生成
-    this.spawnActivePuyo()
-  }
-
-  // テスト用メソッド: 落下可能かどうかをチェック
-  canFallTest(): boolean {
-    return this.canFall()
-  }
-
-  // テスト用メソッド: 着地しているかどうかをチェック
-  hasLandedTest(): boolean {
-    return !this.canFall()
-  }
-
-  // ぷよの接続判定: 指定した位置から同じ色で接続されたぷよをすべて検出
-  findConnectedPuyos(startX: number, startY: number): Array<{ x: number; y: number }> {
-    const connected: Array<{ x: number; y: number }> = []
-    const visited: boolean[][] = Array(Game.FIELD_HEIGHT)
-      .fill(null)
-      .map(() => Array(Game.FIELD_WIDTH).fill(false))
-
-    const targetColor = this.field[startY][startX]
-    if (targetColor === 0) {
-      return connected // 空のセルからは何も返さない
+  updateRotation(): void {
+    if (!this.puyo.hasActivePuyo()) return
+    
+    // 回転可能な場合のみ処理
+    if (this.player.canRotate() && this.player.isUpKeyPressed()) {
+      if (this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))) {
+        this.puyo.rotateActivePuyo()
+        this.player.handleRotation()
+      } else {
+        // 壁キック処理を試行
+        this.tryWallKick()
+        this.player.handleRotation()
+      }
     }
-
-    // 深度優先探索で接続されたぷよを検出
-    this.dfsConnectedPuyos(startX, startY, targetColor, visited, connected)
-
-    return connected
   }
 
-  // 深度優先探索で同じ色のぷよを再帰的に検出
-  private dfsConnectedPuyos(
-    x: number,
-    y: number,
-    targetColor: number,
-    visited: boolean[][],
-    connected: Array<{ x: number; y: number }>
-  ): void {
-    // 境界チェック
-    if (x < 0 || x >= Game.FIELD_WIDTH || y < 0 || y >= Game.FIELD_HEIGHT) {
-      return
-    }
-
-    // 既に訪問済みかチェック
-    if (visited[y][x]) {
-      return
-    }
-
-    // 色が一致しないかチェック
-    if (this.field[y][x] !== targetColor) {
-      return
-    }
-
-    // 訪問済みにマーク
-    visited[y][x] = true
-
-    // 接続リストに追加
-    connected.push({ x, y })
-
-    // 4方向に再帰的に探索
-    this.dfsConnectedPuyos(x + 1, y, targetColor, visited, connected) // 右
-    this.dfsConnectedPuyos(x - 1, y, targetColor, visited, connected) // 左
-    this.dfsConnectedPuyos(x, y + 1, targetColor, visited, connected) // 下
-    this.dfsConnectedPuyos(x, y - 1, targetColor, visited, connected) // 上
+  canRotate(): boolean {
+    return this.puyo.canRotate((positions) => this.stage.arePositionsValid(positions))
   }
 
-  // 4つ以上つながったぷよのグループを検出
-  findEliminateGroups(): Array<Array<{ x: number; y: number }>> {
-    const eliminateGroups: Array<Array<{ x: number; y: number }>> = []
-    const visited: boolean[][] = Array(Game.FIELD_HEIGHT)
-      .fill(null)
-      .map(() => Array(Game.FIELD_WIDTH).fill(false))
-
-    // フィールド全体をスキャンして4つ以上の接続グループを検出
-    for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
-      for (let x = 0; x < Game.FIELD_WIDTH; x++) {
-        // 空でない、かつまだ訪問していないセルから開始
-        if (this.field[y][x] !== 0 && !visited[y][x]) {
-          const connectedPuyos = this.findConnectedPuyos(x, y)
-
-          // 4つ以上のグループは消去対象
-          if (connectedPuyos.length >= 4) {
-            eliminateGroups.push(connectedPuyos)
-          }
-
-          // 訪問済みにマーク（重複検出を避ける）
-          for (const puyo of connectedPuyos) {
-            visited[puyo.y][puyo.x] = true
-          }
-        }
+  handleKeyDown(event: KeyboardEvent): void {
+    // ゲームオーバー時のリスタート処理
+    if (this.gameState === 'gameover') {
+      if (event.key === 'r' || event.key === 'R' || event.key === ' ') {
+        this.restart()
+        return
       }
     }
 
-    return eliminateGroups
-  }
-
-  // ぷよの消去処理: 4つ以上つながったぷよを実際に消去する
-  eliminatePuyos(): Array<Array<{ x: number; y: number }>> {
-    // 消去対象のグループを検出
-    const eliminateGroups = this.findEliminateGroups()
-
-    // 検出された各グループのぷよを消去（フィールドから0にする）
-    for (const group of eliminateGroups) {
-      for (const puyo of group) {
-        this.field[puyo.y][puyo.x] = 0
+    // keyCodeが設定されていない場合は、keyから推測
+    let keyCode = event.keyCode
+    if (!keyCode) {
+      switch (event.key) {
+        case 'ArrowLeft':
+          keyCode = 37
+          break
+        case 'ArrowUp':
+          keyCode = 38
+          break
+        case 'ArrowRight':
+          keyCode = 39
+          break
+        case 'ArrowDown':
+          keyCode = 40
+          break
+        default:
+          keyCode = 0
       }
     }
-
-    return eliminateGroups
+    this.player.handleKeyDown(keyCode)
   }
 
-  // 消去後の落下処理: 空いたスペースに上のぷよを落下させる
-  // 注意: このメソッドは eliminatePuyos() が実際に消去を行った後でのみ使用すべき
-  dropAfterElimination(): boolean {
-    let hasDropped = false
-
-    // 各列ごとに処理
-    for (let x = 0; x < Game.FIELD_WIDTH; x++) {
-      // 空でないぷよを上から下の順で収集
-      const column: number[] = []
-
-      // 列全体を上から下にスキャンして、空でないぷよを収集
-      for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
-        if (this.field[y][x] !== 0) {
-          column.push(this.field[y][x])
-        }
-      }
-
-      // 下から連続して配置されているかチェック
-      let needsReorder = false
-      for (let i = 0; i < column.length; i++) {
-        const expectedY = Game.FIELD_HEIGHT - 1 - i
-        const expectedValue = column[column.length - 1 - i]
-        if (this.field[expectedY][x] !== expectedValue) {
-          needsReorder = true
+  handleKeyUp(event: KeyboardEvent): void {
+    // keyCodeが設定されていない場合は、keyから推測
+    let keyCode = event.keyCode
+    if (!keyCode) {
+      switch (event.key) {
+        case 'ArrowLeft':
+          keyCode = 37
           break
-        }
-      }
-
-      // 再配置が必要な場合のみ処理
-      if (needsReorder) {
-        hasDropped = true
-        // 列全体をクリア
-        for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
-          this.field[y][x] = 0
-        }
-
-        // 収集したぷよを下から配置（落下順序を正しく保つため、columnの逆順で配置）
-        for (let i = 0; i < column.length; i++) {
-          const targetY = Game.FIELD_HEIGHT - 1 - i
-          this.field[targetY][x] = column[column.length - 1 - i]
-        }
+        case 'ArrowUp':
+          keyCode = 38
+          break
+        case 'ArrowRight':
+          keyCode = 39
+          break
+        case 'ArrowDown':
+          keyCode = 40
+          break
+        default:
+          keyCode = 0
       }
     }
-
-    return hasDropped
+    this.player.handleKeyUp(keyCode)
   }
 
-  // 消去処理と落下処理を統合したメソッド
-  eliminateAndDrop(): { eliminated: Array<Array<{ x: number; y: number }>>; dropped: boolean } {
-    const eliminatedGroups = this.eliminatePuyos()
-    const dropped = eliminatedGroups.length > 0 ? this.dropAfterElimination() : false
-
-    return {
-      eliminated: eliminatedGroups,
-      dropped: dropped,
-    }
+  getFallSpeed(): number {
+    return this.fallSpeed
   }
 
-  // 連鎖処理を実行するメソッド
-  processChain(): { chains: number; totalEliminated: number } {
-    let chainCount = 0
-    let totalEliminated = 0
-
-    // 連鎖が続く限り繰り返し処理
-    while (true) {
-      // 消去処理を実行
-      const eliminatedGroups = this.eliminatePuyos()
-
-      // 消去対象がない場合は連鎖終了
-      if (eliminatedGroups.length === 0) {
-        break
-      }
-
-      // 連鎖カウントと消去数を更新
-      chainCount++
-      for (const group of eliminatedGroups) {
-        totalEliminated += group.length
-      }
-
-      // 落下処理を実行
-      this.dropAfterElimination()
-
-      // 連鎖の無限ループを防ぐため、最大10回まで
-      if (chainCount >= 10) {
-        break
-      }
-    }
-
-    return {
-      chains: chainCount,
-      totalEliminated: totalEliminated,
-    }
+  setFallSpeed(speed: number): void {
+    this.fallSpeed = speed
   }
 
-  // スコア計算のボーナステーブル（テストケースに合わせて調整）
-  private static readonly CHAIN_BONUS = [
-    0, 8, 16, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512,
-  ]
-
-  private static readonly PIECE_BONUS = [0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6]
-
-  private static readonly COLOR_BONUS = [0, 0, 4, 8, 8]
-
-  // 全消しボーナススコア
-  private static readonly ZENKESHI_BONUS = 3600
-
-  // 全消し演出管理
-  private isZenkeshiEffectActiveFlag = false
-
-  // ゲームオーバー演出管理
-  private isGameOverEffectActiveFlag = false
-
-  // 連鎖スコアを計算するメソッド
-  calculateScore(chainNumber: number, piecesEliminated: number, colors: number): number {
-    const chainBonus = Game.CHAIN_BONUS[Math.min(chainNumber, Game.CHAIN_BONUS.length - 1)]
-    const pieceBonus = Game.PIECE_BONUS[Math.min(piecesEliminated, Game.PIECE_BONUS.length - 1)]
-    const colorBonus = Game.COLOR_BONUS[Math.min(colors, Game.COLOR_BONUS.length - 1)]
-
-    const scale = chainBonus + pieceBonus + colorBonus
-    return piecesEliminated * 10 * scale
+  getFallInterval(): number {
+    return this.fallInterval
   }
 
-  // 連鎖処理とスコア計算を統合したメソッド
-  processChainWithScore(): { chains: number; totalScore: number; totalEliminated: number } {
-    let chainCount = 0
-    let totalScore = 0
-    let totalEliminated = 0
-
-    // 連鎖が続く限り繰り返し処理
-    while (true) {
-      // 消去処理を実行
-      const eliminatedGroups = this.eliminatePuyos()
-
-      // 消去対象がない場合は連鎖終了
-      if (eliminatedGroups.length === 0) {
-        break
-      }
-
-      // 連鎖カウントを更新
-      chainCount++
-
-      // 各グループのスコアを計算
-      let chainEliminated = 0
-      const colors = eliminatedGroups.length // 消去されたグループ数 = 色数
-
-      for (const group of eliminatedGroups) {
-        chainEliminated += group.length
-      }
-
-      totalEliminated += chainEliminated
-
-      // この連鎖のスコアを計算して加算
-      const chainScore = this.calculateScore(chainCount, chainEliminated, colors)
-      totalScore += chainScore
-
-      // 落下処理を実行
-      this.dropAfterElimination()
-
-      // 連鎖の無限ループを防ぐため、最大10回まで
-      if (chainCount >= 10) {
-        break
-      }
-    }
-
-    // 全消しボーナスの判定と加算
-    let zenkeshiBonus = 0
-    if (chainCount > 0 && this.isZenkeshi()) {
-      zenkeshiBonus = Game.ZENKESHI_BONUS
-      totalScore += zenkeshiBonus
-      // 全消し演出を開始
-      this.startZenkeshiEffect()
-    }
-
-    // ゲームのスコアに加算
-    this.score += totalScore
-    this.updateScoreDisplay()
-
-    return {
-      chains: chainCount,
-      totalScore: totalScore,
-      totalEliminated: totalEliminated,
-    }
+  isLeftKeyPressed(): boolean {
+    return this.player.isLeftKeyPressed()
   }
 
-  // 全消し判定: 盤面上にぷよが残っていないかをチェック
-  isZenkeshi(): boolean {
-    // フィールド全体をスキャンして、空でないセルがあるかチェック
-    for (let y = 0; y < Game.FIELD_HEIGHT; y++) {
-      for (let x = 0; x < Game.FIELD_WIDTH; x++) {
-        if (this.field[y][x] !== 0) {
-          return false // ぷよが残っている場合は全消しではない
-        }
-      }
-    }
-    return true // すべてのセルが空の場合は全消し
+  isRightKeyPressed(): boolean {
+    return this.player.isRightKeyPressed()
   }
 
-  // 全消しボーナス値を取得
-  getZenkeshiBonus(): number {
-    return Game.ZENKESHI_BONUS
+  isUpKeyPressed(): boolean {
+    return this.player.isUpKeyPressed()
   }
 
-  // 全消し演出が有効かどうかを取得
-  isZenkeshiEffectActive(): boolean {
-    return this.isZenkeshiEffectActiveFlag
+  resetInputState(): void {
+    this.player.reset()
   }
 
-  // 全消し演出を開始
-  private startZenkeshiEffect(): void {
-    this.isZenkeshiEffectActiveFlag = true
+  canFallTest(): boolean {
+    return this.canFall()
   }
 
-  // 全消し演出を停止
-  // @ts-expect-error - 将来の演出停止機能で使用予定
-
-  private stopZenkeshiEffect(): void {
-    this.isZenkeshiEffectActiveFlag = false
+  hasLandedTest(): boolean {
+    return !this.canFall()
   }
 
-  // 全消し演出の描画
-  private renderZenkeshiEffect(): void {
-    if (!this.isZenkeshiEffectActiveFlag) return
-
-    // 画面中央に「全消し！」テキストを描画
-    const centerX = this.canvas.width / 2
-    const centerY = this.canvas.height / 2
-
-    this.context.save()
-    this.context.fillStyle = '#FFD700' // 金色
-    this.context.font = 'bold 48px Arial'
-    this.context.textAlign = 'center'
-    this.context.textBaseline = 'middle'
+  isPuyoPositionEmpty(x: number, y: number): boolean {
+    const activePuyo = this.puyo.getActivePuyo()
+    if (!activePuyo) return false
 
-    // 影効果を追加
-    this.context.fillStyle = '#000000'
-    this.context.fillText('全消し！', centerX + 2, centerY + 2)
-
-    // メインテキスト
-    this.context.fillStyle = '#FFD700'
-    this.context.fillText('全消し！', centerX, centerY)
-
-    this.context.restore()
+    const positions = this.puyo.calculatePuyoPositions(x, y, activePuyo.direction)
+    return this.stage.arePositionsValid(positions)
   }
 
-  // ゲームオーバー判定: 新しいぷよを配置できない状態を検出
-  isGameOver(): boolean {
-    // 新しいぷよのデフォルト配置位置（x=2, y=0）をチェック
-    const spawnX = 2
-    const spawnY = 0
-    const spawnDirection = 0 // デフォルトの縦配置
-
-    // テスト ぷよオブジェクトを作成
-    const testPuyo = {
-      x: spawnX,
-      y: spawnY,
-      direction: spawnDirection,
-    }
-
-    // 新しいぷよの2つの位置を取得
-    const positions = this.getPuyoPositionsForTest(testPuyo)
-
-    // すべての位置が空かどうかチェック
-    for (const pos of positions) {
-      // フィールドの境界チェック
-      if (pos.x < 0 || pos.x >= Game.FIELD_WIDTH || pos.y < 0 || pos.y >= Game.FIELD_HEIGHT) {
-        return true // 境界外なのでゲームオーバー
-      }
-
-      // フィールドの占有チェック
-      if (this.field[pos.y] && this.field[pos.y][pos.x] !== 0) {
-        return true // 既に占有されているのでゲームオーバー
-      }
-    }
-
-    return false // 配置可能なのでゲームオーバーではない
+  getPuyoPositionsForTest(testPuyo: {
+    x: number
+    y: number
+    direction: number
+  }): Array<{ x: number; y: number }> {
+    return this.puyo.calculatePuyoPositions(testPuyo.x, testPuyo.y, testPuyo.direction)
   }
 
-  // ゲームオーバー演出が有効かどうかを取得
-  isGameOverEffectActive(): boolean {
-    return this.isGameOverEffectActiveFlag
+  // Stage クラスへの委譲メソッド群
+  eliminatePuyos(): Array<Array<{ x: number; y: number }>> {
+    return this.stage.eliminatePuyos()
   }
 
-  // ゲームオーバー演出を開始
-  triggerGameOver(): void {
-    this.isGameOverEffectActiveFlag = true
+  dropAfterElimination(): boolean {
+    return this.stage.dropAfterElimination()
   }
 
-  // ゲームオーバー演出を停止
-  // @ts-expect-error - 将来のリスタート機能で使用予定
-
-  private stopGameOverEffect(): void {
-    this.isGameOverEffectActiveFlag = false
+  eliminateAndDrop(): { eliminated: Array<Array<{ x: number; y: number }>>; dropped: boolean } {
+    return this.stage.eliminateAndDrop()
   }
 
-  // ゲームオーバー演出の描画
-  private renderGameOverEffect(): void {
-    if (!this.isGameOverEffectActiveFlag) return
-
-    // 画面中央に「GAME OVER」テキストを描画
-    const centerX = this.canvas.width / 2
-    const centerY = this.canvas.height / 2
-
-    this.context.save()
-    this.context.fillStyle = '#FF0000' // 赤色
-    this.context.font = 'bold 36px Arial'
-    this.context.textAlign = 'center'
-    this.context.textBaseline = 'middle'
-
-    // 影効果を追加
-    this.context.fillStyle = '#000000'
-    this.context.fillText('GAME OVER', centerX + 2, centerY + 2)
-
-    // メインテキスト
-    this.context.fillStyle = '#FF0000'
-    this.context.fillText('GAME OVER', centerX, centerY)
+  findConnectedPuyos(x: number, y: number): Array<{ x: number; y: number }> {
+    return this.stage.findConnectedPuyos(x, y)
+  }
 
-    // リスタート案内メッセージを追加
-    this.context.font = 'bold 18px Arial'
-    const restartY = centerY + 60
+  findEliminateGroups(): Array<Array<{ x: number; y: number }>> {
+    return this.stage.findEliminateGroups()
+  }
 
-    // 影効果を追加
-    this.context.fillStyle = '#000000'
-    this.context.fillText('Rキーまたはスペースキーでリスタート', centerX + 1, restartY + 1)
+  processChain(): { chains: number; totalEliminated: number } {
+    return this.stage.processChain()
+  }
 
-    // メインテキスト
-    this.context.fillStyle = '#FFFFFF' // 白色
-    this.context.fillText('Rキーまたはスペースキーでリスタート', centerX, restartY)
+  processChainWithScore(): {
+    chains: number
+    totalScore: number
+    totalEliminated: number
+  } {
+    const result = this.stage.processChainWithScore()
+    this.updateScoreDisplay()
+    return result
+  }
 
-    this.context.restore()
+  calculateScore(chainCount: number, eliminatedCount: number, colors: number): number {
+    return this.stage.calculateScore(chainCount, eliminatedCount, colors)
   }
 
-  // スコアを追加（テスト用）
-  addScore(points: number): void {
-    this.score += points
-    this.updateScoreDisplay()
+  isZenkeshi(): boolean {
+    return this.stage.isZenkeshi()
   }
 
-  // ゲームをリスタート
-  restart(): void {
-    // スコアをリセット
-    this.score = 0
+  getZenkeshiBonus(): number {
+    return this.stage.getZenkeshiBonus()
+  }
 
-    // フィールドをクリア
-    this.field = Array(Game.FIELD_HEIGHT)
-      .fill(null)
-      .map(() => Array(Game.FIELD_WIDTH).fill(0))
+  stopZenkeshiEffect(): void {
+    this.stage.stopZenkeshiEffect()
+  }
 
-    // 演出フラグをリセット
-    this.isGameOverEffectActiveFlag = false
-    this.isZenkeshiEffectActiveFlag = false
+  stopGameOverEffect(): void {
+    this.stage.stopGameOverEffect()
+  }
 
-    // 新しいぷよを生成
-    this.nextPuyo = this.generateNewPuyoPair()
-    this.spawnActivePuyo()
+  // 定数の取得（テスト互換性）
+  static get ZENKESHI_BONUS(): number {
+    return 3600
+  }
 
-    // スコア表示を更新
-    this.updateScoreDisplay()
+  // テスト用メソッド: 全消し演出フラグを直接設定
+  setZenkeshiEffectActive(active: boolean): void {
+    if (active) {
+      // StageクラスのstartZenkeshiEffect()メソッドを呼び出すためのハック
+      ;(this.stage as any).isZenkeshiEffectActiveFlag = true
+    } else {
+      this.stage.stopZenkeshiEffect()
+    }
   }
-}
+}
\ No newline at end of file
diff --git a/app/src/player.ts b/app/src/player.ts
index ccdaebc..b51dcd3 100644
--- a/app/src/player.ts
+++ b/app/src/player.ts
@@ -19,8 +19,11 @@ export class Player {
   private static readonly ROTATION_COOLDOWN = 15
   private static readonly MOVEMENT_COOLDOWN = 8
 
-  // 下キー押下状態
+  // キー押下状態
   private isDownPressed = false
+  private isLeftPressed = false
+  private isRightPressed = false
+  private isUpPressed = false
 
   // 操作タイマー
   private rotationTimer = 0
@@ -47,21 +50,24 @@ export class Player {
   handleKeyDown(keyCode: number): void {
     switch (keyCode) {
       case Player.KEY_LEFT:
-        if (this.canMove()) {
-          this.leftKeyCallbacks.forEach((callback) => callback())
-          this.handleMovement()
+        if (!this.isLeftPressed) {
+          this.isLeftPressed = true
+          // コールバックを実行（タイマーセットは実際に移動した時に行う）
+          this.leftKeyCallbacks.forEach(callback => callback())
         }
         break
       case Player.KEY_RIGHT:
-        if (this.canMove()) {
-          this.rightKeyCallbacks.forEach((callback) => callback())
-          this.handleMovement()
+        if (!this.isRightPressed) {
+          this.isRightPressed = true
+          // コールバックを実行（タイマーセットは実際に移動した時に行う）
+          this.rightKeyCallbacks.forEach(callback => callback())
         }
         break
       case Player.KEY_UP:
-        if (this.canRotate()) {
-          this.upKeyCallbacks.forEach((callback) => callback())
-          this.handleRotation()
+        if (!this.isUpPressed) {
+          this.isUpPressed = true
+          // コールバックを実行（タイマーセットは実際に回転した時に行う）
+          this.upKeyCallbacks.forEach(callback => callback())
         }
         break
       case Player.KEY_DOWN:
@@ -75,12 +81,42 @@ export class Player {
    */
   handleKeyUp(keyCode: number): void {
     switch (keyCode) {
+      case Player.KEY_LEFT:
+        this.isLeftPressed = false
+        break
+      case Player.KEY_RIGHT:
+        this.isRightPressed = false
+        break
+      case Player.KEY_UP:
+        this.isUpPressed = false
+        break
       case Player.KEY_DOWN:
         this.isDownPressed = false
         break
     }
   }
 
+  /**
+   * 左キーが押されているかどうかを取得
+   */
+  isLeftKeyPressed(): boolean {
+    return this.isLeftPressed
+  }
+
+  /**
+   * 右キーが押されているかどうかを取得
+   */
+  isRightKeyPressed(): boolean {
+    return this.isRightPressed
+  }
+
+  /**
+   * 上キーが押されているかどうかを取得
+   */
+  isUpKeyPressed(): boolean {
+    return this.isUpPressed
+  }
+
   /**
    * 下キーが押されているかどうかを取得
    */
@@ -113,6 +149,7 @@ export class Player {
    * 移動操作が行われた時の処理
    */
   handleMovement(): void {
+    // 移動後は再度クールダウンタイマーをセット
     this.movementTimer = Player.MOVEMENT_COOLDOWN
   }
 
@@ -168,6 +205,9 @@ export class Player {
    */
   reset(): void {
     this.isDownPressed = false
+    this.isLeftPressed = false
+    this.isRightPressed = false
+    this.isUpPressed = false
     this.rotationTimer = 0
     this.movementTimer = 0
     // コールバックはリセットしない（再設定が必要になるため）
diff --git a/app/src/puyo.ts b/app/src/puyo.ts
index c914ced..2285585 100644
--- a/app/src/puyo.ts
+++ b/app/src/puyo.ts
@@ -62,7 +62,7 @@ export class Puyo {
   /**
    * アクティブぷよの状態を取得する
    */
-  getActivePuyo(): { x: number; y: number; color1: number; color2: number } | null {
+  getActivePuyo(): { x: number; y: number; color1: number; color2: number; direction: number } | null {
     return this.activePuyo
   }
 
diff --git a/app/src/puyoimage.ts b/app/src/puyoimage.ts
index d151f01..a0bbf95 100644
--- a/app/src/puyoimage.ts
+++ b/app/src/puyoimage.ts
@@ -48,6 +48,26 @@ export class PuyoImage {
    * ゲームフィールドを描画する
    */
   renderField(field: number[][]): void {
+    // フィールドの背景を描画
+    this.context.fillStyle = '#333333'
+    this.context.fillRect(
+      PuyoImage.FIELD_OFFSET_X,
+      PuyoImage.FIELD_OFFSET_Y,
+      field[0].length * PuyoImage.CELL_SIZE,
+      field.length * PuyoImage.CELL_SIZE
+    )
+
+    // フィールドの枠線を描画
+    this.context.strokeStyle = '#FFFFFF'
+    this.context.lineWidth = 2
+    this.context.strokeRect(
+      PuyoImage.FIELD_OFFSET_X,
+      PuyoImage.FIELD_OFFSET_Y,
+      field[0].length * PuyoImage.CELL_SIZE,
+      field.length * PuyoImage.CELL_SIZE
+    )
+
+    // ぷよを描画
     for (let y = 0; y < field.length; y++) {
       for (let x = 0; x < field[y].length; x++) {
         const puyoColor = field[y][x]
diff --git a/app/src/stage.ts b/app/src/stage.ts
index 8661516..6175422 100644
--- a/app/src/stage.ts
+++ b/app/src/stage.ts
@@ -28,6 +28,7 @@ export class Stage {
 
   // 演出管理
   private isZenkeshiEffectActiveFlag = false
+  private isGameOverEffectActiveFlag = false
 
   constructor() {
     // ゲームフィールドの初期化
@@ -463,10 +464,32 @@ export class Stage {
     return false // すべての位置が空なのでゲームオーバーではない
   }
 
+  /**
+   * ゲームオーバー演出が有効かどうかを取得
+   */
+  isGameOverEffectActive(): boolean {
+    return this.isGameOverEffectActiveFlag
+  }
+
+  /**
+   * ゲームオーバー演出を開始
+   */
+  triggerGameOver(): void {
+    this.isGameOverEffectActiveFlag = true
+  }
+
+  /**
+   * ゲームオーバー演出を停止
+   */
+  stopGameOverEffect(): void {
+    this.isGameOverEffectActiveFlag = false
+  }
+
   /**
    * 演出を全て停止する
    */
   stopAllEffects(): void {
     this.isZenkeshiEffectActiveFlag = false
+    this.isGameOverEffectActiveFlag = false
   }
 }
diff --git a/app/src/tests/game.test.ts b/app/src/tests/game.test.ts
index aa37169..ddd436e 100644
--- a/app/src/tests/game.test.ts
+++ b/app/src/tests/game.test.ts
@@ -1,5 +1,24 @@
 import { describe, it, expect, beforeEach, vi } from 'vitest'
 import { Game } from '../game'
+import { PuyoImage } from '../puyoimage'
+
+// PuyoImageクラスをモック化
+const mockPuyoImageInstance = {
+  clearCanvas: vi.fn(),
+  renderField: vi.fn(),
+  renderActivePuyo: vi.fn(),
+  renderNextPuyo: vi.fn(),
+  renderZenkeshiEffect: vi.fn(),
+  renderGameOverEffect: vi.fn(),
+  getCellSize: vi.fn(() => 30),
+  getFieldOffset: vi.fn(() => ({ x: 10, y: 10 })),
+}
+
+vi.mock('../puyoimage', () => {
+  return {
+    PuyoImage: vi.fn(() => mockPuyoImageInstance)
+  }
+})
 
 describe('Game', () => {
   let canvas: HTMLCanvasElement
@@ -8,6 +27,8 @@ describe('Game', () => {
   let mockContext: CanvasRenderingContext2D
 
   beforeEach(() => {
+    vi.clearAllMocks()
+    
     // Canvas 2Dコンテキストのモック
     mockContext = {
       fillStyle: '',
@@ -29,13 +50,15 @@ describe('Game', () => {
       font: 'bold 48px Arial',
     } as unknown as CanvasRenderingContext2D
 
-    // Canvas要素をモック
-    canvas = document.createElement('canvas')
-    canvas.width = 320
-    canvas.height = 480
-
-    // getContextメソッドをモック
-    vi.spyOn(canvas, 'getContext').mockReturnValue(mockContext)
+    // Canvas要素を完全にモック化（setup.tsのモックと一貫性を保つ）
+    canvas = {
+      getContext: vi.fn().mockReturnValue(mockContext),
+      width: 320,
+      height: 480,
+      style: {},
+      addEventListener: vi.fn(),
+      removeEventListener: vi.fn(),
+    } as unknown as HTMLCanvasElement
 
     // スコア表示要素をモック
     scoreDisplay = document.createElement('div')
@@ -43,6 +66,13 @@ describe('Game', () => {
     // requestAnimationFrameをモック
     vi.stubGlobal('requestAnimationFrame', vi.fn())
 
+    // PuyoImageモックをリセット
+    Object.values(mockPuyoImageInstance).forEach(mock => {
+      if (typeof mock === 'function' && mock.mockReset) {
+        mock.mockReset()
+      }
+    })
+
     game = new Game(canvas, scoreDisplay)
   })
 
@@ -112,22 +142,22 @@ describe('Game', () => {
     it('ゲームフィールドが描画される', () => {
       game.renderField()
 
-      // fillRectが呼ばれることを確認（フィールドの背景描画）
-      expect(mockContext.fillRect).toHaveBeenCalled()
+      // PuyoImageのrenderFieldメソッドが呼ばれることを確認
+      expect(mockPuyoImageInstance.renderField).toHaveBeenCalled()
     })
 
     it('ゲームフィールドの枠線が描画される', () => {
       game.renderField()
 
-      // strokeRectが呼ばれることを確認（フィールドの枠線描画）
-      expect(mockContext.strokeRect).toHaveBeenCalled()
+      // PuyoImageのrenderFieldメソッドが呼ばれることを確認
+      expect(mockPuyoImageInstance.renderField).toHaveBeenCalled()
     })
 
     it('Canvasがクリアされる', () => {
       game.clearScreen()
 
-      // clearRectが呼ばれることを確認
-      expect(mockContext.clearRect).toHaveBeenCalled()
+      // PuyoImageのclearCanvasメソッドが呼ばれることを確認
+      expect(mockPuyoImageInstance.clearCanvas).toHaveBeenCalled()
     })
   })
 
@@ -174,17 +204,15 @@ describe('Game', () => {
       game.spawnActivePuyo()
       game.renderActivePuyo()
 
-      // 2つのぷよが楕円形で描画される（ellipseが2回呼ばれる）
-      expect(mockContext.ellipse).toHaveBeenCalledTimes(2)
-      expect(mockContext.fill).toHaveBeenCalledTimes(2)
+      // PuyoImageのrenderActivePuyoメソッドが呼ばれる
+      expect(mockPuyoImageInstance.renderActivePuyo).toHaveBeenCalled()
     })
 
     it('次のぷよが画面に描画される', () => {
       game.renderNextPuyo()
 
-      // 次のぷよエリアが楕円形で描画される
-      expect(mockContext.ellipse).toHaveBeenCalled()
-      expect(mockContext.fill).toHaveBeenCalled()
+      // PuyoImageのrenderNextPuyoメソッドが呼ばれる
+      expect(mockPuyoImageInstance.renderNextPuyo).toHaveBeenCalled()
     })
 
     it('ぷよの色が正しく設定される', () => {
@@ -240,8 +268,8 @@ describe('Game', () => {
     beforeEach(() => {
       vi.clearAllMocks()
       // キーボードイベントのモック設定
-      global.addEventListener = vi.fn()
-      global.removeEventListener = vi.fn()
+      globalThis.addEventListener = vi.fn()
+      globalThis.removeEventListener = vi.fn()
     })
 
     it('左キーが押されたことを検知できる', () => {
@@ -280,8 +308,8 @@ describe('Game', () => {
     it('キーボードイベントリスナーが登録される', () => {
       game.setupInputHandlers()
 
-      expect(global.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function))
-      expect(global.addEventListener).toHaveBeenCalledWith('keyup', expect.any(Function))
+      expect(globalThis.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function))
+      expect(globalThis.addEventListener).toHaveBeenCalledWith('keyup', expect.any(Function))
     })
 
     it('入力状態をリセットできる', () => {
@@ -386,41 +414,49 @@ describe('Game', () => {
       const initialPuyo = game.getActivePuyo()
       const initialX = initialPuyo!.x
 
-      // 左キーを押す
+      // 左キーを押す（即座に1回移動する）
       const leftKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowLeft' })
       game.handleKeyDown(leftKeyEvent)
 
-      // 移動間隔の直前まで移動処理を実行
+      // 1回移動したことを確認
+      expect(game.getActivePuyo()!.x).toBe(initialX - 1)
+
+      // 移動間隔の直前まで移動処理を実行（まだ次の移動はされない）
       for (let i = 0; i < 7; i++) {
         game.updateMovement()
       }
 
       const updatedPuyo = game.getActivePuyo()
-      expect(updatedPuyo!.x).toBe(initialX) // まだ移動しない
+      expect(updatedPuyo!.x).toBe(initialX - 1) // まだ次の移動はしない
     })
 
     it('連続移動のタイミングが正しく制御される', () => {
       const initialPuyo = game.getActivePuyo()
       const initialX = initialPuyo!.x
 
-      // 左キーを押して8フレーム待って移動させる
+      // 左キーを押す（即座に1回移動する）
       const leftKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowLeft' })
       game.handleKeyDown(leftKeyEvent)
 
-      for (let i = 0; i < 8; i++) {
-        game.updateMovement()
-      }
-
-      // 最初の移動が完了
+      // 最初の移動が完了していることを確認
       expect(game.getActivePuyo()!.x).toBe(initialX - 1)
 
-      // さらに8フレーム待って再び移動
-      for (let i = 0; i < 8; i++) {
+      // 9フレーム間、継続的にupdateMovementとupdateTimersを呼び出す
+      // （キーが押され続けている状態で8フレーム経過後の9フレーム目に次の移動が発生）
+      for (let i = 0; i < 9; i++) {
+        // 移動間隔制御のテストなので、落下やゲームループは無効化
+        game.disableFalling()
         game.updateMovement()
+        // プライベートなplayerにアクセスするためにテスト用メソッドを使う
+        ;(game as any).player.updateTimers()
       }
 
       const updatedPuyo = game.getActivePuyo()
       expect(updatedPuyo!.x).toBe(initialX - 2) // 2回移動
+      
+      // キーアップをシミュレートして状態をクリア
+      const leftKeyUpEvent = new KeyboardEvent('keyup', { key: 'ArrowLeft' })
+      game.handleKeyUp(leftKeyUpEvent)
     })
   })
 
@@ -460,9 +496,6 @@ describe('Game', () => {
       const initialPuyo = game.getActivePuyo()
       const initialX = initialPuyo!.x
 
-      // renderActivePuyoメソッドをスパイする
-      const renderActivePuyoSpy = vi.spyOn(game, 'renderActivePuyo')
-
       // 左キーを押す
       const leftKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowLeft' })
       game.handleKeyDown(leftKeyEvent)
@@ -479,8 +512,8 @@ describe('Game', () => {
       const updatedPuyo = game.getActivePuyo()
       expect(updatedPuyo!.x).toBe(initialX - 1)
 
-      // renderActivePuyoが呼ばれることを確認
-      expect(renderActivePuyoSpy).toHaveBeenCalled()
+      // PuyoImageのrenderActivePuyoメソッドが呼ばれることを確認
+      expect(mockPuyoImageInstance.renderActivePuyo).toHaveBeenCalledWith(updatedPuyo)
     })
 
     it('ゲームループが動作中は継続的に表示が更新される', async () => {
@@ -890,26 +923,10 @@ describe('Game', () => {
   describe('フィールド上のぷよ描画', () => {
     let game: Game
     let mockCanvas: HTMLCanvasElement
-    let mockContext: CanvasRenderingContext2D
     let mockScoreDisplay: HTMLElement
 
     beforeEach(() => {
-      // Canvas とコンテキストのモックを作成
-      mockContext = {
-        fillStyle: '',
-        strokeStyle: '',
-        lineWidth: 1,
-        fillRect: vi.fn(),
-        strokeRect: vi.fn(),
-        clearRect: vi.fn(),
-        beginPath: vi.fn(),
-        ellipse: vi.fn(),
-        fill: vi.fn(),
-        stroke: vi.fn(),
-      } as unknown as CanvasRenderingContext2D
-
       mockCanvas = {
-        getContext: vi.fn().mockReturnValue(mockContext),
         width: 320,
         height: 480,
       } as unknown as HTMLCanvasElement
@@ -933,32 +950,16 @@ describe('Game', () => {
       // フィールドを描画
       game.renderField()
 
-      // ellipseが呼ばれている回数を確認（楕円描画）
-      const ellipseCalls = (mockContext.ellipse as any).mock.calls
-
-      // 固定ぷよが楕円形で描画される（3回のellipse呼び出しがあるはず）
-      expect(ellipseCalls.length).toBe(3)
-
-      // fillが呼ばれている回数を確認（楕円の塗りつぶし）
-      const fillCalls = (mockContext.fill as any).mock.calls
-      expect(fillCalls.length).toBe(3)
-
-      // ぷよの色が正しく設定されているかチェック
-      const fillStyleCalls = mockContext.fillStyle as any
-
-      // 固定されたぷよの色が描画されているかをテスト
-      game.render()
-      expect(mockContext.fillRect).toHaveBeenCalled()
+      // PuyoImageのrenderFieldメソッドが呼ばれたことを確認
+      expect(mockPuyoImageInstance.renderField).toHaveBeenCalledWith(field)
     })
 
     it('空のフィールドセルは描画されない', () => {
       // 空のフィールドで描画
       game.renderField()
 
-      const fillRectCalls = (mockContext.fillRect as any).mock.calls
-
-      // 背景のみの描画（固定ぷよがないので背景の1回のみ）
-      expect(fillRectCalls.length).toBe(1)
+      // PuyoImageのrenderFieldメソッドが呼ばれたことを確認
+      expect(mockPuyoImageInstance.renderField).toHaveBeenCalledWith(game.getField())
     })
   })
 
@@ -1019,6 +1020,13 @@ describe('Game', () => {
       })
 
       it('回転方向の値は0-3の範囲で循環する', () => {
+        // ぷよを少し下に移動させて回転可能な位置に移動
+        const activePuyo = game.getActivePuyo()
+        if (activePuyo) {
+          // ぷよを(2,2)に移動させて回転に十分なスペースを確保
+          ;(game as any).puyo.updateActivePuyoPosition(0, 2)
+        }
+
         // 4回回転させると元の方向に戻る
         for (let i = 0; i < 4; i++) {
           const upKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowUp' })
@@ -1486,10 +1494,12 @@ describe('Game', () => {
           const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
           game.handleKeyDown(downKeyEvent)
 
-          // 1フレーム更新
-          game.updateAndRender()
+          // 高速落下間隔（3フレーム）まで更新
+          for (let i = 0; i < 3; i++) {
+            game.updateAndRender()
+          }
 
-          // 下キーが押されているときは即座に落下するはず
+          // 下キーが押されているときは高速落下するはず
           expect(activePuyo.y).toBeGreaterThan(initialY)
         }
       })
@@ -1521,13 +1531,13 @@ describe('Game', () => {
           const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
           game.handleKeyDown(downKeyEvent)
 
-          // 複数フレーム更新
-          for (let i = 0; i < 5; i++) {
+          // 十分なフレーム数更新（2回の高速落下が発生するよう6フレーム）
+          for (let i = 0; i < 6; i++) {
             game.updateAndRender()
           }
 
-          // 継続的に落下しているはず
-          expect(activePuyo.y).toBeGreaterThan(initialY + 3)
+          // 継続的に落下しているはず（2回落下して2ピクセル下に）
+          expect(activePuyo.y).toBeGreaterThan(initialY + 1)
         }
       })
     })
@@ -1689,8 +1699,10 @@ describe('Game', () => {
           const downKeyEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' })
           game.handleKeyDown(downKeyEvent)
 
-          // 高速落下処理を実行（着地するまで）
-          game.updateAndRender()
+          // 高速落下処理を実行（3フレーム必要）
+          for (let i = 0; i < 3; i++) {
+            game.updateAndRender()
+          }
 
           // 着地により新しいぷよが生成されているはず
           const newActivePuyo = game.getActivePuyo()
@@ -2748,12 +2760,8 @@ describe('Game', () => {
         // 描画メソッドを実行
         game.render()
 
-        // 全消し演出のテキストが描画されているかチェック
-        expect(mockContext.fillText).toHaveBeenCalledWith(
-          '全消し！',
-          expect.any(Number),
-          expect.any(Number)
-        )
+        // PuyoImageのrenderZenkeshiEffectメソッドが呼ばれることを確認
+        expect(mockPuyoImageInstance.renderZenkeshiEffect).toHaveBeenCalled()
       })
     })
   })
@@ -2807,12 +2815,8 @@ describe('Game', () => {
         // 描画メソッドを呼び出し
         game.render()
 
-        // ゲームオーバー演出用のテキスト描画が実行されることを確認
-        expect(mockContext.fillText).toHaveBeenCalledWith(
-          expect.stringContaining('GAME OVER'),
-          expect.any(Number),
-          expect.any(Number)
-        )
+        // PuyoImageのrenderGameOverEffectメソッドが呼ばれることを確認
+        expect(mockPuyoImageInstance.renderGameOverEffect).toHaveBeenCalled()
       })
 
       it('ゲームオーバー演出でリスタート案内が表示される', () => {
@@ -2829,12 +2833,8 @@ describe('Game', () => {
         // 描画メソッドを呼び出し
         game.render()
 
-        // リスタート案内テキストが描画されることを確認
-        expect(mockContext.fillText).toHaveBeenCalledWith(
-          expect.stringContaining('Rキーまたはスペースキーでリスタート'),
-          expect.any(Number),
-          expect.any(Number)
-        )
+        // PuyoImageのrenderGameOverEffectメソッドが呼ばれることを確認（リスタート案内も含む）
+        expect(mockPuyoImageInstance.renderGameOverEffect).toHaveBeenCalled()
       })
     })
 
@@ -2935,9 +2935,8 @@ describe('Game', () => {
       })
 
       it('リスタート後に全消し演出が停止する', () => {
-        // 全消し演出フラグを直接設定（テスト用メソッドが必要）
-        // privateメソッドにアクセスするため、anyでキャスト
-        ;(game as any).isZenkeshiEffectActiveFlag = true
+        // 全消し演出フラグを直接設定（テスト用メソッド使用）
+        game.setZenkeshiEffectActive(true)
 
         // 全消し演出が有効になったことを確認
         expect(game.isZenkeshiEffectActive()).toBe(true)
diff --git a/app/src/tests/player.test.ts b/app/src/tests/player.test.ts
index 458a1fb..fc4034d 100644
--- a/app/src/tests/player.test.ts
+++ b/app/src/tests/player.test.ts
@@ -180,6 +180,9 @@ describe('Player', () => {
       player.handleKeyDown(37) // ArrowLeft
       expect(callback).toHaveBeenCalledTimes(1) // 増えない
 
+      // キーリリースをシミュレート
+      player.handleKeyUp(37) // ArrowLeft
+      
       // タイマーリセット後
       player.resetMovementTimer()
       player.handleKeyDown(37) // ArrowLeft
diff --git a/app/src/tests/puyoimage.test.ts b/app/src/tests/puyoimage.test.ts
index 46808e1..125569f 100644
--- a/app/src/tests/puyoimage.test.ts
+++ b/app/src/tests/puyoimage.test.ts
@@ -7,42 +7,48 @@ describe('PuyoImage', () => {
   let mockContext: CanvasRenderingContext2D
 
   beforeEach(() => {
-    // Canvas 2D context をモック化
-    mockContext = {
-      clearRect: vi.fn(),
-      fillRect: vi.fn(),
-      fillText: vi.fn(),
-      ellipse: vi.fn(),
-      beginPath: vi.fn(),
-      fill: vi.fn(),
-      stroke: vi.fn(),
-      save: vi.fn(),
-      restore: vi.fn(),
-      set fillStyle(value: string) {},
-      get fillStyle() {
-        return '#000000'
-      },
-      set strokeStyle(value: string) {},
-      get strokeStyle() {
-        return '#000000'
-      },
-      set lineWidth(value: number) {},
-      get lineWidth() {
-        return 1
-      },
-      set font(value: string) {},
-      get font() {
-        return '10px sans-serif'
-      },
-      set textAlign(value: string) {},
-      get textAlign() {
-        return 'start'
-      },
-      set textBaseline(value: string) {},
-      get textBaseline() {
-        return 'alphabetic'
-      },
-    } as any
+    // setup.tsで定義されたグローバルモックを使用
+    const createMockContext = (global as any).createMockContext
+    if (createMockContext) {
+      mockContext = createMockContext()
+    } else {
+      // フォールバック用の独自モック（setup.tsが利用できない場合）
+      mockContext = {
+        clearRect: vi.fn(),
+        fillRect: vi.fn(),
+        fillText: vi.fn(),
+        ellipse: vi.fn(),
+        beginPath: vi.fn(),
+        fill: vi.fn(),
+        stroke: vi.fn(),
+        save: vi.fn(),
+        restore: vi.fn(),
+        set fillStyle(value: string) {},
+        get fillStyle() {
+          return '#000000'
+        },
+        set strokeStyle(value: string) {},
+        get strokeStyle() {
+          return '#000000'
+        },
+        set lineWidth(value: number) {},
+        get lineWidth() {
+          return 1
+        },
+        set font(value: string) {},
+        get font() {
+          return '10px sans-serif'
+        },
+        set textAlign(value: string) {},
+        get textAlign() {
+          return 'start'
+        },
+        set textBaseline(value: string) {},
+        get textBaseline() {
+          return 'alphabetic'
+        },
+      } as any
+    }
 
     // Canvas をモック化
     mockCanvas = {
diff --git a/app/src/tests/setup.ts b/app/src/tests/setup.ts
index 915ebdc..7d83307 100644
--- a/app/src/tests/setup.ts
+++ b/app/src/tests/setup.ts
@@ -10,22 +10,66 @@ import { vi, beforeEach } from 'vitest'
   clearTimeout(id)
 })
 
-// HTMLCanvasElement のモック
+// 共通のCanvas 2D contextモックを作成
+const createMockContext = () => ({
+  clearRect: vi.fn(),
+  fillRect: vi.fn(),
+  strokeRect: vi.fn(),
+  beginPath: vi.fn(),
+  ellipse: vi.fn(),
+  fill: vi.fn(),
+  stroke: vi.fn(),
+  save: vi.fn(),
+  restore: vi.fn(),
+  fillText: vi.fn(),
+  fillStyle: '',
+  strokeStyle: '',
+  lineWidth: 1,
+  font: '',
+  textAlign: '',
+  textBaseline: '',
+})
+
+// HTMLCanvasElement のモック（グローバル設定）
+Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {
+  value: vi.fn(() => {
+    const context = createMockContext()
+    // デバッグ用ログ
+    console.log('Global mock getContext called, returning context with save:', typeof context.save)
+    return context
+  }),
+  writable: true,
+  configurable: true,
+})
+
+Object.defineProperty(HTMLCanvasElement.prototype, 'width', {
+  value: 400,
+  writable: true,
+  configurable: true,
+})
+
+Object.defineProperty(HTMLCanvasElement.prototype, 'height', {
+  value: 600,
+  writable: true,
+  configurable: true,
+})
+
+// HTMLCanvasElement のモック（各テスト前のリセット）
 beforeEach(() => {
+  // 各テストの前にモックをリフレッシュ
+  const mockGetContext = vi.fn(() => {
+    const context = createMockContext()
+    // デバッグ用ログ
+    console.log('BeforeEach mock getContext called, returning context with save:', typeof context.save)
+    return context
+  })
+  
   Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {
-    value: vi.fn(() => ({
-      clearRect: vi.fn(),
-      fillRect: vi.fn(),
-      strokeRect: vi.fn(),
-      beginPath: vi.fn(),
-      ellipse: vi.fn(),
-      fill: vi.fn(),
-      stroke: vi.fn(),
-      fillStyle: '',
-      strokeStyle: '',
-      lineWidth: 1,
-    })),
+    value: mockGetContext,
     writable: true,
     configurable: true,
   })
 })
+
+// グローバルにcanvas contextモックを利用可能にする
+;(global as any).createMockContext = createMockContext

```

