# 作業履歴 2025-07-22

## 概要

2025-07-22の作業内容をまとめています。

## コミット: 79daa5d

### メッセージ

```
feat: サウンド・設定・統計システムの追加とUI拡張（第3イテレーション）
- Web Audio APIによる効果音・BGM再生機能（audio.ts, input.ts, main.ts）
- サウンド・BGM・FPS表示・キーバインド等の設定管理/テスト追加（settings.test.ts, settings.local.json, settingsUI.css）
- ゲーム統計・進捗・ランキング管理とテスト追加（statistics.test.ts, main.ts）
- サウンド・設定・統計のUI統合、パフォーマンス・エラー表示拡張（index.html, main.ts）
- レンダラーの拡張アニメーションAPI追加（renderer.ts）
- audio, settings, statisticsの単体テスト追加
```

### 変更されたファイル

- A	.claude/settings.local.json
- M	app/index.html
- A	app/src/audio.test.ts
- A	app/src/audio.ts
- A	app/src/enhanced-animation.test.ts
- A	app/src/enhanced-animation.ts
- M	app/src/input.ts
- M	app/src/main.ts
- M	app/src/renderer.ts
- A	app/src/settings.test.ts
- A	app/src/settings.ts
- A	app/src/settingsUI.css
- A	app/src/settingsUI.ts
- A	app/src/statistics.test.ts
- A	app/src/statistics.ts

### 変更内容

```diff
commit 79daa5d3542f7b7ff2d965d1712dde6c796b3ba3
Author: k2works <kakimomokuri@gmail.com>
Date:   Tue Jul 22 21:11:04 2025 +0900

    feat: サウンド・設定・統計システムの追加とUI拡張（第3イテレーション）
    
    - Web Audio APIによる効果音・BGM再生機能（audio.ts, input.ts, main.ts）
    - サウンド・BGM・FPS表示・キーバインド等の設定管理/テスト追加（settings.test.ts, settings.local.json, settingsUI.css）
    - ゲーム統計・進捗・ランキング管理とテスト追加（statistics.test.ts, main.ts）
    - サウンド・設定・統計のUI統合、パフォーマンス・エラー表示拡張（index.html, main.ts）
    - レンダラーの拡張アニメーションAPI追加（renderer.ts）
    - audio, settings, statisticsの単体テスト追加

diff --git a/.claude/settings.local.json b/.claude/settings.local.json
new file mode 100644
index 0000000..d12fcd2
--- /dev/null
+++ b/.claude/settings.local.json
@@ -0,0 +1,11 @@
+{
+  "permissions": {
+    "allow": [
+      "Bash(npm test)",
+      "Bash(npm test:*)",
+      "Bash(npm run build:*)",
+      "Bash(npm run dev:*)"
+    ],
+    "deny": []
+  }
+}
\ No newline at end of file
diff --git a/app/index.html b/app/index.html
index df96f2e..5d34e1c 100644
--- a/app/index.html
+++ b/app/index.html
@@ -5,6 +5,7 @@
     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
     <title>Puyo Puyo Game</title>
+    <link rel="stylesheet" href="/src/settingsUI.css">
     <style>
       body {
         margin: 0;
@@ -113,6 +114,7 @@
             <div style="margin-bottom: 10px">
               <button id="start-button">Start Game</button>
               <button id="reset-button">Reset</button>
+              <button id="settings-button">⚙️ Settings</button>
             </div>
             <div style="font-size: 12px; line-height: 1.4">
               <strong>Controls:</strong><br />
@@ -125,8 +127,23 @@
             <div class="info-title">Status</div>
             <div class="info-value" id="status-display">Ready</div>
           </div>
+          <div class="info-panel">
+            <div class="info-title">Statistics</div>
+            <div style="font-size: 11px; line-height: 1.3;">
+              <div>Games: <span id="stats-games">0</span></div>
+              <div>High Score: <span id="stats-high">0</span></div>
+              <div>Avg Score: <span id="stats-avg">0</span></div>
+              <div>Play Time: <span id="stats-time">0秒</span></div>
+            </div>
+          </div>
         </div>
       </div>
+      
+      <!-- エラーメッセージ表示用 -->
+      <div id="error-message" style="display: none; position: fixed; top: 20px; right: 20px; background: #dc3545; color: white; padding: 12px; border-radius: 6px; z-index: 1001;"></div>
+      
+      <!-- パフォーマンス表示（オプション） -->
+      <div id="performance-display" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; z-index: 100;"></div>
     </div>
     <script type="module" src="/src/main.ts"></script>
   </body>
diff --git a/app/src/audio.test.ts b/app/src/audio.test.ts
new file mode 100644
index 0000000..277105f
--- /dev/null
+++ b/app/src/audio.test.ts
@@ -0,0 +1,301 @@
+import { describe, it, expect, beforeEach, vi } from 'vitest'
+import { AudioEngine, SoundType, SoundPresets } from './audio'
+
+// Web Audio API のモック化
+class MockAudioContext {
+  public state = 'running'
+  public currentTime = 0
+  public destination = {}
+
+  createGain() {
+    return {
+      gain: {
+        setValueAtTime: vi.fn(),
+        exponentialRampToValueAtTime: vi.fn()
+      },
+      connect: vi.fn()
+    }
+  }
+
+  createOscillator() {
+    return {
+      type: 'sine',
+      frequency: {
+        setValueAtTime: vi.fn()
+      },
+      connect: vi.fn(),
+      start: vi.fn(),
+      stop: vi.fn(),
+      disconnect: vi.fn(),
+      onended: null
+    }
+  }
+
+  resume() {
+    return Promise.resolve()
+  }
+
+  close() {
+    return Promise.resolve()
+  }
+}
+
+// グローバルモック設定
+Object.defineProperty(window, 'AudioContext', {
+  writable: true,
+  value: MockAudioContext
+})
+
+describe('AudioEngine', () => {
+  let audioEngine: AudioEngine
+
+  beforeEach(() => {
+    audioEngine = new AudioEngine()
+    vi.clearAllMocks()
+  })
+
+  describe('初期化', () => {
+    it('AudioEngineを正常に作成できる', () => {
+      expect(audioEngine).toBeInstanceOf(AudioEngine)
+      expect(audioEngine.getAudioState()).toBe('not-initialized')
+    })
+
+    it('初期化後にオーディオ状態が変わる', async () => {
+      await audioEngine.initialize()
+      expect(audioEngine.getAudioState()).toBe('running')
+    })
+
+    it('設定のデフォルト値が正しい', () => {
+      const config = audioEngine.getConfig()
+      expect(config.volume).toBe(0.7)
+      expect(config.enabled).toBe(true)
+      expect(config.bgmEnabled).toBe(true)
+    })
+  })
+
+  describe('設定管理', () => {
+    beforeEach(async () => {
+      await audioEngine.initialize()
+    })
+
+    it('音量を設定できる', () => {
+      audioEngine.setMasterVolume(0.5)
+      expect(audioEngine.getConfig().volume).toBe(0.5)
+    })
+
+    it('音量範囲が制限される', () => {
+      audioEngine.setMasterVolume(-0.1)
+      expect(audioEngine.getConfig().volume).toBe(0)
+      
+      audioEngine.setMasterVolume(1.5)
+      expect(audioEngine.getConfig().volume).toBe(1)
+    })
+
+    it('効果音の有効/無効を設定できる', () => {
+      audioEngine.setSoundEnabled(false)
+      expect(audioEngine.getConfig().enabled).toBe(false)
+      
+      audioEngine.setSoundEnabled(true)
+      expect(audioEngine.getConfig().enabled).toBe(true)
+    })
+
+    it('BGMの有効/無効を設定できる', () => {
+      audioEngine.setBGMEnabled(false)
+      expect(audioEngine.getConfig().bgmEnabled).toBe(false)
+      
+      audioEngine.setBGMEnabled(true)
+      expect(audioEngine.getConfig().bgmEnabled).toBe(true)
+    })
+  })
+
+  describe('効果音再生', () => {
+    beforeEach(async () => {
+      await audioEngine.initialize()
+    })
+
+    it('Move音を再生できる', () => {
+      audioEngine.playSound(SoundType.Move)
+      // モックなので実際の音は再生されないが、エラーなく実行される
+      expect(true).toBe(true)
+    })
+
+    it('Rotate音を再生できる', () => {
+      audioEngine.playSound(SoundType.Rotate)
+      expect(true).toBe(true)
+    })
+
+    it('Chain音をチェイン数付きで再生できる', () => {
+      audioEngine.playSound(SoundType.Chain, { chain: 3 })
+      expect(true).toBe(true)
+    })
+
+    it('効果音無効時は再生されない', () => {
+      audioEngine.setSoundEnabled(false)
+      audioEngine.playSound(SoundType.Move)
+      // エラーなく実行されることを確認
+      expect(true).toBe(true)
+    })
+
+    it('未初期化時は再生されない', () => {
+      const uninitializedEngine = new AudioEngine()
+      uninitializedEngine.playSound(SoundType.Move)
+      expect(true).toBe(true)
+    })
+  })
+
+  describe('BGM制御', () => {
+    beforeEach(async () => {
+      await audioEngine.initialize()
+    })
+
+    it('BGMを開始できる', () => {
+      audioEngine.startBGM()
+      expect(true).toBe(true)
+    })
+
+    it('BGMを停止できる', () => {
+      audioEngine.startBGM()
+      audioEngine.stopBGM()
+      expect(true).toBe(true)
+    })
+
+    it('BGM無効時は開始されない', () => {
+      audioEngine.setBGMEnabled(false)
+      audioEngine.startBGM()
+      expect(true).toBe(true)
+    })
+
+    it('複数回startBGMを呼んでも問題ない', () => {
+      audioEngine.startBGM()
+      audioEngine.startBGM()
+      expect(true).toBe(true)
+    })
+  })
+
+  describe('リソース管理', () => {
+    it('全音停止ができる', async () => {
+      await audioEngine.initialize()
+      audioEngine.playSound(SoundType.Move)
+      audioEngine.startBGM()
+      
+      audioEngine.stopAllSounds()
+      expect(true).toBe(true)
+    })
+
+    it('リソース破棄ができる', async () => {
+      await audioEngine.initialize()
+      audioEngine.destroy()
+      
+      expect(audioEngine.getAudioState()).toBe('not-initialized')
+    })
+  })
+
+  describe('AudioContext復旧', () => {
+    it('AudioContext復旧を試行できる', async () => {
+      await audioEngine.initialize()
+      await audioEngine.resumeAudioContext()
+      expect(true).toBe(true)
+    })
+  })
+})
+
+describe('SoundPresets', () => {
+  describe('プリセット効果音', () => {
+    it('Move音のプリセットが正しい', () => {
+      const sound = SoundPresets.getPuyoMoveSound()
+      expect(sound.type).toBe(SoundType.Move)
+      expect(sound.frequency).toBe(400)
+      expect(sound.duration).toBe(0.08)
+    })
+
+    it('Rotate音のプリセットが正しい', () => {
+      const sound = SoundPresets.getPuyoRotateSound()
+      expect(sound.type).toBe(SoundType.Rotate)
+      expect(sound.frequency).toBe(550)
+      expect(sound.duration).toBe(0.12)
+    })
+
+    it('Land音のプリセットが正しい', () => {
+      const sound = SoundPresets.getPuyoLandSound()
+      expect(sound.type).toBe(SoundType.Land)
+      expect(sound.frequency).toBe(180)
+      expect(sound.duration).toBe(0.25)
+    })
+
+    it('Chain音のプリセットがチェイン数に応じて変わる', () => {
+      const chain1 = SoundPresets.getChainSound(1)
+      const chain3 = SoundPresets.getChainSound(3)
+      
+      expect(chain1.type).toBe(SoundType.Chain)
+      expect(chain3.type).toBe(SoundType.Chain)
+      expect(chain3.frequency).toBeGreaterThan(chain1.frequency)
+      expect(chain3.duration).toBeGreaterThan(chain1.duration)
+      expect(chain3.chain).toBe(3)
+    })
+
+    it('Erase音のプリセットがぷよ数に応じて変わる', () => {
+      const erase4 = SoundPresets.getEraseSound(4)
+      const erase8 = SoundPresets.getEraseSound(8)
+      
+      expect(erase4.type).toBe(SoundType.Erase)
+      expect(erase8.type).toBe(SoundType.Erase)
+      expect(erase8.frequency).toBeGreaterThan(erase4.frequency)
+      expect(erase4.fadeOut).toBe(true)
+      expect(erase8.fadeOut).toBe(true)
+    })
+  })
+
+  describe('プリセット値の妥当性', () => {
+    it('周波数が妥当な範囲内', () => {
+      const sounds = [
+        SoundPresets.getPuyoMoveSound(),
+        SoundPresets.getPuyoRotateSound(),
+        SoundPresets.getPuyoLandSound(),
+        SoundPresets.getChainSound(1),
+        SoundPresets.getEraseSound(4)
+      ]
+
+      sounds.forEach(sound => {
+        expect(sound.frequency).toBeGreaterThan(0)
+        expect(sound.frequency).toBeLessThan(2000) // 人間の可聴域内
+      })
+    })
+
+    it('持続時間が妥当な範囲内', () => {
+      const sounds = [
+        SoundPresets.getPuyoMoveSound(),
+        SoundPresets.getPuyoRotateSound(),
+        SoundPresets.getPuyoLandSound(),
+        SoundPresets.getChainSound(1),
+        SoundPresets.getEraseSound(4)
+      ]
+
+      sounds.forEach(sound => {
+        expect(sound.duration).toBeGreaterThan(0)
+        expect(sound.duration).toBeLessThan(2) // 2秒以下
+      })
+    })
+  })
+})
+
+describe('SoundType', () => {
+  it('すべてのSoundTypeが定義されている', () => {
+    expect(SoundType.Move).toBeDefined()
+    expect(SoundType.Rotate).toBeDefined()
+    expect(SoundType.Land).toBeDefined()
+    expect(SoundType.Erase).toBeDefined()
+    expect(SoundType.Chain).toBeDefined()
+    expect(SoundType.GameOver).toBeDefined()
+    expect(SoundType.BGM).toBeDefined()
+  })
+
+  it('SoundType値が期待通り', () => {
+    expect(SoundType.Move).toBe('move')
+    expect(SoundType.Rotate).toBe('rotate')
+    expect(SoundType.Land).toBe('land')
+    expect(SoundType.Erase).toBe('erase')
+    expect(SoundType.Chain).toBe('chain')
+    expect(SoundType.GameOver).toBe('gameOver')
+    expect(SoundType.BGM).toBe('bgm')
+  })
+})
\ No newline at end of file
diff --git a/app/src/audio.ts b/app/src/audio.ts
new file mode 100644
index 0000000..e822d2d
--- /dev/null
+++ b/app/src/audio.ts
@@ -0,0 +1,396 @@
+// サウンドシステム - Web Audio API実装
+
+export enum SoundType {
+  Move = 'move',
+  Rotate = 'rotate',
+  Land = 'land',
+  Erase = 'erase',
+  Chain = 'chain',
+  GameOver = 'gameOver',
+  BGM = 'bgm'
+}
+
+export interface SoundConfig {
+  volume: number  // 0.0 - 1.0
+  enabled: boolean
+  bgmEnabled: boolean
+}
+
+export interface SoundEffect {
+  id: string
+  type: SoundType
+  frequency: number
+  duration: number
+  fadeOut?: boolean
+  chain?: number // チェイン数（チェイン音用）
+}
+
+export class AudioEngine {
+  private audioContext: AudioContext | null = null
+  private masterGain: GainNode | null = null
+  private bgmGain: GainNode | null = null
+  private sfxGain: GainNode | null = null
+  private config: SoundConfig
+  private isInitialized = false
+  private bgmOscillator: OscillatorNode | null = null
+  private activeSounds: Map<string, { oscillator: OscillatorNode; gain: GainNode }> = new Map()
+
+  constructor() {
+    this.config = {
+      volume: 0.7,
+      enabled: true,
+      bgmEnabled: true
+    }
+  }
+
+  async initialize(): Promise<void> {
+    try {
+      // Web Audio APIの初期化
+      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()
+      
+      // マスターゲイン設定
+      this.masterGain = this.audioContext.createGain()
+      this.masterGain.connect(this.audioContext.destination)
+      this.masterGain.gain.setValueAtTime(this.config.volume, this.audioContext.currentTime)
+
+      // BGM用ゲイン
+      this.bgmGain = this.audioContext.createGain()
+      this.bgmGain.connect(this.masterGain)
+      this.bgmGain.gain.setValueAtTime(0.3, this.audioContext.currentTime)
+
+      // 効果音用ゲイン
+      this.sfxGain = this.audioContext.createGain()
+      this.sfxGain.connect(this.masterGain)
+      this.sfxGain.gain.setValueAtTime(0.8, this.audioContext.currentTime)
+
+      this.isInitialized = true
+      console.log('🔊 Audio Engine initialized')
+    } catch (error) {
+      console.warn('オーディオの初期化に失敗しました:', error)
+      this.isInitialized = false
+    }
+  }
+
+  // 効果音再生
+  playSound(type: SoundType, options?: { chain?: number; pitch?: number }): void {
+    if (!this.isInitialized || !this.config.enabled || !this.audioContext || !this.sfxGain) {
+      return
+    }
+
+    const effect = this.createSoundEffect(type, options)
+    this.playSoundEffect(effect)
+  }
+
+  // BGM開始
+  startBGM(): void {
+    if (!this.isInitialized || !this.config.bgmEnabled || !this.audioContext || !this.bgmGain) {
+      return
+    }
+
+    this.stopBGM() // 既存のBGMを停止
+
+    try {
+      // シンプルなBGMメロディ生成
+      this.bgmOscillator = this.audioContext.createOscillator()
+      this.bgmOscillator.type = 'sine'
+      this.bgmOscillator.frequency.setValueAtTime(220, this.audioContext.currentTime) // A3
+
+      // BGMパターン（簡単なアルペジオ）
+      const melody = [220, 261.63, 329.63, 392, 329.63, 261.63] // A3, C4, E4, G4, E4, C4
+      let currentNote = 0
+
+      const playNextNote = () => {
+        if (this.bgmOscillator && this.audioContext) {
+          const frequency = melody[currentNote % melody.length]
+          this.bgmOscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime)
+          currentNote++
+          setTimeout(playNextNote, 800) // 0.8秒ごとに音符変更
+        }
+      }
+
+      this.bgmOscillator.connect(this.bgmGain)
+      this.bgmOscillator.start()
+      playNextNote()
+
+    } catch (error) {
+      console.warn('BGMの再生に失敗しました:', error)
+    }
+  }
+
+  // BGM停止
+  stopBGM(): void {
+    if (this.bgmOscillator) {
+      try {
+        this.bgmOscillator.stop()
+        this.bgmOscillator.disconnect()
+      } catch (error) {
+        // すでに停止している場合は無視
+      }
+      this.bgmOscillator = null
+    }
+  }
+
+  // 音量設定
+  setMasterVolume(volume: number): void {
+    this.config.volume = Math.max(0, Math.min(1, volume))
+    if (this.masterGain && this.audioContext) {
+      this.masterGain.gain.setValueAtTime(this.config.volume, this.audioContext.currentTime)
+    }
+  }
+
+  // 効果音有効/無効
+  setSoundEnabled(enabled: boolean): void {
+    this.config.enabled = enabled
+  }
+
+  // BGM有効/無効
+  setBGMEnabled(enabled: boolean): void {
+    this.config.bgmEnabled = enabled
+    if (!enabled) {
+      this.stopBGM()
+    }
+  }
+
+  // 設定取得
+  getConfig(): SoundConfig {
+    return { ...this.config }
+  }
+
+  // 全音停止
+  stopAllSounds(): void {
+    // 効果音停止
+    for (const [id, sound] of this.activeSounds.entries()) {
+      try {
+        sound.oscillator.stop()
+        sound.oscillator.disconnect()
+        sound.gain.disconnect()
+      } catch (error) {
+        // 無視
+      }
+    }
+    this.activeSounds.clear()
+
+    // BGM停止
+    this.stopBGM()
+  }
+
+  // AudioContextの状態確認
+  getAudioState(): string {
+    if (!this.audioContext) return 'not-initialized'
+    return this.audioContext.state
+  }
+
+  // ユーザージェスチャー後のAudioContext再開
+  async resumeAudioContext(): Promise<void> {
+    if (this.audioContext && this.audioContext.state === 'suspended') {
+      try {
+        await this.audioContext.resume()
+        console.log('AudioContext resumed')
+      } catch (error) {
+        console.warn('AudioContext resume failed:', error)
+      }
+    }
+  }
+
+  private createSoundEffect(type: SoundType, options?: { chain?: number; pitch?: number }): SoundEffect {
+    const baseFreq = options?.pitch || 1.0
+
+    switch (type) {
+      case SoundType.Move:
+        return {
+          id: `move_${Date.now()}`,
+          type,
+          frequency: 400 * baseFreq,
+          duration: 0.1
+        }
+
+      case SoundType.Rotate:
+        return {
+          id: `rotate_${Date.now()}`,
+          type,
+          frequency: 600 * baseFreq,
+          duration: 0.15
+        }
+
+      case SoundType.Land:
+        return {
+          id: `land_${Date.now()}`,
+          type,
+          frequency: 200 * baseFreq,
+          duration: 0.2
+        }
+
+      case SoundType.Erase:
+        return {
+          id: `erase_${Date.now()}`,
+          type,
+          frequency: 800 * baseFreq,
+          duration: 0.3,
+          fadeOut: true
+        }
+
+      case SoundType.Chain:
+        const chain = options?.chain || 1
+        return {
+          id: `chain_${Date.now()}`,
+          type,
+          frequency: (400 + (chain * 200)) * baseFreq, // チェイン数に応じて高音に
+          duration: 0.4 + (chain * 0.1), // チェイン数に応じて長く
+          fadeOut: true,
+          chain
+        }
+
+      case SoundType.GameOver:
+        return {
+          id: `gameOver_${Date.now()}`,
+          type,
+          frequency: 150 * baseFreq,
+          duration: 1.0,
+          fadeOut: true
+        }
+
+      default:
+        return {
+          id: `sound_${Date.now()}`,
+          type,
+          frequency: 440 * baseFreq,
+          duration: 0.2
+        }
+    }
+  }
+
+  private playSoundEffect(effect: SoundEffect): void {
+    if (!this.audioContext || !this.sfxGain) return
+
+    try {
+      const oscillator = this.audioContext.createOscillator()
+      const gain = this.audioContext.createGain()
+
+      // 音の種類に応じた波形設定
+      switch (effect.type) {
+        case SoundType.Chain:
+          oscillator.type = 'sawtooth'
+          break
+        case SoundType.Erase:
+          oscillator.type = 'triangle'
+          break
+        case SoundType.GameOver:
+          oscillator.type = 'square'
+          break
+        default:
+          oscillator.type = 'sine'
+      }
+
+      oscillator.frequency.setValueAtTime(effect.frequency, this.audioContext.currentTime)
+      
+      // ゲイン設定
+      const startTime = this.audioContext.currentTime
+      const endTime = startTime + effect.duration
+
+      gain.gain.setValueAtTime(0.5, startTime)
+      
+      if (effect.fadeOut) {
+        gain.gain.exponentialRampToValueAtTime(0.01, endTime)
+      } else {
+        gain.gain.setValueAtTime(0.5, endTime - 0.01)
+        gain.gain.exponentialRampToValueAtTime(0.01, endTime)
+      }
+
+      // 接続
+      oscillator.connect(gain)
+      gain.connect(this.sfxGain)
+
+      // 再生
+      oscillator.start(startTime)
+      oscillator.stop(endTime)
+
+      // アクティブサウンド登録
+      this.activeSounds.set(effect.id, { oscillator, gain })
+
+      // 終了後クリーンアップ
+      oscillator.onended = () => {
+        this.activeSounds.delete(effect.id)
+        try {
+          oscillator.disconnect()
+          gain.disconnect()
+        } catch (error) {
+          // 無視
+        }
+      }
+
+    } catch (error) {
+      console.warn('効果音の再生に失敗しました:', error)
+    }
+  }
+
+  // リソース解放
+  destroy(): void {
+    this.stopAllSounds()
+    
+    if (this.audioContext) {
+      try {
+        this.audioContext.close()
+      } catch (error) {
+        // 無視
+      }
+      this.audioContext = null
+    }
+
+    this.isInitialized = false
+  }
+}
+
+// プリセット音響効果
+export class SoundPresets {
+  static getPuyoMoveSound(): SoundEffect {
+    return {
+      id: 'puyo_move',
+      type: SoundType.Move,
+      frequency: 400,
+      duration: 0.08
+    }
+  }
+
+  static getPuyoRotateSound(): SoundEffect {
+    return {
+      id: 'puyo_rotate', 
+      type: SoundType.Rotate,
+      frequency: 550,
+      duration: 0.12
+    }
+  }
+
+  static getPuyoLandSound(): SoundEffect {
+    return {
+      id: 'puyo_land',
+      type: SoundType.Land,
+      frequency: 180,
+      duration: 0.25
+    }
+  }
+
+  static getChainSound(chainCount: number): SoundEffect {
+    return {
+      id: `chain_${chainCount}`,
+      type: SoundType.Chain,
+      frequency: 600 + (chainCount * 150),
+      duration: 0.3 + (chainCount * 0.08),
+      fadeOut: true,
+      chain: chainCount
+    }
+  }
+
+  static getEraseSound(puyoCount: number): SoundEffect {
+    const pitch = Math.min(1.5, 1.0 + (puyoCount - 4) * 0.1)
+    return {
+      id: 'puyo_erase',
+      type: SoundType.Erase,
+      frequency: 750 * pitch,
+      duration: 0.35,
+      fadeOut: true
+    }
+  }
+}
+
+// グローバルサウンドマネージャー
+export const soundManager = new AudioEngine()
\ No newline at end of file
diff --git a/app/src/enhanced-animation.test.ts b/app/src/enhanced-animation.test.ts
new file mode 100644
index 0000000..b5c3fb3
--- /dev/null
+++ b/app/src/enhanced-animation.test.ts
@@ -0,0 +1,354 @@
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
+import { EnhancedAnimationManager, Easing, ParticleSystem } from './enhanced-animation'
+import { settingsManager } from './settings'
+
+// settingsManagerをモック化
+vi.mock('./settings', () => ({
+  settingsManager: {
+    get: vi.fn()
+  }
+}))
+
+const mockSettingsManager = settingsManager as any
+
+describe('Easing', () => {
+  describe('基本イージング関数', () => {
+    it('linear関数が正しく動作する', () => {
+      expect(Easing.linear(0)).toBe(0)
+      expect(Easing.linear(0.5)).toBe(0.5)
+      expect(Easing.linear(1)).toBe(1)
+    })
+
+    it('easeInQuad関数が正しく動作する', () => {
+      expect(Easing.easeInQuad(0)).toBe(0)
+      expect(Easing.easeInQuad(0.5)).toBe(0.25)
+      expect(Easing.easeInQuad(1)).toBe(1)
+    })
+
+    it('easeOutQuad関数が正しく動作する', () => {
+      expect(Easing.easeOutQuad(0)).toBe(0)
+      expect(Easing.easeOutQuad(0.5)).toBe(0.75)
+      expect(Easing.easeOutQuad(1)).toBe(1)
+    })
+
+    it('easeInOutQuad関数が正しく動作する', () => {
+      expect(Easing.easeInOutQuad(0)).toBe(0)
+      expect(Easing.easeInOutQuad(1)).toBe(1)
+      const midValue = Easing.easeInOutQuad(0.5)
+      expect(midValue).toBeCloseTo(0.5, 5)
+    })
+  })
+
+  describe('高度なイージング関数', () => {
+    it('easeOutBounce関数が正しく動作する', () => {
+      expect(Easing.easeOutBounce(0)).toBe(0)
+      expect(Easing.easeOutBounce(1)).toBe(1)
+      const bounceValue = Easing.easeOutBounce(0.5)
+      expect(bounceValue).toBeGreaterThan(0)
+      expect(bounceValue).toBeLessThan(1)
+    })
+
+    it('easeOutElastic関数が境界値で正しく動作する', () => {
+      expect(Easing.easeOutElastic(0)).toBe(0)
+      expect(Easing.easeOutElastic(1)).toBe(1)
+    })
+  })
+})
+
+describe('ParticleSystem', () => {
+  let particleSystem: ParticleSystem
+
+  beforeEach(() => {
+    particleSystem = new ParticleSystem()
+  })
+
+  it('パーティクルシステムを作成できる', () => {
+    expect(particleSystem).toBeInstanceOf(ParticleSystem)
+  })
+
+  it('バーストエフェクトを作成できる', () => {
+    particleSystem.createBurstEffect(100, 100, '#ff0000', 5)
+    
+    // プライベートメンバにアクセスするための型キャスト
+    const particles = (particleSystem as any).particles
+    expect(particles.length).toBe(5)
+    
+    particles.forEach((particle: any) => {
+      expect(particle.x).toBe(100)
+      expect(particle.y).toBe(100)
+      expect(particle.color).toBe('#ff0000')
+      expect(particle.life).toBe(1.0)
+    })
+  })
+
+  it('チェーンエフェクトを作成できる', () => {
+    particleSystem.createChainEffect(150, 150, 3)
+    
+    const particles = (particleSystem as any).particles
+    expect(particles.length).toBeGreaterThan(15) // 基本数 + チェーンレベルボーナス
+  })
+
+  it('パーティクルが時間経過で更新される', () => {
+    particleSystem.createBurstEffect(100, 100, '#ff0000', 3)
+    
+    const particlesBefore = (particleSystem as any).particles.length
+    expect(particlesBefore).toBe(3)
+    
+    // 複数回更新してパーティクルを消費
+    for (let i = 0; i < 100; i++) {
+      particleSystem.update()
+    }
+    
+    const particlesAfter = (particleSystem as any).particles.length
+    expect(particlesAfter).toBeLessThan(particlesBefore)
+  })
+
+  it('パーティクルをクリアできる', () => {
+    particleSystem.createBurstEffect(100, 100, '#ff0000', 10)
+    expect((particleSystem as any).particles.length).toBe(10)
+    
+    particleSystem.clear()
+    expect((particleSystem as any).particles.length).toBe(0)
+  })
+})
+
+describe('EnhancedAnimationManager', () => {
+  let animationManager: EnhancedAnimationManager
+
+  beforeEach(() => {
+    mockSettingsManager.get.mockReturnValue(true) // アニメーション有効
+    animationManager = new EnhancedAnimationManager()
+    vi.useFakeTimers()
+  })
+
+  afterEach(() => {
+    vi.useRealTimers()
+    vi.clearAllMocks()
+  })
+
+  it('EnhancedAnimationManagerを作成できる', () => {
+    expect(animationManager).toBeInstanceOf(EnhancedAnimationManager)
+  })
+
+  it('基本アニメーションを作成できる', () => {
+    const animId = animationManager.createAnimation(
+      'move',
+      { x: 0, y: 0 },
+      { x: 100, y: 100 },
+      { duration: 1000, easing: Easing.linear }
+    )
+    
+    expect(animId).toBeTruthy()
+    expect(animationManager.getActiveAnimationCount()).toBe(1)
+  })
+
+  it('ぷよ移動アニメーションを作成できる', () => {
+    const animId = animationManager.animatePuyoMove('puyo1', 0, 0, 2, 3)
+    
+    expect(animId).toBeTruthy()
+    expect(animationManager.getActiveAnimationCount()).toBe(1)
+    
+    const animation = animationManager.getAnimation(animId)
+    expect(animation).toBeDefined()
+    expect(animation!.type).toBe('move')
+    expect(animation!.from).toEqual({ x: 0, y: 0 })
+    expect(animation!.to).toEqual({ x: 2, y: 3 })
+  })
+
+  it('ぷよ回転アニメーションを作成できる', () => {
+    const animId = animationManager.animatePuyoRotation('puyo1', 0, Math.PI / 2)
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('rotate')
+    expect(animation!.from.angle).toBe(0)
+    expect(animation!.to.angle).toBe(Math.PI / 2)
+  })
+
+  it('ぷよ落下アニメーションを作成できる', () => {
+    const animId = animationManager.animatePuyoDrop('puyo1', 0, 10, true)
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('drop')
+    expect(animation!.from.y).toBe(0)
+    expect(animation!.to.y).toBe(10)
+  })
+
+  it('ぷよ消去アニメーションを作成できる', () => {
+    const animId = animationManager.animatePuyoErase('puyo1', 50, 50, '#ff0000', 2)
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('erase')
+    expect(animation!.from.scale).toBe(1.0)
+    expect(animation!.to.scale).toBe(1.8)
+  })
+
+  it('チェーンアニメーションを作成できる', () => {
+    const animId = animationManager.animateChain(100, 100, 3)
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('chain')
+  })
+
+  it('UIアニメーションを作成できる', () => {
+    const animId = animationManager.animateUI(
+      'element1',
+      { opacity: 0, scale: 0.5 },
+      { opacity: 1, scale: 1.0 },
+      500
+    )
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('ui')
+    expect(animation!.config.duration).toBe(500)
+  })
+
+  it('スコアポップアップアニメーションを作成できる', () => {
+    const animId = animationManager.animateScorePopup(200, 200, 1000, '#ffff00')
+    
+    expect(animId).toBeTruthy()
+    const animation = animationManager.getAnimation(animId)
+    expect(animation!.type).toBe('ui')
+    expect(animation!.from.x).toBe(200)
+    expect(animation!.from.y).toBe(200)
+  })
+
+  it('アニメーションが時間経過で更新される', () => {
+    const animId = animationManager.createAnimation(
+      'move',
+      { x: 0 },
+      { x: 100 },
+      { duration: 1000, easing: Easing.linear }
+    )
+    
+    const animation = animationManager.getAnimation(animId)!
+    expect(animation.current.x).toBe(0)
+    
+    // 500ms進める
+    vi.advanceTimersByTime(500)
+    animationManager.update()
+    
+    expect(animation.current.x).toBe(50) // 線形補間で中間値
+  })
+
+  it('アニメーション完了時にコールバックが呼ばれる', () => {
+    const onComplete = vi.fn()
+    
+    const animId = animationManager.createAnimation(
+      'move',
+      { x: 0 },
+      { x: 100 },
+      { duration: 1000, easing: Easing.linear }
+    )
+    
+    const animation = animationManager.getAnimation(animId)!
+    animation.onComplete = onComplete
+    
+    // アニメーション完了まで進める
+    vi.advanceTimersByTime(1000)
+    animationManager.update()
+    
+    expect(onComplete).toHaveBeenCalled()
+    expect(animationManager.getActiveAnimationCount()).toBe(0)
+  })
+
+  it('特定タイプのアニメーションを停止できる', () => {
+    animationManager.animatePuyoMove('puyo1', 0, 0, 10, 10)
+    animationManager.animatePuyoRotation('puyo2', 0, Math.PI)
+    animationManager.animateChain(100, 100, 1)
+    
+    expect(animationManager.getActiveAnimationCount()).toBe(3)
+    
+    animationManager.stopAnimationsByType('move')
+    expect(animationManager.getActiveAnimationCount()).toBe(2)
+  })
+
+  it('全てのアニメーションを停止できる', () => {
+    animationManager.animatePuyoMove('puyo1', 0, 0, 10, 10)
+    animationManager.animateChain(100, 100, 1)
+    
+    expect(animationManager.getActiveAnimationCount()).toBe(2)
+    
+    animationManager.stopAllAnimations()
+    expect(animationManager.getActiveAnimationCount()).toBe(0)
+  })
+
+  it('アニメーション無効時は処理をスキップする', () => {
+    mockSettingsManager.get.mockReturnValue(false) // アニメーション無効
+    
+    const animId = animationManager.createAnimation(
+      'move',
+      { x: 0 },
+      { x: 100 },
+      { duration: 1000, easing: Easing.linear }
+    )
+    
+    vi.advanceTimersByTime(500)
+    animationManager.update() // 無効のため更新されない
+    
+    const animation = animationManager.getAnimation(animId)!
+    expect(animation.current.x).toBe(0) // 初期値のまま
+  })
+
+  it('パフォーマンス統計を取得できる', () => {
+    animationManager.animatePuyoMove('puyo1', 0, 0, 10, 10)
+    animationManager.animateChain(100, 100, 2)
+    
+    const stats = animationManager.getPerformanceStats()
+    
+    expect(stats.activeAnimations).toBe(2)
+    expect(stats.activeParticles).toBeGreaterThan(0) // チェーンエフェクトでパーティクル生成
+    expect(stats.memoryUsage).toBeGreaterThan(0)
+  })
+})
+
+// キャンバス描画のモック
+const mockCanvas = {
+  getContext: () => ({
+    save: vi.fn(),
+    restore: vi.fn(),
+    globalAlpha: 1,
+    fillStyle: '',
+    strokeStyle: '',
+    beginPath: vi.fn(),
+    arc: vi.fn(),
+    fill: vi.fn(),
+    stroke: vi.fn(),
+    textAlign: '',
+    font: '',
+    fillText: vi.fn()
+  })
+}
+
+describe('描画機能', () => {
+  let animationManager: EnhancedAnimationManager
+  let mockCtx: any
+
+  beforeEach(() => {
+    mockSettingsManager.get.mockReturnValue(true)
+    animationManager = new EnhancedAnimationManager()
+    mockCtx = mockCanvas.getContext()
+  })
+
+  it('パーティクルシステムが描画される', () => {
+    const particleSystem = (animationManager as any).particles
+    particleSystem.createBurstEffect(100, 100, '#ff0000', 3)
+    
+    animationManager.render(mockCtx)
+    
+    expect(mockCtx.save).toHaveBeenCalled()
+    expect(mockCtx.restore).toHaveBeenCalled()
+  })
+
+  it('アニメーション無効時は描画をスキップする', () => {
+    mockSettingsManager.get.mockReturnValue(false)
+    
+    animationManager.render(mockCtx)
+    
+    expect(mockCtx.save).not.toHaveBeenCalled()
+  })
+})
\ No newline at end of file
diff --git a/app/src/enhanced-animation.ts b/app/src/enhanced-animation.ts
new file mode 100644
index 0000000..311ee63
--- /dev/null
+++ b/app/src/enhanced-animation.ts
@@ -0,0 +1,494 @@
+// 拡張アニメーションシステム
+import { settingsManager } from './settings'
+
+export interface AnimationConfig {
+  duration: number
+  easing: EasingFunction
+  delay?: number
+  repeat?: number
+  yoyo?: boolean
+  onComplete?: () => void
+}
+
+export type EasingFunction = (t: number) => number
+
+export class Easing {
+  // 基本イージング関数
+  static linear(t: number): number {
+    return t
+  }
+
+  static easeInQuad(t: number): number {
+    return t * t
+  }
+
+  static easeOutQuad(t: number): number {
+    return t * (2 - t)
+  }
+
+  static easeInOutQuad(t: number): number {
+    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
+  }
+
+  static easeInCubic(t: number): number {
+    return t * t * t
+  }
+
+  static easeOutCubic(t: number): number {
+    return --t * t * t + 1
+  }
+
+  static easeInOutCubic(t: number): number {
+    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
+  }
+
+  static easeInBounce(t: number): number {
+    return 1 - Easing.easeOutBounce(1 - t)
+  }
+
+  static easeOutBounce(t: number): number {
+    if (t < 1 / 2.75) {
+      return 7.5625 * t * t
+    } else if (t < 2 / 2.75) {
+      return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
+    } else if (t < 2.5 / 2.75) {
+      return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
+    } else {
+      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
+    }
+  }
+
+  static easeInElastic(t: number): number {
+    if (t === 0) return 0
+    if (t === 1) return 1
+    return -(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI))
+  }
+
+  static easeOutElastic(t: number): number {
+    if (t === 0) return 0
+    if (t === 1) return 1
+    return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1
+  }
+}
+
+export interface EnhancedAnimationState {
+  id: string
+  type: 'move' | 'rotate' | 'drop' | 'erase' | 'chain' | 'particle' | 'ui'
+  startTime: number
+  config: AnimationConfig
+  from: Record<string, number>
+  to: Record<string, number>
+  current: Record<string, number>
+  isActive: boolean
+  onComplete?: () => void
+  onUpdate?: (state: EnhancedAnimationState) => void
+}
+
+export class ParticleSystem {
+  private particles: Array<{
+    id: string
+    x: number
+    y: number
+    vx: number
+    vy: number
+    life: number
+    maxLife: number
+    color: string
+    size: number
+    decay: number
+  }> = []
+  
+  private nextParticleId = 0
+
+  createBurstEffect(x: number, y: number, color: string, count: number = 10): void {
+    for (let i = 0; i < count; i++) {
+      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5
+      const speed = 2 + Math.random() * 3
+      
+      this.particles.push({
+        id: `particle_${this.nextParticleId++}`,
+        x,
+        y,
+        vx: Math.cos(angle) * speed,
+        vy: Math.sin(angle) * speed,
+        life: 1.0,
+        maxLife: 1.0,
+        color,
+        size: 3 + Math.random() * 4,
+        decay: 0.02 + Math.random() * 0.02
+      })
+    }
+  }
+
+  createChainEffect(x: number, y: number, chainLevel: number): void {
+    const colors = ['#ffff44', '#ff8844', '#ff4488', '#8844ff', '#44ff88']
+    const color = colors[Math.min(chainLevel - 1, colors.length - 1)]
+    const count = Math.min(15 + chainLevel * 3, 30)
+    
+    this.createBurstEffect(x, y, color, count)
+    
+    // 追加のスパークル効果
+    for (let i = 0; i < chainLevel * 2; i++) {
+      setTimeout(() => {
+        const offsetX = (Math.random() - 0.5) * 40
+        const offsetY = (Math.random() - 0.5) * 40
+        this.createBurstEffect(x + offsetX, y + offsetY, color, 5)
+      }, i * 100)
+    }
+  }
+
+  update(): void {
+    this.particles = this.particles.filter(particle => {
+      particle.x += particle.vx
+      particle.y += particle.vy
+      particle.vy += 0.1 // 重力効果
+      particle.life -= particle.decay
+      particle.vx *= 0.98 // 空気抵抗
+      particle.vy *= 0.98
+      
+      return particle.life > 0
+    })
+  }
+
+  render(ctx: CanvasRenderingContext2D): void {
+    this.particles.forEach(particle => {
+      ctx.save()
+      ctx.globalAlpha = particle.life
+      ctx.fillStyle = particle.color
+      ctx.beginPath()
+      ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2)
+      ctx.fill()
+      ctx.restore()
+    })
+  }
+
+  clear(): void {
+    this.particles.length = 0
+  }
+}
+
+export class EnhancedAnimationManager {
+  private animations: Map<string, EnhancedAnimationState> = new Map()
+  private particles: ParticleSystem = new ParticleSystem()
+  private nextAnimationId = 0
+
+  // アニメーション作成
+  createAnimation(
+    type: EnhancedAnimationState['type'],
+    from: Record<string, number>,
+    to: Record<string, number>,
+    config: AnimationConfig
+  ): string {
+    const id = `anim_${this.nextAnimationId++}_${type}`
+    
+    const animation: EnhancedAnimationState = {
+      id,
+      type,
+      startTime: Date.now() + (config.delay || 0),
+      config,
+      from: { ...from },
+      to: { ...to },
+      current: { ...from },
+      isActive: true
+    }
+
+    this.animations.set(id, animation)
+    return id
+  }
+
+  // ぷよ移動アニメーション
+  animatePuyoMove(
+    _puyoId: string,
+    fromX: number,
+    fromY: number,
+    toX: number,
+    toY: number
+  ): string {
+    return this.createAnimation(
+      'move',
+      { x: fromX, y: fromY },
+      { x: toX, y: toY },
+      {
+        duration: 150,
+        easing: Easing.easeOutQuad
+      }
+    )
+  }
+
+  // ぷよ回転アニメーション
+  animatePuyoRotation(
+    _puyoId: string,
+    fromAngle: number,
+    toAngle: number
+  ): string {
+    return this.createAnimation(
+      'rotate',
+      { angle: fromAngle },
+      { angle: toAngle },
+      {
+        duration: 200,
+        easing: Easing.easeInOutCubic
+      }
+    )
+  }
+
+  // ぷよ落下アニメーション
+  animatePuyoDrop(
+    _puyoId: string,
+    fromY: number,
+    toY: number,
+    bounceEffect: boolean = true
+  ): string {
+    const easing = bounceEffect ? Easing.easeOutBounce : Easing.easeInQuad
+    
+    return this.createAnimation(
+      'drop',
+      { y: fromY, scale: 1.0 },
+      { y: toY, scale: 1.0 },
+      {
+        duration: 300 + Math.abs(toY - fromY) * 10,
+        easing
+      }
+    )
+  }
+
+  // ぷよ消去アニメーション
+  animatePuyoErase(
+    _puyoId: string,
+    x: number,
+    y: number,
+    _color: string,
+    chainLevel: number = 1
+  ): string {
+    // パーティクル効果作成
+    this.particles.createChainEffect(x, y, chainLevel)
+    
+    return this.createAnimation(
+      'erase',
+      { scale: 1.0, alpha: 1.0, rotation: 0 },
+      { scale: 1.8, alpha: 0.0, rotation: Math.PI * 2 },
+      {
+        duration: 400,
+        easing: Easing.easeOutCubic,
+        onComplete: () => {
+          // 消去完了時の処理
+        }
+      }
+    )
+  }
+
+  // チェーンアニメーション
+  animateChain(
+    centerX: number,
+    centerY: number,
+    chainLevel: number
+  ): string {
+    // 連鎖レベルに応じたエフェクト
+    this.particles.createChainEffect(centerX, centerY, chainLevel)
+    
+    return this.createAnimation(
+      'chain',
+      { scale: 0.5, alpha: 1.0, shockwave: 0 },
+      { scale: 2.0, alpha: 0.0, shockwave: 50 },
+      {
+        duration: 800 + chainLevel * 200,
+        easing: Easing.easeOutElastic
+      }
+    )
+  }
+
+  // UI要素のアニメーション
+  animateUI(
+    _elementId: string,
+    properties: Record<string, number>,
+    targetProperties: Record<string, number>,
+    duration: number = 300
+  ): string {
+    return this.createAnimation(
+      'ui',
+      properties,
+      targetProperties,
+      {
+        duration,
+        easing: Easing.easeOutQuad
+      }
+    )
+  }
+
+  // スコア表示アニメーション
+  animateScorePopup(
+    x: number,
+    y: number,
+    _score: number,
+    _color: string = '#ffff44'
+  ): string {
+    return this.createAnimation(
+      'ui',
+      { x, y: y, scale: 0.5, alpha: 1.0 },
+      { x, y: y - 50, scale: 1.2, alpha: 0.0 },
+      {
+        duration: 1000,
+        easing: Easing.easeOutCubic
+      }
+    )
+  }
+
+  // アニメーション更新
+  update(): void {
+    if (!settingsManager.get('enableAnimations')) {
+      return // アニメーション無効時はスキップ
+    }
+
+    const now = Date.now()
+    
+    this.animations.forEach((animation, id) => {
+      if (!animation.isActive || now < animation.startTime) {
+        return
+      }
+
+      const elapsed = now - animation.startTime
+      const progress = Math.min(elapsed / animation.config.duration, 1)
+      const easedProgress = animation.config.easing(progress)
+
+      // プロパティ値の補間
+      for (const [key, startValue] of Object.entries(animation.from)) {
+        const endValue = animation.to[key]
+        if (endValue !== undefined) {
+          animation.current[key] = startValue + (endValue - startValue) * easedProgress
+        }
+      }
+
+      // 更新コールバック実行
+      if (animation.onUpdate) {
+        animation.onUpdate(animation)
+      }
+
+      // アニメーション完了チェック
+      if (progress >= 1) {
+        if (animation.config.yoyo && animation.config.repeat !== 0) {
+          // ヨーヨー効果
+          const temp = animation.from
+          animation.from = animation.to
+          animation.to = temp
+          animation.startTime = now
+          
+          if (animation.config.repeat !== undefined && animation.config.repeat > 0) {
+            animation.config.repeat--
+          }
+        } else if (animation.config.repeat && animation.config.repeat > 0) {
+          // リピート
+          animation.config.repeat--
+          animation.startTime = now
+          animation.current = { ...animation.from }
+        } else {
+          // アニメーション完了
+          animation.isActive = false
+          if (animation.onComplete) {
+            animation.onComplete()
+          }
+          this.animations.delete(id)
+        }
+      }
+    })
+
+    // パーティクルシステム更新
+    this.particles.update()
+  }
+
+  // アニメーション描画
+  render(ctx: CanvasRenderingContext2D): void {
+    if (!settingsManager.get('enableAnimations')) {
+      return
+    }
+
+    // パーティクル描画
+    this.particles.render(ctx)
+
+    // その他のアニメーション効果描画
+    this.animations.forEach(animation => {
+      this.renderAnimation(ctx, animation)
+    })
+  }
+
+  private renderAnimation(ctx: CanvasRenderingContext2D, animation: EnhancedAnimationState): void {
+    if (!animation.isActive) return
+
+    ctx.save()
+
+    switch (animation.type) {
+      case 'chain':
+        this.renderChainEffect(ctx, animation)
+        break
+      case 'ui':
+        this.renderUIEffect(ctx, animation)
+        break
+      // 他のアニメーションタイプも必要に応じて実装
+    }
+
+    ctx.restore()
+  }
+
+  private renderChainEffect(ctx: CanvasRenderingContext2D, animation: EnhancedAnimationState): void {
+    const { scale, alpha, shockwave } = animation.current
+    
+    if (shockwave > 0) {
+      ctx.globalAlpha = alpha * 0.3
+      ctx.strokeStyle = '#ffffff'
+      ctx.lineWidth = 3
+      ctx.beginPath()
+      ctx.arc(200, 300, shockwave, 0, Math.PI * 2) // 仮の中心座標
+      ctx.stroke()
+    }
+  }
+
+  private renderUIEffect(ctx: CanvasRenderingContext2D, animation: EnhancedAnimationState): void {
+    const { x, y, scale, alpha } = animation.current
+    
+    if (x !== undefined && y !== undefined) {
+      ctx.globalAlpha = alpha || 1.0
+      ctx.font = `${Math.round(16 * (scale || 1.0))}px Arial`
+      ctx.fillStyle = '#ffff44'
+      ctx.textAlign = 'center'
+      ctx.fillText('+1000', x, y) // 仮のスコア表示
+    }
+  }
+
+  // アニメーション取得
+  getAnimation(id: string): EnhancedAnimationState | undefined {
+    return this.animations.get(id)
+  }
+
+  // 特定タイプのアニメーション停止
+  stopAnimationsByType(type: EnhancedAnimationState['type']): void {
+    this.animations.forEach((animation, id) => {
+      if (animation.type === type) {
+        animation.isActive = false
+        this.animations.delete(id)
+      }
+    })
+  }
+
+  // 全アニメーション停止
+  stopAllAnimations(): void {
+    this.animations.clear()
+    this.particles.clear()
+  }
+
+  // アニメーション数取得
+  getActiveAnimationCount(): number {
+    return this.animations.size
+  }
+
+  // パフォーマンス統計
+  getPerformanceStats(): {
+    activeAnimations: number
+    activeParticles: number
+    memoryUsage: number
+  } {
+    return {
+      activeAnimations: this.animations.size,
+      activeParticles: this.particles['particles'].length,
+      memoryUsage: this.animations.size * 200 + this.particles['particles'].length * 50 // 概算
+    }
+  }
+}
\ No newline at end of file
diff --git a/app/src/input.ts b/app/src/input.ts
index 4a55cee..7db1515 100644
--- a/app/src/input.ts
+++ b/app/src/input.ts
@@ -1,4 +1,5 @@
 import { Game } from './game'
+import { soundManager, SoundType } from './audio'
 
 export class InputHandler {
   private keyPressed: Set<string> = new Set()
@@ -76,13 +77,19 @@ export class InputHandler {
 
     switch (key) {
       case 'ArrowLeft':
-        player.moveLeft()
+        if (player.moveLeft()) {
+          soundManager.playSound(SoundType.Move)
+        }
         break
       case 'ArrowRight':
-        player.moveRight()
+        if (player.moveRight()) {
+          soundManager.playSound(SoundType.Move)
+        }
         break
       case 'ArrowUp':
-        player.rotateRight()
+        if (player.rotateRight()) {
+          soundManager.playSound(SoundType.Rotate)
+        }
         break
       case 'ArrowDown':
         this.forcePlayerUpdate()
@@ -92,11 +99,15 @@ export class InputHandler {
         break
       case 'z':
       case 'Z':
-        player.rotateLeft()
+        if (player.rotateLeft()) {
+          soundManager.playSound(SoundType.Rotate)
+        }
         break
       case 'x':
       case 'X':
-        player.rotateRight()
+        if (player.rotateRight()) {
+          soundManager.playSound(SoundType.Rotate)
+        }
         break
     }
   }
@@ -111,10 +122,18 @@ export class InputHandler {
 
     // 一気落下処理
     let moved = true
+    let totalMoved = 0
+    
     while (moved && !player.isPlaced()) {
       const currentY = player.getCurrentPair().getY()
       player.update()
       moved = player.getCurrentPair().getY() > currentY
+      if (moved) totalMoved++
+    }
+    
+    // 落下音再生（実際に移動した場合のみ）
+    if (totalMoved > 0) {
+      soundManager.playSound(SoundType.Land)
     }
   }
 
diff --git a/app/src/main.ts b/app/src/main.ts
index 2ebcde6..b7cb972 100644
--- a/app/src/main.ts
+++ b/app/src/main.ts
@@ -3,6 +3,10 @@ import { GameRenderer } from './renderer'
 import { InputHandler } from './input'
 import { PerformanceMonitor, DrawOptimizer } from './performance'
 import { globalErrorHandler, ErrorLevel, handleError, handleRenderingError, handleGameStateError } from './errorhandler'
+import { soundManager, SoundType, SoundPresets } from './audio'
+import { SettingsUI } from './settingsUI'
+import { settingsManager } from './settings'
+import { statisticsManager } from './statistics'
 
 class PuyoPuyoWebApp {
   private game: Game
@@ -12,6 +16,7 @@ class PuyoPuyoWebApp {
   private isRunning: boolean = false
   private performanceMonitor: PerformanceMonitor
   private drawOptimizer: DrawOptimizer
+  private settingsUI: SettingsUI
 
   // UI要素
   private scoreDisplay: HTMLElement
@@ -19,11 +24,21 @@ class PuyoPuyoWebApp {
   private statusDisplay: HTMLElement
   private startButton: HTMLElement
   private resetButton: HTMLElement
+  private settingsButton: HTMLElement
   private performanceDisplay?: HTMLElement
+  
+  // 統計表示要素
+  private statsGamesDisplay: HTMLElement
+  private statsHighDisplay: HTMLElement
+  private statsAvgDisplay: HTMLElement
+  private statsTimeDisplay: HTMLElement
 
   constructor() {
     try {
       this.game = new Game()
+      
+      // サウンドシステム初期化
+      this.initializeAudio()
 
       // キャンバス要素取得
       const canvas = document.getElementById('game-canvas') as HTMLCanvasElement
@@ -46,6 +61,7 @@ class PuyoPuyoWebApp {
     this.inputHandler = new InputHandler(this.game)
     this.performanceMonitor = new PerformanceMonitor()
     this.drawOptimizer = new DrawOptimizer()
+    this.settingsUI = new SettingsUI()
 
     // UI要素取得
     this.scoreDisplay = document.getElementById('score-display')!
@@ -53,10 +69,19 @@ class PuyoPuyoWebApp {
     this.statusDisplay = document.getElementById('status-display')!
     this.startButton = document.getElementById('start-button')!
     this.resetButton = document.getElementById('reset-button')!
+    this.settingsButton = document.getElementById('settings-button')!
     this.performanceDisplay = document.getElementById('performance-display') || undefined
+    
+    // 統計表示要素取得
+    this.statsGamesDisplay = document.getElementById('stats-games')!
+    this.statsHighDisplay = document.getElementById('stats-high')!
+    this.statsAvgDisplay = document.getElementById('stats-avg')!
+    this.statsTimeDisplay = document.getElementById('stats-time')!
 
       this.setupEventListeners()
       this.setupErrorHandlers()
+      this.setupGameEventListeners()
+      this.setupSettingsIntegration()
       this.updateUI()
     } catch (error) {
       handleError(error instanceof Error ? error : new Error(String(error)), 'Initialization')
@@ -72,6 +97,10 @@ class PuyoPuyoWebApp {
     this.resetButton.addEventListener('click', () => {
       this.resetGame()
     })
+
+    this.settingsButton.addEventListener('click', () => {
+      this.settingsUI.open()
+    })
   }
 
   startGame(): void {
@@ -80,6 +109,13 @@ class PuyoPuyoWebApp {
     try {
       this.game.initialize()
       this.isRunning = true
+      
+      // 統計セッション開始
+      statisticsManager.startSession(1) // レベル1で開始（将来的には設定可能）
+      
+      // BGM開始
+      soundManager.startBGM()
+      
       this.gameLoop = requestAnimationFrame(() => this.tick())
     } catch (error) {
       handleGameStateError(`ゲーム開始エラー: ${error}`, 'GameStart')
@@ -107,6 +143,16 @@ class PuyoPuyoWebApp {
       cancelAnimationFrame(this.gameLoop)
       this.gameLoop = null
     }
+    
+    // 統計セッション終了
+    if (statisticsManager.getCurrentSession()) {
+      const finalScore = this.game.getScore()
+      const isCompleted = this.game.getMode() !== 'gameOver'
+      statisticsManager.endSession(finalScore, isCompleted)
+    }
+    
+    // BGM停止
+    soundManager.stopBGM()
   }
 
   private tick(): void {
@@ -118,6 +164,9 @@ class PuyoPuyoWebApp {
 
       // ゲーム更新
       this.game.update()
+      
+      // セッション統計の更新
+      this.updateSessionStatistics()
 
       // 描画最適化判定
       const gameState = this.getGameStateHash()
@@ -205,6 +254,9 @@ class PuyoPuyoWebApp {
       const status = this.performanceMonitor.isPerformanceGood() ? '✅' : '⚠️'
       this.performanceDisplay.textContent = `${fps.toFixed(1)} FPS ${status}`
     }
+    
+    // 統計表示更新
+    this.updateStatisticsDisplay()
   }
 
   private handleGameOver(): void {
@@ -222,6 +274,10 @@ class PuyoPuyoWebApp {
   cleanup(): void {
     this.stopGame()
     this.inputHandler.cleanup()
+    
+    // サウンド停止・リソース解放
+    soundManager.destroy()
+    
     // 最終パフォーマンスログ
     console.log('📊 Final Performance Report:')
     this.performanceMonitor.logPerformance()
@@ -303,6 +359,146 @@ class PuyoPuyoWebApp {
       alert(message)
     }
   }
+
+  private async initializeAudio(): Promise<void> {
+    try {
+      await soundManager.initialize()
+    } catch (error) {
+      console.warn('サウンドシステムの初期化に失敗しました:', error)
+    }
+  }
+
+  private setupGameEventListeners(): void {
+    // ゲームイベントに応じたサウンド再生
+    // 注意: この実装は簡略化されています。実際にはゲームクラスからイベントを受け取る設計が必要
+    
+    // ユーザージェスチャー後のAudioContext再開
+    document.addEventListener('click', async () => {
+      await soundManager.resumeAudioContext()
+    }, { once: true })
+
+    document.addEventListener('keydown', async () => {
+      await soundManager.resumeAudioContext()
+    }, { once: true })
+  }
+
+  // ゲームイベントハンドラー（将来の拡張用）
+  onPuyoMove(): void {
+    soundManager.playSound(SoundType.Move)
+  }
+
+  onPuyoRotate(): void {
+    soundManager.playSound(SoundType.Rotate)
+  }
+
+  onPuyoLand(): void {
+    soundManager.playSound(SoundType.Land)
+  }
+
+  onPuyoErase(count: number): void {
+    soundManager.playSound(SoundType.Erase, { pitch: 1.0 + (count - 4) * 0.1 })
+  }
+
+  onChain(chainCount: number): void {
+    soundManager.playSound(SoundType.Chain, { chain: chainCount })
+  }
+
+  onGameOver(): void {
+    soundManager.playSound(SoundType.GameOver)
+  }
+
+  private setupSettingsIntegration(): void {
+    // 設定変更の監視と適用
+    settingsManager.onChange('masterVolume', (volume) => {
+      soundManager.setMasterVolume(volume)
+    })
+
+    settingsManager.onChange('soundEnabled', (enabled) => {
+      soundManager.setSoundEnabled(enabled)
+    })
+
+    settingsManager.onChange('bgmEnabled', (enabled) => {
+      soundManager.setBGMEnabled(enabled)
+      if (enabled && this.isRunning) {
+        soundManager.startBGM()
+      } else {
+        soundManager.stopBGM()
+      }
+    })
+
+    settingsManager.onChange('showFPS', (show) => {
+      if (this.performanceDisplay) {
+        this.performanceDisplay.style.display = show ? 'block' : 'none'
+      }
+    })
+
+    settingsManager.onChange('pauseOnFocusLoss', (pauseOnFocus) => {
+      if (pauseOnFocus) {
+        window.addEventListener('blur', this.handleFocusLoss)
+        window.addEventListener('focus', this.handleFocusGain)
+      } else {
+        window.removeEventListener('blur', this.handleFocusLoss)
+        window.removeEventListener('focus', this.handleFocusGain)
+      }
+    })
+
+    // 初期設定を適用
+    const currentSettings = settingsManager.getSettings()
+    soundManager.setMasterVolume(currentSettings.masterVolume)
+    soundManager.setSoundEnabled(currentSettings.soundEnabled)
+    soundManager.setBGMEnabled(currentSettings.bgmEnabled)
+    
+    if (this.performanceDisplay) {
+      this.performanceDisplay.style.display = currentSettings.showFPS ? 'block' : 'none'
+    }
+  }
+
+  private handleFocusLoss = () => {
+    if (this.isRunning && settingsManager.get('pauseOnFocusLoss')) {
+      this.stopGame()
+    }
+  }
+
+  private handleFocusGain = () => {
+    // フォーカス復帰時の処理（必要に応じて実装）
+  }
+
+  private updateSessionStatistics(): void {
+    // セッション中の統計を定期的に更新
+    if (statisticsManager.getCurrentSession()) {
+      const currentScore = this.game.getScore()
+      const combinationCount = this.game.getCombinationCount()
+      
+      statisticsManager.updateSessionStats({
+        score: currentScore,
+        chainsCount: combinationCount,
+        longestChain: combinationCount // 簡略化（実際にはより詳細な追跡が必要）
+      })
+    }
+  }
+
+  private updateStatisticsDisplay(): void {
+    const stats = statisticsManager.getStatistics()
+    const summary = statisticsManager.getStatisticsSummary()
+    
+    this.statsGamesDisplay.textContent = stats.totalGamesPlayed.toString()
+    this.statsHighDisplay.textContent = stats.highScore.toString()
+    this.statsAvgDisplay.textContent = Math.round(stats.averageScore).toString()
+    this.statsTimeDisplay.textContent = summary.totalPlayTime
+  }
+
+  private formatDuration(seconds: number): string {
+    if (seconds < 60) {
+      return `${seconds}秒`
+    } else if (seconds < 3600) {
+      const minutes = Math.floor(seconds / 60)
+      return `${minutes}分`
+    } else {
+      const hours = Math.floor(seconds / 3600)
+      const remainingMinutes = Math.floor((seconds % 3600) / 60)
+      return remainingMinutes > 0 ? `${hours}時間${remainingMinutes}分` : `${hours}時間`
+    }
+  }
 }
 
 // アプリケーション初期化
diff --git a/app/src/renderer.ts b/app/src/renderer.ts
index 0ce6040..069fce3 100644
--- a/app/src/renderer.ts
+++ b/app/src/renderer.ts
@@ -5,6 +5,7 @@ import { PuyoColor } from './puyo'
 import { Config } from './config'
 import { DrawOptimizer, RenderBatch } from './performance'
 import { AnimationManager } from './animation'
+import { EnhancedAnimationManager } from './enhanced-animation'
 
 export class GameRenderer {
   private cellSize: number = 32
@@ -18,6 +19,7 @@ export class GameRenderer {
   private drawOptimizer: DrawOptimizer = new DrawOptimizer()
   private renderBatch: RenderBatch = new RenderBatch()
   private animationManager: AnimationManager = new AnimationManager()
+  private enhancedAnimations: EnhancedAnimationManager = new EnhancedAnimationManager()
 
   constructor(
     private ctx: CanvasRenderingContext2D,
@@ -29,6 +31,7 @@ export class GameRenderer {
   render(game: Game): void {
     // アニメーション更新
     this.animationManager.update()
+    this.enhancedAnimations.update()
     
     // バッチ処理でレンダリング最適化
     this.renderBatch.addOperation(() => {
@@ -41,6 +44,7 @@ export class GameRenderer {
     this.renderBatch.addOperation(() => this.renderStage(game.getStageForRenderer()))
     this.renderBatch.addOperation(() => this.renderCurrentPair(game.getPlayerForRenderer()))
     this.renderBatch.addOperation(() => this.renderAnimations())
+    this.renderBatch.addOperation(() => this.renderEnhancedAnimations())
     this.renderBatch.addOperation(() => this.renderGrid(game.getConfigForRenderer()))
     this.renderBatch.addOperation(() => this.renderNextPuyo(game.getPlayerForRenderer()))
 
@@ -247,5 +251,31 @@ export class GameRenderer {
   // アニメーションクリア（ゲームリセット時など）
   clearAnimations(): void {
     this.animationManager.clear()
+    this.enhancedAnimations.stopAllAnimations()
+  }
+
+  private renderEnhancedAnimations(): void {
+    this.enhancedAnimations.render(this.ctx)
+  }
+
+  // 拡張アニメーション機能のAPI
+  public animatePuyoMove(puyoId: string, fromX: number, fromY: number, toX: number, toY: number): string {
+    return this.enhancedAnimations.animatePuyoMove(puyoId, fromX, fromY, toX, toY)
+  }
+
+  public animatePuyoErase(puyoId: string, x: number, y: number, color: string, chainLevel: number = 1): string {
+    return this.enhancedAnimations.animatePuyoErase(puyoId, x, y, color, chainLevel)
+  }
+
+  public animateChain(centerX: number, centerY: number, chainLevel: number): string {
+    return this.enhancedAnimations.animateChain(centerX, centerY, chainLevel)
+  }
+
+  public animateScorePopup(x: number, y: number, score: number, color?: string): string {
+    return this.enhancedAnimations.animateScorePopup(x, y, score, color)
+  }
+
+  public getAnimationStats(): { activeAnimations: number; activeParticles: number; memoryUsage: number } {
+    return this.enhancedAnimations.getPerformanceStats()
   }
 }
diff --git a/app/src/settings.test.ts b/app/src/settings.test.ts
new file mode 100644
index 0000000..136ff99
--- /dev/null
+++ b/app/src/settings.test.ts
@@ -0,0 +1,283 @@
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
+import { SettingsManager, SettingsPresets, GameSettings, KeyBindings } from './settings'
+
+// localStorage のモック化
+const localStorageMock = {
+  getItem: vi.fn(),
+  setItem: vi.fn(),
+  removeItem: vi.fn(),
+  clear: vi.fn()
+}
+
+Object.defineProperty(window, 'localStorage', {
+  value: localStorageMock
+})
+
+describe('SettingsManager', () => {
+  let settingsManager: SettingsManager
+  
+  beforeEach(() => {
+    vi.clearAllMocks()
+    localStorageMock.getItem.mockReturnValue(null)
+    settingsManager = new SettingsManager()
+  })
+
+  afterEach(() => {
+    vi.clearAllMocks()
+  })
+
+  describe('初期化', () => {
+    it('SettingsManagerを正常に作成できる', () => {
+      expect(settingsManager).toBeInstanceOf(SettingsManager)
+    })
+
+    it('デフォルト設定が正しく読み込まれる', () => {
+      const settings = settingsManager.getSettings()
+      expect(settings.masterVolume).toBe(0.7)
+      expect(settings.soundEnabled).toBe(true)
+      expect(settings.bgmEnabled).toBe(true)
+      expect(settings.fallSpeed).toBe(5)
+      expect(settings.showGrid).toBe(true)
+      expect(settings.showFPS).toBe(false)
+    })
+
+    it('保存済み設定が正しく読み込まれる', () => {
+      const savedSettings = {
+        masterVolume: 0.5,
+        soundEnabled: false,
+        fallSpeed: 8
+      }
+      localStorageMock.getItem.mockReturnValue(JSON.stringify(savedSettings))
+      
+      const manager = new SettingsManager()
+      const settings = manager.getSettings()
+      
+      expect(settings.masterVolume).toBe(0.5)
+      expect(settings.soundEnabled).toBe(false)
+      expect(settings.fallSpeed).toBe(8)
+      // デフォルト値とマージされることを確認
+      expect(settings.bgmEnabled).toBe(true)
+    })
+  })
+
+  describe('設定の取得と更新', () => {
+    it('個別設定を取得できる', () => {
+      expect(settingsManager.get('masterVolume')).toBe(0.7)
+      expect(settingsManager.get('soundEnabled')).toBe(true)
+    })
+
+    it('個別設定を更新できる', () => {
+      settingsManager.set('masterVolume', 0.5)
+      expect(settingsManager.get('masterVolume')).toBe(0.5)
+      expect(localStorageMock.setItem).toHaveBeenCalled()
+    })
+
+    it('複数設定を一括更新できる', () => {
+      const updates = {
+        masterVolume: 0.8,
+        soundEnabled: false,
+        fallSpeed: 7
+      }
+      
+      settingsManager.updateSettings(updates)
+      
+      expect(settingsManager.get('masterVolume')).toBe(0.8)
+      expect(settingsManager.get('soundEnabled')).toBe(false)
+      expect(settingsManager.get('fallSpeed')).toBe(7)
+    })
+  })
+
+  describe('変更通知システム', () => {
+    it('設定変更時にリスナーが呼ばれる', () => {
+      const listener = vi.fn()
+      settingsManager.onChange('masterVolume', listener)
+      
+      settingsManager.set('masterVolume', 0.5)
+      
+      expect(listener).toHaveBeenCalledWith(0.5, 0.7)
+    })
+
+    it('複数のリスナーが正しく呼ばれる', () => {
+      const listener1 = vi.fn()
+      const listener2 = vi.fn()
+      
+      settingsManager.onChange('masterVolume', listener1)
+      settingsManager.onChange('masterVolume', listener2)
+      
+      settingsManager.set('masterVolume', 0.9)
+      
+      expect(listener1).toHaveBeenCalledWith(0.9, 0.7)
+      expect(listener2).toHaveBeenCalledWith(0.9, 0.7)
+    })
+
+    it('リスナーを削除できる', () => {
+      const listener = vi.fn()
+      settingsManager.onChange('masterVolume', listener)
+      settingsManager.removeListener('masterVolume', listener)
+      
+      settingsManager.set('masterVolume', 0.6)
+      
+      expect(listener).not.toHaveBeenCalled()
+    })
+  })
+
+  describe('設定リセット', () => {
+    it('全設定をデフォルトに戻せる', () => {
+      settingsManager.updateSettings({
+        masterVolume: 0.3,
+        soundEnabled: false,
+        fallSpeed: 9
+      })
+      
+      settingsManager.resetToDefaults()
+      
+      expect(settingsManager.get('masterVolume')).toBe(0.7)
+      expect(settingsManager.get('soundEnabled')).toBe(true)
+      expect(settingsManager.get('fallSpeed')).toBe(5)
+    })
+
+    it('カテゴリ別リセットが正常に動作する', () => {
+      settingsManager.updateSettings({
+        masterVolume: 0.3,
+        soundEnabled: false,
+        fallSpeed: 9,
+        showGrid: false
+      })
+      
+      settingsManager.resetCategory('sound')
+      
+      expect(settingsManager.get('masterVolume')).toBe(0.7)
+      expect(settingsManager.get('soundEnabled')).toBe(true)
+      expect(settingsManager.get('fallSpeed')).toBe(9) // サウンド以外は変更されない
+    })
+  })
+
+  describe('キーバインド管理', () => {
+    it('有効なキーバインドを検証できる', () => {
+      expect(settingsManager.isValidKeyBinding('ArrowLeft')).toBe(true)
+      expect(settingsManager.isValidKeyBinding('a')).toBe(true)
+      expect(settingsManager.isValidKeyBinding(' ')).toBe(true)
+      expect(settingsManager.isValidKeyBinding('InvalidKey')).toBe(false)
+    })
+
+    it('キーバインド重複を検出できる', () => {
+      const conflict = settingsManager.hasKeyConflict('moveRight', 'ArrowLeft')
+      expect(conflict).toBe('moveLeft') // ArrowLeftは既にmoveLeftに割り当て済み
+      
+      const noConflict = settingsManager.hasKeyConflict('moveLeft', 'ArrowLeft')
+      expect(noConflict).toBe(null) // 同じアクションなので重複ではない
+    })
+
+    it('キーバインドを正しく更新できる', () => {
+      const success = settingsManager.updateKeyBinding('moveLeft', 'a')
+      expect(success).toBe(true)
+      expect(settingsManager.get('keyBindings').moveLeft).toBe('a')
+    })
+
+    it('無効なキーでキーバインド更新が失敗する', () => {
+      const success = settingsManager.updateKeyBinding('moveLeft', 'InvalidKey')
+      expect(success).toBe(false)
+    })
+
+    it('重複キーでキーバインド更新が失敗する', () => {
+      const success = settingsManager.updateKeyBinding('moveLeft', 'ArrowRight')
+      expect(success).toBe(false) // ArrowRightは既にmoveRightに使用されている
+    })
+  })
+
+  describe('設定の妥当性検証', () => {
+    it('正常な設定で検証が通る', () => {
+      const validation = settingsManager.validateSettings()
+      expect(validation.valid).toBe(true)
+      expect(validation.errors).toHaveLength(0)
+    })
+
+    it('無効な音量範囲でエラーになる', () => {
+      settingsManager.set('masterVolume', -0.1)
+      const validation = settingsManager.validateSettings()
+      expect(validation.valid).toBe(false)
+      expect(validation.errors).toContain('音量は0.0-1.0の範囲で設定してください')
+    })
+
+    it('無効な落下速度範囲でエラーになる', () => {
+      settingsManager.set('fallSpeed', 11)
+      const validation = settingsManager.validateSettings()
+      expect(validation.valid).toBe(false)
+      expect(validation.errors).toContain('落下速度は1-10の範囲で設定してください')
+    })
+  })
+
+  describe('設定のエクスポート・インポート', () => {
+    it('設定をJSONでエクスポートできる', () => {
+      const exported = settingsManager.exportSettings()
+      const parsed = JSON.parse(exported)
+      
+      expect(parsed.masterVolume).toBe(0.7)
+      expect(parsed.soundEnabled).toBe(true)
+    })
+
+    it('設定をJSONからインポートできる', () => {
+      const settingsJson = JSON.stringify({
+        masterVolume: 0.4,
+        soundEnabled: false,
+        fallSpeed: 8
+      })
+      
+      const success = settingsManager.importSettings(settingsJson)
+      
+      expect(success).toBe(true)
+      expect(settingsManager.get('masterVolume')).toBe(0.4)
+      expect(settingsManager.get('soundEnabled')).toBe(false)
+      expect(settingsManager.get('fallSpeed')).toBe(8)
+    })
+
+    it('不正なJSONでインポートが失敗する', () => {
+      const success = settingsManager.importSettings('invalid json')
+      expect(success).toBe(false)
+    })
+  })
+})
+
+describe('SettingsPresets', () => {
+  describe('プリセット設定', () => {
+    it('初心者向け設定が正しい', () => {
+      const preset = SettingsPresets.getBeginnerSettings()
+      expect(preset.fallSpeed).toBe(3)
+      expect(preset.showGrid).toBe(true)
+      expect(preset.showGhost).toBe(true)
+    })
+
+    it('上級者向け設定が正しい', () => {
+      const preset = SettingsPresets.getAdvancedSettings()
+      expect(preset.fallSpeed).toBe(8)
+      expect(preset.showGrid).toBe(false)
+      expect(preset.showGhost).toBe(false)
+      expect(preset.showFPS).toBe(true)
+    })
+
+    it('サイレント設定が正しい', () => {
+      const preset = SettingsPresets.getSilentSettings()
+      expect(preset.masterVolume).toBe(0.0)
+      expect(preset.soundEnabled).toBe(false)
+      expect(preset.bgmEnabled).toBe(false)
+    })
+  })
+
+  describe('キーバインドプリセット', () => {
+    it('コンパクトバインドが正しい', () => {
+      const bindings = SettingsPresets.getCompactBindings()
+      expect(bindings.moveLeft).toBe('a')
+      expect(bindings.moveRight).toBe('d')
+      expect(bindings.rotateLeft).toBe('s')
+      expect(bindings.rotateRight).toBe('w')
+    })
+
+    it('アローキーバインドが正しい', () => {
+      const bindings = SettingsPresets.getArrowBindings()
+      expect(bindings.moveLeft).toBe('ArrowLeft')
+      expect(bindings.moveRight).toBe('ArrowRight')
+      expect(bindings.rotateLeft).toBe('z')
+      expect(bindings.rotateRight).toBe('ArrowUp')
+    })
+  })
+})
\ No newline at end of file
diff --git a/app/src/settings.ts b/app/src/settings.ts
new file mode 100644
index 0000000..10bb562
--- /dev/null
+++ b/app/src/settings.ts
@@ -0,0 +1,387 @@
+// ゲーム設定管理システム
+
+export interface KeyBindings {
+  moveLeft: string
+  moveRight: string
+  rotateLeft: string
+  rotateRight: string
+  softDrop: string
+  hardDrop: string
+}
+
+export interface GameSettings {
+  // サウンド設定
+  masterVolume: number      // 0.0 - 1.0
+  soundEnabled: boolean
+  bgmEnabled: boolean
+  
+  // キーボード設定
+  keyBindings: KeyBindings
+  
+  // ゲームプレイ設定
+  fallSpeed: number         // 1-10 (遅い-速い)
+  showGrid: boolean
+  showGhost: boolean        // ゴーストぷよ表示
+  
+  // 表示設定
+  showFPS: boolean
+  showNextPuyo: boolean
+  
+  // その他
+  pauseOnFocusLoss: boolean
+  enableAnimations: boolean
+}
+
+export class SettingsManager {
+  private static readonly STORAGE_KEY = 'puyo-puyo-settings'
+  private static readonly DEFAULT_SETTINGS: GameSettings = {
+    // サウンド
+    masterVolume: 0.7,
+    soundEnabled: true,
+    bgmEnabled: true,
+    
+    // キーバインド
+    keyBindings: {
+      moveLeft: 'ArrowLeft',
+      moveRight: 'ArrowRight',
+      rotateLeft: 'z',
+      rotateRight: 'ArrowUp',
+      softDrop: 'ArrowDown',
+      hardDrop: ' '
+    },
+    
+    // ゲームプレイ
+    fallSpeed: 5,
+    showGrid: true,
+    showGhost: false,
+    
+    // 表示
+    showFPS: false,
+    showNextPuyo: true,
+    
+    // その他
+    pauseOnFocusLoss: true,
+    enableAnimations: true
+  }
+
+  private settings: GameSettings
+  private listeners: Map<keyof GameSettings, ((value: any, oldValue?: any) => void)[]> = new Map()
+
+  constructor() {
+    this.settings = this.loadSettings()
+  }
+
+  // 設定読み込み
+  private loadSettings(): GameSettings {
+    try {
+      const stored = localStorage.getItem(SettingsManager.STORAGE_KEY)
+      if (stored) {
+        const parsed = JSON.parse(stored)
+        // デフォルト設定とマージ（新しい設定項目のフォールバック）
+        return { ...SettingsManager.DEFAULT_SETTINGS, ...parsed }
+      }
+    } catch (error) {
+      console.warn('設定の読み込みに失敗しました:', error)
+    }
+    
+    return { ...SettingsManager.DEFAULT_SETTINGS }
+  }
+
+  // 設定保存
+  private saveSettings(): void {
+    try {
+      localStorage.setItem(SettingsManager.STORAGE_KEY, JSON.stringify(this.settings))
+    } catch (error) {
+      console.warn('設定の保存に失敗しました:', error)
+    }
+  }
+
+  // 全設定取得
+  getSettings(): GameSettings {
+    return { ...this.settings }
+  }
+
+  // 個別設定取得
+  get<K extends keyof GameSettings>(key: K): GameSettings[K] {
+    return this.settings[key]
+  }
+
+  // 個別設定更新
+  set<K extends keyof GameSettings>(key: K, value: GameSettings[K]): void {
+    const oldValue = this.settings[key]
+    this.settings[key] = value
+    
+    this.saveSettings()
+    this.notifyListeners(key, value, oldValue)
+  }
+
+  // 複数設定の一括更新
+  updateSettings(updates: Partial<GameSettings>): void {
+    const changes: Array<{ key: keyof GameSettings; value: any; oldValue: any }> = []
+    
+    for (const [key, value] of Object.entries(updates)) {
+      const typedKey = key as keyof GameSettings
+      if (typedKey in this.settings) {
+        const oldValue = this.settings[typedKey]
+        ;(this.settings as any)[typedKey] = value
+        changes.push({ key: typedKey, value, oldValue })
+      }
+    }
+    
+    this.saveSettings()
+    
+    // 変更通知
+    changes.forEach(({ key, value, oldValue }) => {
+      this.notifyListeners(key, value, oldValue)
+    })
+  }
+
+  // 設定変更リスナー登録
+  onChange<K extends keyof GameSettings>(
+    key: K, 
+    callback: (value: GameSettings[K], oldValue?: GameSettings[K]) => void
+  ): void {
+    if (!this.listeners.has(key)) {
+      this.listeners.set(key, [])
+    }
+    this.listeners.get(key)!.push(callback)
+  }
+
+  // リスナー削除
+  removeListener<K extends keyof GameSettings>(
+    key: K,
+    callback: (value: GameSettings[K], oldValue?: GameSettings[K]) => void
+  ): void {
+    const listeners = this.listeners.get(key)
+    if (listeners) {
+      const index = listeners.indexOf(callback)
+      if (index > -1) {
+        listeners.splice(index, 1)
+      }
+    }
+  }
+
+  // 設定リセット
+  resetToDefaults(): void {
+    const oldSettings = { ...this.settings }
+    this.settings = { ...SettingsManager.DEFAULT_SETTINGS }
+    this.saveSettings()
+    
+    // 全ての変更を通知
+    for (const key of Object.keys(this.settings) as Array<keyof GameSettings>) {
+      this.notifyListeners(key, this.settings[key], oldSettings[key])
+    }
+  }
+
+  // 特定カテゴリのリセット
+  resetCategory(category: 'sound' | 'keyBindings' | 'display' | 'gameplay'): void {
+    const updates: Partial<GameSettings> = {}
+    
+    switch (category) {
+      case 'sound':
+        updates.masterVolume = SettingsManager.DEFAULT_SETTINGS.masterVolume
+        updates.soundEnabled = SettingsManager.DEFAULT_SETTINGS.soundEnabled
+        updates.bgmEnabled = SettingsManager.DEFAULT_SETTINGS.bgmEnabled
+        break
+      case 'keyBindings':
+        updates.keyBindings = { ...SettingsManager.DEFAULT_SETTINGS.keyBindings }
+        break
+      case 'display':
+        updates.showGrid = SettingsManager.DEFAULT_SETTINGS.showGrid
+        updates.showGhost = SettingsManager.DEFAULT_SETTINGS.showGhost
+        updates.showFPS = SettingsManager.DEFAULT_SETTINGS.showFPS
+        updates.showNextPuyo = SettingsManager.DEFAULT_SETTINGS.showNextPuyo
+        break
+      case 'gameplay':
+        updates.fallSpeed = SettingsManager.DEFAULT_SETTINGS.fallSpeed
+        updates.pauseOnFocusLoss = SettingsManager.DEFAULT_SETTINGS.pauseOnFocusLoss
+        updates.enableAnimations = SettingsManager.DEFAULT_SETTINGS.enableAnimations
+        break
+    }
+    
+    this.updateSettings(updates)
+  }
+
+  // キーバインド検証
+  isValidKeyBinding(key: string): boolean {
+    // 基本的なキー名の検証
+    const validKeys = [
+      'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+      ' ', 'Enter', 'Escape', 'Tab', 'Shift', 'Control', 'Alt'
+    ]
+    
+    return validKeys.includes(key)
+  }
+
+  // キーバインド重複チェック
+  hasKeyConflict(action: keyof KeyBindings, key: string): keyof KeyBindings | null {
+    for (const [bindAction, bindKey] of Object.entries(this.settings.keyBindings)) {
+      if (bindAction !== action && bindKey === key) {
+        return bindAction as keyof KeyBindings
+      }
+    }
+    return null
+  }
+
+  // キーバインド更新（重複チェック付き）
+  updateKeyBinding(action: keyof KeyBindings, key: string): boolean {
+    if (!this.isValidKeyBinding(key)) {
+      return false
+    }
+    
+    const conflict = this.hasKeyConflict(action, key)
+    if (conflict) {
+      return false
+    }
+    
+    const newBindings = { ...this.settings.keyBindings }
+    newBindings[action] = key
+    this.set('keyBindings', newBindings)
+    return true
+  }
+
+  // 設定の妥当性検証
+  validateSettings(): { valid: boolean; errors: string[] } {
+    const errors: string[] = []
+    
+    // 音量範囲チェック
+    if (this.settings.masterVolume < 0 || this.settings.masterVolume > 1) {
+      errors.push('音量は0.0-1.0の範囲で設定してください')
+    }
+    
+    // 落下速度チェック  
+    if (this.settings.fallSpeed < 1 || this.settings.fallSpeed > 10) {
+      errors.push('落下速度は1-10の範囲で設定してください')
+    }
+    
+    // キーバインド重複チェック
+    const keyValues = Object.values(this.settings.keyBindings)
+    const uniqueKeys = new Set(keyValues)
+    if (keyValues.length !== uniqueKeys.size) {
+      errors.push('キーバインドに重複があります')
+    }
+    
+    // キーバインド妥当性チェック
+    for (const [action, key] of Object.entries(this.settings.keyBindings)) {
+      if (!this.isValidKeyBinding(key)) {
+        errors.push(`${action}のキーバインド"${key}"が無効です`)
+      }
+    }
+    
+    return {
+      valid: errors.length === 0,
+      errors
+    }
+  }
+
+  // 設定エクスポート（JSON）
+  exportSettings(): string {
+    return JSON.stringify(this.settings, null, 2)
+  }
+
+  // 設定インポート（JSON）
+  importSettings(jsonString: string): boolean {
+    try {
+      const imported = JSON.parse(jsonString)
+      
+      // 基本的な構造検証
+      if (typeof imported !== 'object' || imported === null) {
+        return false
+      }
+      
+      // 既知のキーのみを取り込む
+      const validSettings: Partial<GameSettings> = {}
+      for (const key of Object.keys(SettingsManager.DEFAULT_SETTINGS)) {
+        if (key in imported) {
+          validSettings[key as keyof GameSettings] = imported[key]
+        }
+      }
+      
+      this.updateSettings(validSettings)
+      return true
+    } catch (error) {
+      console.warn('設定のインポートに失敗しました:', error)
+      return false
+    }
+  }
+
+  private notifyListeners<K extends keyof GameSettings>(
+    key: K,
+    value: GameSettings[K],
+    oldValue?: GameSettings[K]
+  ): void {
+    const listeners = this.listeners.get(key)
+    if (listeners) {
+      listeners.forEach(callback => {
+        try {
+          callback(value as any, oldValue)
+        } catch (error) {
+          console.error('設定変更リスナーエラー:', error)
+        }
+      })
+    }
+  }
+}
+
+// プリセット設定
+export class SettingsPresets {
+  static getBeginnerSettings(): Partial<GameSettings> {
+    return {
+      fallSpeed: 3,
+      showGrid: true,
+      showGhost: true,
+      showFPS: false,
+      masterVolume: 0.8,
+      enableAnimations: true
+    }
+  }
+
+  static getAdvancedSettings(): Partial<GameSettings> {
+    return {
+      fallSpeed: 8,
+      showGrid: false,
+      showGhost: false,
+      showFPS: true,
+      masterVolume: 0.5,
+      enableAnimations: false
+    }
+  }
+
+  static getSilentSettings(): Partial<GameSettings> {
+    return {
+      masterVolume: 0.0,
+      soundEnabled: false,
+      bgmEnabled: false
+    }
+  }
+
+  static getCompactBindings(): KeyBindings {
+    return {
+      moveLeft: 'a',
+      moveRight: 'd',
+      rotateLeft: 's',
+      rotateRight: 'w',
+      softDrop: 's',
+      hardDrop: ' '
+    }
+  }
+
+  static getArrowBindings(): KeyBindings {
+    return {
+      moveLeft: 'ArrowLeft',
+      moveRight: 'ArrowRight',
+      rotateLeft: 'z',
+      rotateRight: 'ArrowUp',
+      softDrop: 'ArrowDown',
+      hardDrop: ' '
+    }
+  }
+}
+
+// グローバル設定マネージャー
+export const settingsManager = new SettingsManager()
\ No newline at end of file
diff --git a/app/src/settingsUI.css b/app/src/settingsUI.css
new file mode 100644
index 0000000..215f911
--- /dev/null
+++ b/app/src/settingsUI.css
@@ -0,0 +1,375 @@
+/* 設定画面のスタイル */
+
+.settings-modal {
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  z-index: 1000;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+.settings-overlay {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  background: rgba(0, 0, 0, 0.7);
+  backdrop-filter: blur(2px);
+}
+
+.settings-content {
+  position: relative;
+  width: 90%;
+  max-width: 600px;
+  max-height: 90vh;
+  background: #f8f9fa;
+  border-radius: 12px;
+  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
+  overflow: hidden;
+  display: flex;
+  flex-direction: column;
+}
+
+.settings-header {
+  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
+  color: white;
+  padding: 20px;
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.settings-header h2 {
+  margin: 0;
+  font-size: 1.5rem;
+  font-weight: 600;
+}
+
+.close-btn {
+  background: rgba(255, 255, 255, 0.2);
+  border: none;
+  color: white;
+  font-size: 1.8rem;
+  width: 36px;
+  height: 36px;
+  border-radius: 50%;
+  cursor: pointer;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  transition: background 0.2s;
+}
+
+.close-btn:hover {
+  background: rgba(255, 255, 255, 0.3);
+}
+
+.settings-tabs {
+  display: flex;
+  background: #e9ecef;
+  border-bottom: 1px solid #dee2e6;
+}
+
+.tab-btn {
+  flex: 1;
+  padding: 12px 16px;
+  background: none;
+  border: none;
+  font-size: 0.9rem;
+  font-weight: 500;
+  color: #6c757d;
+  cursor: pointer;
+  transition: all 0.2s;
+  border-bottom: 3px solid transparent;
+}
+
+.tab-btn:hover {
+  background: #dee2e6;
+  color: #495057;
+}
+
+.tab-btn.active {
+  background: #f8f9fa;
+  color: #667eea;
+  border-bottom-color: #667eea;
+}
+
+.settings-body {
+  flex: 1;
+  overflow-y: auto;
+  padding: 20px;
+}
+
+.tab-content {
+  display: none;
+}
+
+.tab-content.active {
+  display: block;
+}
+
+.setting-group {
+  margin-bottom: 24px;
+  padding: 16px;
+  background: white;
+  border-radius: 8px;
+  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
+}
+
+.setting-group h3 {
+  margin: 0 0 16px 0;
+  color: #495057;
+  font-size: 1.1rem;
+  font-weight: 600;
+}
+
+.setting-group label {
+  display: block;
+  font-weight: 500;
+  color: #495057;
+  margin-bottom: 8px;
+}
+
+.slider-group {
+  display: flex;
+  align-items: center;
+  gap: 16px;
+  margin-top: 8px;
+}
+
+.slider-group input[type="range"] {
+  flex: 1;
+  height: 6px;
+  border-radius: 3px;
+  background: #e9ecef;
+  outline: none;
+  -webkit-appearance: none;
+}
+
+.slider-group input[type="range"]::-webkit-slider-thumb {
+  -webkit-appearance: none;
+  appearance: none;
+  width: 20px;
+  height: 20px;
+  border-radius: 50%;
+  background: #667eea;
+  cursor: pointer;
+  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+}
+
+.slider-group input[type="range"]::-moz-range-thumb {
+  width: 20px;
+  height: 20px;
+  border-radius: 50%;
+  background: #667eea;
+  cursor: pointer;
+  border: none;
+  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
+}
+
+.slider-group span {
+  min-width: 48px;
+  font-weight: 600;
+  color: #667eea;
+  text-align: center;
+}
+
+input[type="checkbox"] {
+  margin-right: 8px;
+  transform: scale(1.2);
+  accent-color: #667eea;
+}
+
+.key-binding-list {
+  display: grid;
+  grid-template-columns: 1fr 1fr;
+  gap: 12px;
+  margin-bottom: 16px;
+}
+
+.key-binding-item {
+  display: flex;
+  align-items: center;
+  justify-content: space-between;
+  padding: 8px;
+  background: #f8f9fa;
+  border-radius: 6px;
+}
+
+.key-binding-item label {
+  margin: 0;
+  font-size: 0.9rem;
+  min-width: 100px;
+}
+
+.key-binding-item input {
+  background: white;
+  border: 1px solid #dee2e6;
+  border-radius: 4px;
+  padding: 6px 12px;
+  font-size: 0.85rem;
+  font-weight: 600;
+  color: #495057;
+  cursor: pointer;
+  text-align: center;
+  min-width: 80px;
+  transition: all 0.2s;
+}
+
+.key-binding-item input:hover {
+  border-color: #667eea;
+}
+
+.key-binding-item input.binding-mode {
+  border-color: #28a745;
+  background: #d4edda;
+  color: #155724;
+  animation: pulse 1s infinite;
+}
+
+@keyframes pulse {
+  0%, 100% { opacity: 1; }
+  50% { opacity: 0.7; }
+}
+
+.preset-buttons {
+  display: flex;
+  gap: 8px;
+  flex-wrap: wrap;
+}
+
+.preset-btn, .test-btn {
+  padding: 8px 16px;
+  background: #6c757d;
+  color: white;
+  border: none;
+  border-radius: 6px;
+  font-size: 0.85rem;
+  font-weight: 500;
+  cursor: pointer;
+  transition: background 0.2s;
+}
+
+.preset-btn:hover, .test-btn:hover {
+  background: #5a6268;
+}
+
+.test-btn {
+  background: #28a745;
+  width: 100%;
+}
+
+.test-btn:hover {
+  background: #218838;
+}
+
+.settings-footer {
+  padding: 16px 20px;
+  background: #f8f9fa;
+  border-top: 1px solid #dee2e6;
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+}
+
+.left-buttons, .right-buttons {
+  display: flex;
+  gap: 8px;
+}
+
+.action-btn {
+  padding: 10px 20px;
+  border: none;
+  border-radius: 6px;
+  font-size: 0.9rem;
+  font-weight: 500;
+  cursor: pointer;
+  transition: all 0.2s;
+}
+
+.action-btn.reset {
+  background: #dc3545;
+  color: white;
+}
+
+.action-btn.reset:hover {
+  background: #c82333;
+}
+
+.action-btn:not(.reset):not(.cancel):not(.apply) {
+  background: #6c757d;
+  color: white;
+}
+
+.action-btn:not(.reset):not(.cancel):not(.apply):hover {
+  background: #5a6268;
+}
+
+.action-btn.cancel {
+  background: #6c757d;
+  color: white;
+}
+
+.action-btn.cancel:hover {
+  background: #5a6268;
+}
+
+.action-btn.apply {
+  background: #28a745;
+  color: white;
+}
+
+.action-btn.apply:hover {
+  background: #218838;
+}
+
+/* レスポンシブ対応 */
+@media (max-width: 768px) {
+  .settings-content {
+    width: 95%;
+    max-height: 95vh;
+  }
+  
+  .key-binding-list {
+    grid-template-columns: 1fr;
+  }
+  
+  .settings-tabs {
+    flex-wrap: wrap;
+  }
+  
+  .tab-btn {
+    font-size: 0.8rem;
+    padding: 10px 12px;
+  }
+  
+  .settings-footer {
+    flex-direction: column;
+    gap: 12px;
+  }
+  
+  .left-buttons, .right-buttons {
+    flex-wrap: wrap;
+    justify-content: center;
+  }
+}
+
+@media (max-width: 480px) {
+  .preset-buttons {
+    flex-direction: column;
+  }
+  
+  .preset-btn {
+    width: 100%;
+  }
+  
+  .action-btn {
+    padding: 8px 16px;
+    font-size: 0.85rem;
+  }
+}
\ No newline at end of file
diff --git a/app/src/settingsUI.ts b/app/src/settingsUI.ts
new file mode 100644
index 0000000..03055a2
--- /dev/null
+++ b/app/src/settingsUI.ts
@@ -0,0 +1,646 @@
+// 設定画面のUI管理
+import { settingsManager, SettingsPresets, GameSettings, KeyBindings } from './settings'
+import { soundManager } from './audio'
+
+export interface SettingsUIElements {
+  // モーダル要素
+  modal: HTMLElement
+  overlay: HTMLElement
+  closeBtn: HTMLElement
+  
+  // タブ要素
+  soundTab: HTMLElement
+  controlsTab: HTMLElement
+  displayTab: HTMLElement
+  gameplayTab: HTMLElement
+  
+  // サウンド設定
+  masterVolumeSlider: HTMLInputElement
+  masterVolumeValue: HTMLElement
+  soundEnabledCheckbox: HTMLInputElement
+  bgmEnabledCheckbox: HTMLInputElement
+  
+  // コントロール設定
+  keyBindingInputs: Map<keyof KeyBindings, HTMLInputElement>
+  
+  // 表示設定
+  showGridCheckbox: HTMLInputElement
+  showGhostCheckbox: HTMLInputElement
+  showFPSCheckbox: HTMLInputElement
+  showNextPuyoCheckbox: HTMLInputElement
+  
+  // ゲームプレイ設定
+  fallSpeedSlider: HTMLInputElement
+  fallSpeedValue: HTMLElement
+  pauseOnFocusLossCheckbox: HTMLInputElement
+  enableAnimationsCheckbox: HTMLInputElement
+  
+  // アクションボタン
+  resetAllBtn: HTMLElement
+  importBtn: HTMLElement
+  exportBtn: HTMLElement
+  applyBtn: HTMLElement
+  cancelBtn: HTMLElement
+}
+
+export class SettingsUI {
+  private elements!: SettingsUIElements
+  private currentTab: string = 'sound'
+  private originalSettings: GameSettings
+  private keyBindingMode: keyof KeyBindings | null = null
+
+  constructor() {
+    this.originalSettings = settingsManager.getSettings()
+    this.initializeUI()
+    this.setupEventListeners()
+    this.loadCurrentSettings()
+  }
+
+  private initializeUI(): void {
+    this.createSettingsModal()
+    this.elements = this.findUIElements()
+    this.setupTabs()
+  }
+
+  private createSettingsModal(): void {
+    const modalHTML = `
+      <div id="settings-modal" class="settings-modal" style="display: none;">
+        <div class="settings-overlay"></div>
+        <div class="settings-content">
+          <div class="settings-header">
+            <h2>⚙️ ゲーム設定</h2>
+            <button id="settings-close-btn" class="close-btn">×</button>
+          </div>
+          
+          <div class="settings-tabs">
+            <button class="tab-btn active" data-tab="sound">🔊 サウンド</button>
+            <button class="tab-btn" data-tab="controls">🎮 操作</button>
+            <button class="tab-btn" data-tab="display">🖥️ 表示</button>
+            <button class="tab-btn" data-tab="gameplay">⚡ ゲーム</button>
+          </div>
+
+          <div class="settings-body">
+            <!-- サウンド設定タブ -->
+            <div id="sound-tab" class="tab-content active">
+              <div class="setting-group">
+                <label>マスター音量</label>
+                <div class="slider-group">
+                  <input type="range" id="master-volume" min="0" max="1" step="0.1" />
+                  <span id="master-volume-value">70%</span>
+                </div>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="sound-enabled" />
+                  効果音を有効にする
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="bgm-enabled" />
+                  BGMを有効にする
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <button id="test-sound-btn" class="test-btn">🔊 効果音テスト</button>
+              </div>
+            </div>
+
+            <!-- 操作設定タブ -->
+            <div id="controls-tab" class="tab-content">
+              <div class="setting-group">
+                <h3>キーバインド設定</h3>
+                <div class="key-binding-list">
+                  <div class="key-binding-item">
+                    <label>左移動:</label>
+                    <input type="text" id="key-move-left" readonly />
+                  </div>
+                  <div class="key-binding-item">
+                    <label>右移動:</label>
+                    <input type="text" id="key-move-right" readonly />
+                  </div>
+                  <div class="key-binding-item">
+                    <label>左回転:</label>
+                    <input type="text" id="key-rotate-left" readonly />
+                  </div>
+                  <div class="key-binding-item">
+                    <label>右回転:</label>
+                    <input type="text" id="key-rotate-right" readonly />
+                  </div>
+                  <div class="key-binding-item">
+                    <label>ソフトドロップ:</label>
+                    <input type="text" id="key-soft-drop" readonly />
+                  </div>
+                  <div class="key-binding-item">
+                    <label>ハードドロップ:</label>
+                    <input type="text" id="key-hard-drop" readonly />
+                  </div>
+                </div>
+                <div class="preset-buttons">
+                  <button id="compact-preset-btn" class="preset-btn">WASD配置</button>
+                  <button id="arrow-preset-btn" class="preset-btn">アローキー配置</button>
+                </div>
+              </div>
+            </div>
+
+            <!-- 表示設定タブ -->
+            <div id="display-tab" class="tab-content">
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="show-grid" />
+                  グリッドを表示する
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="show-ghost" />
+                  ゴーストぷよを表示する
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="show-fps" />
+                  FPSを表示する
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="show-next-puyo" />
+                  次のぷよを表示する
+                </label>
+              </div>
+            </div>
+
+            <!-- ゲームプレイ設定タブ -->
+            <div id="gameplay-tab" class="tab-content">
+              <div class="setting-group">
+                <label>落下速度</label>
+                <div class="slider-group">
+                  <input type="range" id="fall-speed" min="1" max="10" step="1" />
+                  <span id="fall-speed-value">5</span>
+                </div>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="pause-on-focus-loss" />
+                  フォーカス失焦時に一時停止
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <label>
+                  <input type="checkbox" id="enable-animations" />
+                  アニメーションを有効にする
+                </label>
+              </div>
+              
+              <div class="setting-group">
+                <div class="preset-buttons">
+                  <button id="beginner-preset-btn" class="preset-btn">初心者向け</button>
+                  <button id="advanced-preset-btn" class="preset-btn">上級者向け</button>
+                  <button id="silent-preset-btn" class="preset-btn">サイレント</button>
+                </div>
+              </div>
+            </div>
+          </div>
+
+          <div class="settings-footer">
+            <div class="left-buttons">
+              <button id="reset-all-btn" class="action-btn reset">🔄 すべてリセット</button>
+              <button id="import-btn" class="action-btn">📂 インポート</button>
+              <button id="export-btn" class="action-btn">💾 エクスポート</button>
+            </div>
+            <div class="right-buttons">
+              <button id="cancel-btn" class="action-btn cancel">キャンセル</button>
+              <button id="apply-btn" class="action-btn apply">適用</button>
+            </div>
+          </div>
+        </div>
+      </div>
+    `
+
+    document.body.insertAdjacentHTML('beforeend', modalHTML)
+  }
+
+  private findUIElements(): SettingsUIElements {
+    const modal = document.getElementById('settings-modal')!
+    
+    return {
+      modal,
+      overlay: modal.querySelector('.settings-overlay')!,
+      closeBtn: document.getElementById('settings-close-btn')!,
+      
+      // タブ
+      soundTab: modal.querySelector('[data-tab="sound"]')!,
+      controlsTab: modal.querySelector('[data-tab="controls"]')!,
+      displayTab: modal.querySelector('[data-tab="display"]')!,
+      gameplayTab: modal.querySelector('[data-tab="gameplay"]')!,
+      
+      // サウンド設定
+      masterVolumeSlider: document.getElementById('master-volume')! as HTMLInputElement,
+      masterVolumeValue: document.getElementById('master-volume-value')!,
+      soundEnabledCheckbox: document.getElementById('sound-enabled')! as HTMLInputElement,
+      bgmEnabledCheckbox: document.getElementById('bgm-enabled')! as HTMLInputElement,
+      
+      // キーバインド
+      keyBindingInputs: new Map([
+        ['moveLeft', document.getElementById('key-move-left')! as HTMLInputElement],
+        ['moveRight', document.getElementById('key-move-right')! as HTMLInputElement],
+        ['rotateLeft', document.getElementById('key-rotate-left')! as HTMLInputElement],
+        ['rotateRight', document.getElementById('key-rotate-right')! as HTMLInputElement],
+        ['softDrop', document.getElementById('key-soft-drop')! as HTMLInputElement],
+        ['hardDrop', document.getElementById('key-hard-drop')! as HTMLInputElement]
+      ]),
+      
+      // 表示設定
+      showGridCheckbox: document.getElementById('show-grid')! as HTMLInputElement,
+      showGhostCheckbox: document.getElementById('show-ghost')! as HTMLInputElement,
+      showFPSCheckbox: document.getElementById('show-fps')! as HTMLInputElement,
+      showNextPuyoCheckbox: document.getElementById('show-next-puyo')! as HTMLInputElement,
+      
+      // ゲームプレイ設定
+      fallSpeedSlider: document.getElementById('fall-speed')! as HTMLInputElement,
+      fallSpeedValue: document.getElementById('fall-speed-value')!,
+      pauseOnFocusLossCheckbox: document.getElementById('pause-on-focus-loss')! as HTMLInputElement,
+      enableAnimationsCheckbox: document.getElementById('enable-animations')! as HTMLInputElement,
+      
+      // アクションボタン
+      resetAllBtn: document.getElementById('reset-all-btn')!,
+      importBtn: document.getElementById('import-btn')!,
+      exportBtn: document.getElementById('export-btn')!,
+      applyBtn: document.getElementById('apply-btn')!,
+      cancelBtn: document.getElementById('cancel-btn')!
+    }
+  }
+
+  private setupTabs(): void {
+    const tabButtons = this.elements.modal.querySelectorAll('.tab-btn')
+    const tabContents = this.elements.modal.querySelectorAll('.tab-content')
+
+    tabButtons.forEach(button => {
+      button.addEventListener('click', () => {
+        const tabName = button.getAttribute('data-tab')!
+        this.switchTab(tabName)
+      })
+    })
+  }
+
+  private switchTab(tabName: string): void {
+    const tabButtons = this.elements.modal.querySelectorAll('.tab-btn')
+    const tabContents = this.elements.modal.querySelectorAll('.tab-content')
+
+    // アクティブタブをクリア
+    tabButtons.forEach(btn => btn.classList.remove('active'))
+    tabContents.forEach(content => content.classList.remove('active'))
+
+    // 新しいタブをアクティブに
+    const activeButton = this.elements.modal.querySelector(`[data-tab="${tabName}"]`)
+    const activeContent = document.getElementById(`${tabName}-tab`)
+
+    if (activeButton && activeContent) {
+      activeButton.classList.add('active')
+      activeContent.classList.add('active')
+      this.currentTab = tabName
+    }
+  }
+
+  private setupEventListeners(): void {
+    // モーダル制御
+    this.elements.closeBtn.addEventListener('click', () => this.close())
+    this.elements.overlay.addEventListener('click', () => this.close())
+    this.elements.cancelBtn.addEventListener('click', () => this.close())
+    this.elements.applyBtn.addEventListener('click', () => this.apply())
+
+    // サウンド設定
+    this.elements.masterVolumeSlider.addEventListener('input', () => this.updateVolumeDisplay())
+    this.elements.masterVolumeSlider.addEventListener('change', () => this.testVolumeChange())
+    
+    // テストサウンド
+    document.getElementById('test-sound-btn')?.addEventListener('click', () => this.testSound())
+
+    // キーバインド設定
+    this.elements.keyBindingInputs.forEach((input, action) => {
+      input.addEventListener('click', () => this.startKeyBinding(action))
+    })
+
+    // プリセットボタン
+    document.getElementById('compact-preset-btn')?.addEventListener('click', () => this.applyKeyBindingPreset('compact'))
+    document.getElementById('arrow-preset-btn')?.addEventListener('click', () => this.applyKeyBindingPreset('arrow'))
+    document.getElementById('beginner-preset-btn')?.addEventListener('click', () => this.applySettingsPreset('beginner'))
+    document.getElementById('advanced-preset-btn')?.addEventListener('click', () => this.applySettingsPreset('advanced'))
+    document.getElementById('silent-preset-btn')?.addEventListener('click', () => this.applySettingsPreset('silent'))
+
+    // 落下速度スライダー
+    this.elements.fallSpeedSlider.addEventListener('input', () => this.updateFallSpeedDisplay())
+
+    // アクションボタン
+    this.elements.resetAllBtn.addEventListener('click', () => this.resetAll())
+    this.elements.importBtn.addEventListener('click', () => this.importSettings())
+    this.elements.exportBtn.addEventListener('click', () => this.exportSettings())
+
+    // ESCキーで閉じる
+    document.addEventListener('keydown', (e) => {
+      if (e.key === 'Escape' && this.isOpen()) {
+        this.close()
+      }
+    })
+  }
+
+  private loadCurrentSettings(): void {
+    const settings = settingsManager.getSettings()
+    
+    // サウンド設定
+    this.elements.masterVolumeSlider.value = settings.masterVolume.toString()
+    this.updateVolumeDisplay()
+    this.elements.soundEnabledCheckbox.checked = settings.soundEnabled
+    this.elements.bgmEnabledCheckbox.checked = settings.bgmEnabled
+    
+    // キーバインド設定
+    for (const [action, key] of Object.entries(settings.keyBindings)) {
+      const input = this.elements.keyBindingInputs.get(action as keyof KeyBindings)
+      if (input) {
+        input.value = this.formatKeyDisplay(key)
+      }
+    }
+    
+    // 表示設定
+    this.elements.showGridCheckbox.checked = settings.showGrid
+    this.elements.showGhostCheckbox.checked = settings.showGhost
+    this.elements.showFPSCheckbox.checked = settings.showFPS
+    this.elements.showNextPuyoCheckbox.checked = settings.showNextPuyo
+    
+    // ゲームプレイ設定
+    this.elements.fallSpeedSlider.value = settings.fallSpeed.toString()
+    this.updateFallSpeedDisplay()
+    this.elements.pauseOnFocusLossCheckbox.checked = settings.pauseOnFocusLoss
+    this.elements.enableAnimationsCheckbox.checked = settings.enableAnimations
+  }
+
+  private updateVolumeDisplay(): void {
+    const value = parseFloat(this.elements.masterVolumeSlider.value)
+    this.elements.masterVolumeValue.textContent = `${Math.round(value * 100)}%`
+  }
+
+  private updateFallSpeedDisplay(): void {
+    const value = parseInt(this.elements.fallSpeedSlider.value)
+    this.elements.fallSpeedValue.textContent = value.toString()
+  }
+
+  private testVolumeChange(): void {
+    const volume = parseFloat(this.elements.masterVolumeSlider.value)
+    soundManager.setMasterVolume(volume)
+    this.testSound()
+  }
+
+  private testSound(): void {
+    import('./audio').then(({ soundManager, SoundType }) => {
+      soundManager.playSound(SoundType.Move)
+    })
+  }
+
+  private startKeyBinding(action: keyof KeyBindings): void {
+    this.keyBindingMode = action
+    const input = this.elements.keyBindingInputs.get(action)
+    
+    if (input) {
+      input.value = 'キーを押してください...'
+      input.classList.add('binding-mode')
+    }
+
+    const keyHandler = (event: KeyboardEvent) => {
+      event.preventDefault()
+      
+      if (this.keyBindingMode) {
+        const key = event.key
+        const input = this.elements.keyBindingInputs.get(this.keyBindingMode)
+        
+        if (settingsManager.isValidKeyBinding(key)) {
+          const conflict = settingsManager.hasKeyConflict(this.keyBindingMode, key)
+          if (conflict) {
+            alert(`このキーは既に「${this.getActionDisplayName(conflict)}」に使用されています`)
+            input?.classList.remove('binding-mode')
+          } else {
+            if (input) {
+              input.value = this.formatKeyDisplay(key)
+              input.classList.remove('binding-mode')
+            }
+          }
+        } else {
+          alert('このキーは使用できません')
+          if (input) {
+            input.classList.remove('binding-mode')
+          }
+        }
+        
+        this.keyBindingMode = null
+        document.removeEventListener('keydown', keyHandler)
+      }
+    }
+
+    document.addEventListener('keydown', keyHandler)
+  }
+
+  private formatKeyDisplay(key: string): string {
+    const keyMap: Record<string, string> = {
+      'ArrowLeft': '←',
+      'ArrowRight': '→',
+      'ArrowUp': '↑',
+      'ArrowDown': '↓',
+      ' ': 'スペース',
+      'Enter': 'エンター',
+      'Escape': 'エスケープ'
+    }
+    
+    return keyMap[key] || key.toUpperCase()
+  }
+
+  private getActionDisplayName(action: keyof KeyBindings): string {
+    const actionNames: Record<keyof KeyBindings, string> = {
+      moveLeft: '左移動',
+      moveRight: '右移動',
+      rotateLeft: '左回転',
+      rotateRight: '右回転',
+      softDrop: 'ソフトドロップ',
+      hardDrop: 'ハードドロップ'
+    }
+    
+    return actionNames[action]
+  }
+
+  private applyKeyBindingPreset(preset: 'compact' | 'arrow'): void {
+    const bindings = preset === 'compact' 
+      ? SettingsPresets.getCompactBindings()
+      : SettingsPresets.getArrowBindings()
+
+    for (const [action, key] of Object.entries(bindings)) {
+      const input = this.elements.keyBindingInputs.get(action as keyof KeyBindings)
+      if (input) {
+        input.value = this.formatKeyDisplay(key)
+      }
+    }
+  }
+
+  private applySettingsPreset(preset: 'beginner' | 'advanced' | 'silent'): void {
+    let presetSettings: Partial<GameSettings>
+    
+    switch (preset) {
+      case 'beginner':
+        presetSettings = SettingsPresets.getBeginnerSettings()
+        break
+      case 'advanced':
+        presetSettings = SettingsPresets.getAdvancedSettings()
+        break
+      case 'silent':
+        presetSettings = SettingsPresets.getSilentSettings()
+        break
+    }
+
+    // UI要素に反映
+    if ('masterVolume' in presetSettings) {
+      this.elements.masterVolumeSlider.value = presetSettings.masterVolume!.toString()
+      this.updateVolumeDisplay()
+    }
+    if ('soundEnabled' in presetSettings) {
+      this.elements.soundEnabledCheckbox.checked = presetSettings.soundEnabled!
+    }
+    if ('bgmEnabled' in presetSettings) {
+      this.elements.bgmEnabledCheckbox.checked = presetSettings.bgmEnabled!
+    }
+    if ('fallSpeed' in presetSettings) {
+      this.elements.fallSpeedSlider.value = presetSettings.fallSpeed!.toString()
+      this.updateFallSpeedDisplay()
+    }
+    if ('showGrid' in presetSettings) {
+      this.elements.showGridCheckbox.checked = presetSettings.showGrid!
+    }
+    if ('showGhost' in presetSettings) {
+      this.elements.showGhostCheckbox.checked = presetSettings.showGhost!
+    }
+    if ('showFPS' in presetSettings) {
+      this.elements.showFPSCheckbox.checked = presetSettings.showFPS!
+    }
+    if ('enableAnimations' in presetSettings) {
+      this.elements.enableAnimationsCheckbox.checked = presetSettings.enableAnimations!
+    }
+  }
+
+  private resetAll(): void {
+    if (confirm('すべての設定をデフォルトに戻しますか？')) {
+      settingsManager.resetToDefaults()
+      this.loadCurrentSettings()
+    }
+  }
+
+  private importSettings(): void {
+    const input = document.createElement('input')
+    input.type = 'file'
+    input.accept = '.json'
+    
+    input.onchange = (event) => {
+      const file = (event.target as HTMLInputElement).files?.[0]
+      if (file) {
+        const reader = new FileReader()
+        reader.onload = (e) => {
+          try {
+            const content = e.target?.result as string
+            if (settingsManager.importSettings(content)) {
+              this.loadCurrentSettings()
+              alert('設定をインポートしました')
+            } else {
+              alert('設定ファイルが無効です')
+            }
+          } catch (error) {
+            alert('設定ファイルの読み込みに失敗しました')
+          }
+        }
+        reader.readAsText(file)
+      }
+    }
+    
+    input.click()
+  }
+
+  private exportSettings(): void {
+    const settings = settingsManager.exportSettings()
+    const blob = new Blob([settings], { type: 'application/json' })
+    const url = URL.createObjectURL(blob)
+    
+    const a = document.createElement('a')
+    a.href = url
+    a.download = 'puyo-settings.json'
+    a.click()
+    
+    URL.revokeObjectURL(url)
+  }
+
+  private apply(): void {
+    // 設定の収集と検証
+    const newSettings: Partial<GameSettings> = {
+      masterVolume: parseFloat(this.elements.masterVolumeSlider.value),
+      soundEnabled: this.elements.soundEnabledCheckbox.checked,
+      bgmEnabled: this.elements.bgmEnabledCheckbox.checked,
+      showGrid: this.elements.showGridCheckbox.checked,
+      showGhost: this.elements.showGhostCheckbox.checked,
+      showFPS: this.elements.showFPSCheckbox.checked,
+      showNextPuyo: this.elements.showNextPuyoCheckbox.checked,
+      fallSpeed: parseInt(this.elements.fallSpeedSlider.value),
+      pauseOnFocusLoss: this.elements.pauseOnFocusLossCheckbox.checked,
+      enableAnimations: this.elements.enableAnimationsCheckbox.checked
+    }
+
+    // キーバインドの収集
+    const keyBindings: KeyBindings = {} as KeyBindings
+    this.elements.keyBindingInputs.forEach((input, action) => {
+      // 表示名から実際のキー名に変換
+      keyBindings[action] = this.parseKeyFromDisplay(input.value)
+    })
+    newSettings.keyBindings = keyBindings
+
+    // 設定を適用
+    settingsManager.updateSettings(newSettings)
+    
+    // サウンドマネージャーにも反映
+    soundManager.setMasterVolume(newSettings.masterVolume!)
+    soundManager.setSoundEnabled(newSettings.soundEnabled!)
+    soundManager.setBGMEnabled(newSettings.bgmEnabled!)
+
+    this.close()
+  }
+
+  private parseKeyFromDisplay(display: string): string {
+    const reverseKeyMap: Record<string, string> = {
+      '←': 'ArrowLeft',
+      '→': 'ArrowRight',
+      '↑': 'ArrowUp',
+      '↓': 'ArrowDown',
+      'スペース': ' ',
+      'エンター': 'Enter',
+      'エスケープ': 'Escape'
+    }
+    
+    return reverseKeyMap[display] || display.toLowerCase()
+  }
+
+  // 公開メソッド
+  public open(): void {
+    this.originalSettings = settingsManager.getSettings()
+    this.loadCurrentSettings()
+    this.elements.modal.style.display = 'block'
+  }
+
+  public close(): void {
+    this.elements.modal.style.display = 'none'
+    this.keyBindingMode = null
+  }
+
+  public isOpen(): boolean {
+    return this.elements.modal.style.display === 'block'
+  }
+}
\ No newline at end of file
diff --git a/app/src/statistics.test.ts b/app/src/statistics.test.ts
new file mode 100644
index 0000000..9c0d96f
--- /dev/null
+++ b/app/src/statistics.test.ts
@@ -0,0 +1,318 @@
+import { describe, it, expect, beforeEach, vi, afterEach, afterAll } from 'vitest'
+import { StatisticsManager, GameStatistics, SessionData } from './statistics'
+
+// localStorage のモック化
+const localStorageMock = {
+  getItem: vi.fn(),
+  setItem: vi.fn(),
+  removeItem: vi.fn(),
+  clear: vi.fn()
+}
+
+Object.defineProperty(window, 'localStorage', {
+  value: localStorageMock
+})
+
+// Dateのモック化
+const mockDate = new Date('2023-12-01T10:00:00Z')
+const originalDate = Date
+;(globalThis as any).Date = vi.fn(() => mockDate) as any
+Date.now = vi.fn(() => mockDate.getTime())
+Date.prototype.toISOString = vi.fn(() => mockDate.toISOString())
+
+describe('StatisticsManager', () => {
+  let statisticsManager: StatisticsManager
+  
+  beforeEach(() => {
+    vi.clearAllMocks()
+    localStorageMock.getItem.mockReturnValue(null)
+    statisticsManager = new StatisticsManager()
+  })
+
+  afterEach(() => {
+    vi.clearAllMocks()
+  })
+
+  describe('初期化', () => {
+    it('StatisticsManagerを正常に作成できる', () => {
+      expect(statisticsManager).toBeInstanceOf(StatisticsManager)
+    })
+
+    it('デフォルト統計が正しく初期化される', () => {
+      const stats = statisticsManager.getStatistics()
+      expect(stats.totalGamesPlayed).toBe(0)
+      expect(stats.totalScore).toBe(0)
+      expect(stats.highScore).toBe(0)
+      expect(stats.totalPlayTime).toBe(0)
+    })
+
+    it('保存済み統計が正しく読み込まれる', () => {
+      const savedStats = {
+        totalGamesPlayed: 5,
+        highScore: 12000,
+        totalPlayTime: 300
+      }
+      localStorageMock.getItem.mockReturnValue(JSON.stringify(savedStats))
+      
+      const manager = new StatisticsManager()
+      const stats = manager.getStatistics()
+      
+      expect(stats.totalGamesPlayed).toBe(5)
+      expect(stats.highScore).toBe(12000)
+      expect(stats.totalPlayTime).toBe(300)
+    })
+  })
+
+  describe('セッション管理', () => {
+    it('セッションを開始できる', () => {
+      statisticsManager.startSession(1)
+      const session = statisticsManager.getCurrentSession()
+      
+      expect(session).not.toBeNull()
+      expect(session!.level).toBe(1)
+      expect(session!.score).toBe(0)
+      expect(session!.startTime).toBe(mockDate.getTime())
+    })
+
+    it('セッション中の統計を更新できる', () => {
+      statisticsManager.startSession(1)
+      
+      statisticsManager.updateSessionStats({
+        score: 5000,
+        chainsCount: 3,
+        longestChain: 4,
+        puyoDropped: 20,
+        linesCleared: 5
+      })
+      
+      const session = statisticsManager.getCurrentSession()
+      expect(session!.score).toBe(5000)
+      expect(session!.chainsCount).toBe(3)
+      expect(session!.longestChain).toBe(4)
+      expect(session!.puyoDropped).toBe(20)
+      expect(session!.linesCleared).toBe(5)
+    })
+
+    it('セッションを終了して統計を更新できる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.updateSessionStats({
+        score: 8000,
+        chainsCount: 2,
+        longestChain: 3,
+        puyoDropped: 30,
+        linesCleared: 8
+      })
+      
+      // 1分後にセッション終了
+      const endTime = mockDate.getTime() + 60000
+      Date.now = vi.fn(() => endTime)
+      
+      statisticsManager.endSession(8000, true)
+      
+      const stats = statisticsManager.getStatistics()
+      expect(stats.totalGamesPlayed).toBe(1)
+      expect(stats.totalGamesWon).toBe(1)
+      expect(stats.totalScore).toBe(8000)
+      expect(stats.highScore).toBe(8000)
+      expect(stats.totalPlayTime).toBe(60)
+      expect(stats.totalPuyoDropped).toBe(30)
+      expect(stats.totalLinesCleared).toBe(8)
+      
+      // セッションがクリアされることを確認
+      expect(statisticsManager.getCurrentSession()).toBeNull()
+    })
+  })
+
+  describe('統計計算', () => {
+    beforeEach(() => {
+      // 複数セッションのテストデータセットアップ
+      statisticsManager.startSession(1)
+      statisticsManager.updateSessionStats({
+        score: 5000,
+        chainsCount: 2,
+        longestChain: 3,
+        puyoDropped: 20,
+        linesCleared: 4
+      })
+      statisticsManager.endSession(5000, true)
+      
+      statisticsManager.startSession(2)
+      statisticsManager.updateSessionStats({
+        score: 12000,
+        chainsCount: 4,
+        longestChain: 6,
+        puyoDropped: 40,
+        linesCleared: 10
+      })
+      statisticsManager.endSession(12000, false)
+    })
+
+    it('平均スコアが正しく計算される', () => {
+      const stats = statisticsManager.getStatistics()
+      expect(stats.averageScore).toBe(8500) // (5000 + 12000) / 2
+    })
+
+    it('ハイスコアが正しく更新される', () => {
+      const stats = statisticsManager.getStatistics()
+      expect(stats.highScore).toBe(12000)
+    })
+
+    it('最長チェーンが正しく記録される', () => {
+      const stats = statisticsManager.getStatistics()
+      expect(stats.longestChain).toBe(6)
+    })
+
+    it('勝率が正しく計算される', () => {
+      const summary = statisticsManager.getStatisticsSummary()
+      expect(summary.winRate).toBe(50) // 1勝 / 2ゲーム = 50%
+    })
+
+    it('レベル別統計が正しく記録される', () => {
+      const stats = statisticsManager.getStatistics()
+      
+      expect(stats.levelStatistics[1].gamesPlayed).toBe(1)
+      expect(stats.levelStatistics[1].bestScore).toBe(5000)
+      expect(stats.levelStatistics[2].gamesPlayed).toBe(1)
+      expect(stats.levelStatistics[2].bestScore).toBe(12000)
+    })
+  })
+
+  describe('統計サマリー', () => {
+    it('統計サマリーを正しく生成できる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.endSession(10000, true)
+      
+      const summary = statisticsManager.getStatisticsSummary()
+      
+      expect(summary.gamesPlayed).toBe(1)
+      expect(summary.winRate).toBe(100)
+      expect(summary.averageScore).toBe(10000)
+      expect(summary.favoriteLevel).toBe(1)
+    })
+
+    it('プレイ時間が正しくフォーマットされる', () => {
+      // 長時間セッションをシミュレート
+      statisticsManager.startSession(1)
+      const endTime = mockDate.getTime() + 7260000 // 2時間1分後
+      Date.now = vi.fn(() => endTime)
+      statisticsManager.endSession(15000, true)
+      
+      const summary = statisticsManager.getStatisticsSummary()
+      expect(summary.totalPlayTime).toContain('時間')
+    })
+  })
+
+  describe('達成度とマイルストーン', () => {
+    it('達成度を正しく計算できる', () => {
+      // 複数ゲームをプレイして達成度をテスト
+      for (let i = 0; i < 12; i++) {
+        statisticsManager.startSession(1)
+        statisticsManager.updateSessionStats({
+          score: 8000,
+          longestChain: 6
+        })
+        statisticsManager.endSession(8000, true)
+      }
+      
+      const progress = statisticsManager.getProgressData()
+      
+      // 「初心者」達成度をチェック（10ゲーム以上）
+      const beginnerAchievement = progress.achievements.find(a => a.name === '初心者')
+      expect(beginnerAchievement?.completed).toBe(true)
+      
+      // 「チェーンマスター」達成度をチェック（5チェーン以上）
+      const chainAchievement = progress.achievements.find(a => a.name === 'チェーンマスター')
+      expect(chainAchievement?.completed).toBe(true)
+    })
+
+    it('マイルストーンを正しく判定できる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.updateSessionStats({
+        score: 15000,
+        longestChain: 8
+      })
+      statisticsManager.endSession(15000, true)
+      
+      const progress = statisticsManager.getProgressData()
+      
+      expect(progress.milestones.length).toBeGreaterThan(0)
+      const scoresMilestone = progress.milestones.find(m => m.name === 'ハイスコア')
+      expect(scoresMilestone?.value).toBe(15000)
+    })
+  })
+
+  describe('データの永続化', () => {
+    it('統計データをリセットできる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.endSession(5000, true)
+      
+      statisticsManager.resetStatistics()
+      
+      const stats = statisticsManager.getStatistics()
+      expect(stats.totalGamesPlayed).toBe(0)
+      expect(stats.totalScore).toBe(0)
+      expect(stats.highScore).toBe(0)
+    })
+
+    it('統計データをエクスポートできる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.endSession(7000, true)
+      
+      const exported = statisticsManager.exportStatistics()
+      const data = JSON.parse(exported)
+      
+      expect(data.statistics.totalGamesPlayed).toBe(1)
+      expect(data.statistics.totalScore).toBe(7000)
+      expect(data.exportDate).toBeDefined()
+      expect(data.version).toBe('1.0')
+    })
+
+    it('統計データをインポートできる', () => {
+      const importData = {
+        statistics: {
+          totalGamesPlayed: 15,
+          highScore: 25000,
+          totalScore: 180000
+        },
+        exportDate: '2023-12-01T12:00:00.000Z',
+        version: '1.0'
+      }
+      
+      const success = statisticsManager.importStatistics(JSON.stringify(importData))
+      expect(success).toBe(true)
+      
+      const stats = statisticsManager.getStatistics()
+      expect(stats.totalGamesPlayed).toBe(15)
+      expect(stats.highScore).toBe(25000)
+      expect(stats.totalScore).toBe(180000)
+    })
+
+    it('不正なデータのインポートは失敗する', () => {
+      const success = statisticsManager.importStatistics('invalid json')
+      expect(success).toBe(false)
+    })
+  })
+
+  describe('ハイスコアランキング', () => {
+    it('ハイスコアランキングを取得できる', () => {
+      statisticsManager.startSession(1)
+      statisticsManager.endSession(20000, true)
+      
+      const ranking = statisticsManager.getHighScoreRanking()
+      
+      expect(ranking.length).toBe(1)
+      expect(ranking[0].score).toBe(20000)
+      expect(ranking[0].date).toBe('2023-12-01')
+    })
+
+    it('スコアがない場合は空のランキングを返す', () => {
+      const ranking = statisticsManager.getHighScoreRanking()
+      expect(ranking).toEqual([])
+    })
+  })
+})
+
+// Dateを元に戻す
+afterAll(() => {
+  ;(globalThis as any).Date = originalDate
+})
\ No newline at end of file
diff --git a/app/src/statistics.ts b/app/src/statistics.ts
new file mode 100644
index 0000000..efc8e1a
--- /dev/null
+++ b/app/src/statistics.ts
@@ -0,0 +1,500 @@
+// 統計機能管理システム
+export interface GameStatistics {
+  // ゲーム統計
+  totalGamesPlayed: number
+  totalGamesWon: number
+  totalScore: number
+  highScore: number
+  averageScore: number
+  
+  // プレイ時間統計
+  totalPlayTime: number        // 秒単位
+  longestSession: number       // 最長セッション（秒）
+  averageSessionTime: number   // 平均セッション時間（秒）
+  
+  // ぷよ統計
+  totalPuyoDropped: number     // 落としたぷよ数
+  totalLinesCleared: number    // 消したライン数
+  totalChainsMade: number      // 作ったチェーン数
+  longestChain: number         // 最長チェーン
+  averageChainLength: number   // 平均チェーン長
+  
+  // 効率統計
+  puyoPerMinute: number        // 分間ぷよ数（APM）
+  scorePerPuyo: number         // ぷよあたりスコア効率
+  
+  // 日付統計
+  firstPlayDate: string        // 初回プレイ日
+  lastPlayDate: string         // 最後のプレイ日
+  playDays: number            // 異なる日にプレイした日数
+  
+  // レベル別統計
+  levelStatistics: Record<number, {
+    gamesPlayed: number
+    bestScore: number
+    averageScore: number
+    totalPlayTime: number
+  }>
+  
+  // 月別統計
+  monthlyStats: Record<string, {  // YYYY-MM形式
+    gamesPlayed: number
+    totalScore: number
+    totalPlayTime: number
+    bestScore: number
+  }>
+}
+
+export interface SessionData {
+  sessionId: string
+  startTime: number
+  endTime?: number
+  score: number
+  level: number
+  chainsCount: number
+  longestChain: number
+  puyoDropped: number
+  linesCleared: number
+  isCompleted: boolean
+}
+
+export class StatisticsManager {
+  private static readonly STORAGE_KEY = 'puyo-puyo-statistics'
+  private static readonly SESSION_KEY = 'puyo-puyo-current-session'
+  
+  private statistics: GameStatistics
+  private currentSession: SessionData | null = null
+  private sessionStartTime: number = 0
+  
+  constructor() {
+    this.statistics = this.loadStatistics()
+    this.loadCurrentSession()
+  }
+
+  private getDefaultStatistics(): GameStatistics {
+    return {
+      totalGamesPlayed: 0,
+      totalGamesWon: 0,
+      totalScore: 0,
+      highScore: 0,
+      averageScore: 0,
+      
+      totalPlayTime: 0,
+      longestSession: 0,
+      averageSessionTime: 0,
+      
+      totalPuyoDropped: 0,
+      totalLinesCleared: 0,
+      totalChainsMade: 0,
+      longestChain: 0,
+      averageChainLength: 0,
+      
+      puyoPerMinute: 0,
+      scorePerPuyo: 0,
+      
+      firstPlayDate: '',
+      lastPlayDate: '',
+      playDays: 0,
+      
+      levelStatistics: {},
+      monthlyStats: {}
+    }
+  }
+
+  private loadStatistics(): GameStatistics {
+    try {
+      const stored = localStorage.getItem(StatisticsManager.STORAGE_KEY)
+      if (stored) {
+        const parsed = JSON.parse(stored)
+        // デフォルト値とマージして不足プロパティを補完
+        return { ...this.getDefaultStatistics(), ...parsed }
+      }
+    } catch (error) {
+      console.warn('統計データの読み込みに失敗しました:', error)
+    }
+    
+    return this.getDefaultStatistics()
+  }
+
+  private saveStatistics(): void {
+    try {
+      localStorage.setItem(StatisticsManager.STORAGE_KEY, JSON.stringify(this.statistics))
+    } catch (error) {
+      console.warn('統計データの保存に失敗しました:', error)
+    }
+  }
+
+  private loadCurrentSession(): void {
+    try {
+      const stored = localStorage.getItem(StatisticsManager.SESSION_KEY)
+      if (stored) {
+        this.currentSession = JSON.parse(stored)
+      }
+    } catch (error) {
+      console.warn('セッションデータの読み込みに失敗しました:', error)
+      this.currentSession = null
+    }
+  }
+
+  private saveCurrentSession(): void {
+    try {
+      if (this.currentSession) {
+        localStorage.setItem(StatisticsManager.SESSION_KEY, JSON.stringify(this.currentSession))
+      }
+    } catch (error) {
+      console.warn('セッションデータの保存に失敗しました:', error)
+    }
+  }
+
+  private clearCurrentSession(): void {
+    this.currentSession = null
+    try {
+      localStorage.removeItem(StatisticsManager.SESSION_KEY)
+    } catch (error) {
+      console.warn('セッションデータの削除に失敗しました:', error)
+    }
+  }
+
+  // セッション開始
+  startSession(level: number = 1): void {
+    this.sessionStartTime = Date.now()
+    
+    this.currentSession = {
+      sessionId: `session_${this.sessionStartTime}`,
+      startTime: this.sessionStartTime,
+      score: 0,
+      level,
+      chainsCount: 0,
+      longestChain: 0,
+      puyoDropped: 0,
+      linesCleared: 0,
+      isCompleted: false
+    }
+    
+    this.saveCurrentSession()
+  }
+
+  // セッション終了
+  endSession(finalScore: number, completed: boolean = false): void {
+    if (!this.currentSession) return
+
+    const endTime = Date.now()
+    const sessionDuration = Math.floor((endTime - this.currentSession.startTime) / 1000)
+    
+    this.currentSession.endTime = endTime
+    this.currentSession.score = finalScore
+    this.currentSession.isCompleted = completed
+    
+    // 統計更新
+    this.updateStatisticsFromSession(this.currentSession, sessionDuration)
+    
+    // セッションをクリア
+    this.clearCurrentSession()
+  }
+
+  private updateStatisticsFromSession(session: SessionData, duration: number): void {
+    const today = new Date().toISOString().split('T')[0] // YYYY-MM-DD
+    const month = today.substring(0, 7) // YYYY-MM
+    
+    // 基本統計更新
+    this.statistics.totalGamesPlayed++
+    if (session.isCompleted) {
+      this.statistics.totalGamesWon++
+    }
+    
+    this.statistics.totalScore += session.score
+    this.statistics.highScore = Math.max(this.statistics.highScore, session.score)
+    this.statistics.averageScore = this.statistics.totalScore / this.statistics.totalGamesPlayed
+    
+    // プレイ時間統計
+    this.statistics.totalPlayTime += duration
+    this.statistics.longestSession = Math.max(this.statistics.longestSession, duration)
+    this.statistics.averageSessionTime = this.statistics.totalPlayTime / this.statistics.totalGamesPlayed
+    
+    // ぷよ統計
+    this.statistics.totalPuyoDropped += session.puyoDropped
+    this.statistics.totalLinesCleared += session.linesCleared
+    this.statistics.totalChainsMade += session.chainsCount
+    this.statistics.longestChain = Math.max(this.statistics.longestChain, session.longestChain)
+    
+    if (this.statistics.totalChainsMade > 0) {
+      // 平均チェーン長の計算は簡略化（実際にはより複雑な計算が必要）
+      this.statistics.averageChainLength = this.statistics.totalChainsMade / this.statistics.totalGamesPlayed
+    }
+    
+    // 効率統計
+    if (duration > 0) {
+      this.statistics.puyoPerMinute = (this.statistics.totalPuyoDropped / this.statistics.totalPlayTime) * 60
+    }
+    if (this.statistics.totalPuyoDropped > 0) {
+      this.statistics.scorePerPuyo = this.statistics.totalScore / this.statistics.totalPuyoDropped
+    }
+    
+    // 日付統計
+    if (!this.statistics.firstPlayDate) {
+      this.statistics.firstPlayDate = today
+    }
+    this.statistics.lastPlayDate = today
+    
+    // プレイした日数の計算（簡略化）
+    this.statistics.playDays = Math.max(this.statistics.playDays, 1)
+    
+    // レベル別統計
+    if (!this.statistics.levelStatistics[session.level]) {
+      this.statistics.levelStatistics[session.level] = {
+        gamesPlayed: 0,
+        bestScore: 0,
+        averageScore: 0,
+        totalPlayTime: 0
+      }
+    }
+    
+    const levelStats = this.statistics.levelStatistics[session.level]
+    levelStats.gamesPlayed++
+    levelStats.bestScore = Math.max(levelStats.bestScore, session.score)
+    levelStats.totalPlayTime += duration
+    levelStats.averageScore = (levelStats.averageScore * (levelStats.gamesPlayed - 1) + session.score) / levelStats.gamesPlayed
+    
+    // 月別統計
+    if (!this.statistics.monthlyStats[month]) {
+      this.statistics.monthlyStats[month] = {
+        gamesPlayed: 0,
+        totalScore: 0,
+        totalPlayTime: 0,
+        bestScore: 0
+      }
+    }
+    
+    const monthStats = this.statistics.monthlyStats[month]
+    monthStats.gamesPlayed++
+    monthStats.totalScore += session.score
+    monthStats.totalPlayTime += duration
+    monthStats.bestScore = Math.max(monthStats.bestScore, session.score)
+    
+    this.saveStatistics()
+  }
+
+  // セッション中の統計更新
+  updateSessionStats(data: {
+    score?: number
+    chainsCount?: number
+    longestChain?: number
+    puyoDropped?: number
+    linesCleared?: number
+  }): void {
+    if (!this.currentSession) return
+    
+    if (data.score !== undefined) {
+      this.currentSession.score = data.score
+    }
+    if (data.chainsCount !== undefined) {
+      this.currentSession.chainsCount = data.chainsCount
+    }
+    if (data.longestChain !== undefined) {
+      this.currentSession.longestChain = Math.max(this.currentSession.longestChain, data.longestChain)
+    }
+    if (data.puyoDropped !== undefined) {
+      this.currentSession.puyoDropped += data.puyoDropped
+    }
+    if (data.linesCleared !== undefined) {
+      this.currentSession.linesCleared += data.linesCleared
+    }
+    
+    this.saveCurrentSession()
+  }
+
+  // 統計データ取得
+  getStatistics(): GameStatistics {
+    return { ...this.statistics }
+  }
+
+  // 現在のセッション取得
+  getCurrentSession(): SessionData | null {
+    return this.currentSession ? { ...this.currentSession } : null
+  }
+
+  // 統計データリセット
+  resetStatistics(): void {
+    this.statistics = this.getDefaultStatistics()
+    this.saveStatistics()
+  }
+
+  // ランキング取得（スコア上位）
+  getHighScoreRanking(): Array<{ score: number; date: string; level: number }> {
+    // 実際の実装では、個々のゲーム記録を保存する必要がある
+    // ここでは簡略化して、現在のハイスコアのみを返す
+    if (this.statistics.highScore > 0) {
+      return [{
+        score: this.statistics.highScore,
+        date: this.statistics.lastPlayDate,
+        level: 1 // 簡略化
+      }]
+    }
+    return []
+  }
+
+  // 統計サマリー取得
+  getStatisticsSummary(): {
+    gamesPlayed: number
+    winRate: number
+    averageScore: number
+    totalPlayTime: string
+    favoriteLevel: number
+    bestMonth: string
+  } {
+    const winRate = this.statistics.totalGamesPlayed > 0 
+      ? (this.statistics.totalGamesWon / this.statistics.totalGamesPlayed) * 100 
+      : 0
+
+    const totalPlayTimeFormatted = this.formatDuration(this.statistics.totalPlayTime)
+    
+    // 最も多くプレイしたレベルを取得
+    let favoriteLevel = 1
+    let maxGames = 0
+    for (const [level, stats] of Object.entries(this.statistics.levelStatistics)) {
+      if (stats.gamesPlayed > maxGames) {
+        maxGames = stats.gamesPlayed
+        favoriteLevel = parseInt(level)
+      }
+    }
+    
+    // 最高スコアを記録した月を取得
+    let bestMonth = ''
+    let bestScore = 0
+    for (const [month, stats] of Object.entries(this.statistics.monthlyStats)) {
+      if (stats.bestScore > bestScore) {
+        bestScore = stats.bestScore
+        bestMonth = month
+      }
+    }
+    
+    return {
+      gamesPlayed: this.statistics.totalGamesPlayed,
+      winRate: Math.round(winRate),
+      averageScore: Math.round(this.statistics.averageScore),
+      totalPlayTime: totalPlayTimeFormatted,
+      favoriteLevel,
+      bestMonth
+    }
+  }
+
+  // 進捗データ取得（達成度など）
+  getProgressData(): {
+    achievements: Array<{
+      name: string
+      description: string
+      completed: boolean
+      progress: number
+      target: number
+    }>
+    milestones: Array<{
+      name: string
+      value: number
+      unit: string
+      rank: 'bronze' | 'silver' | 'gold' | 'platinum'
+    }>
+  } {
+    const achievements = [
+      {
+        name: '初心者',
+        description: '10ゲームプレイする',
+        completed: this.statistics.totalGamesPlayed >= 10,
+        progress: this.statistics.totalGamesPlayed,
+        target: 10
+      },
+      {
+        name: 'チェーンマスター',
+        description: '5チェーン以上を作る',
+        completed: this.statistics.longestChain >= 5,
+        progress: this.statistics.longestChain,
+        target: 5
+      },
+      {
+        name: '高得点',
+        description: '10,000点以上を獲得する',
+        completed: this.statistics.highScore >= 10000,
+        progress: this.statistics.highScore,
+        target: 10000
+      },
+      {
+        name: '継続は力なり',
+        description: '総プレイ時間1時間達成',
+        completed: this.statistics.totalPlayTime >= 3600,
+        progress: this.statistics.totalPlayTime,
+        target: 3600
+      }
+    ]
+
+    const milestones = []
+    
+    // スコアマイルストーン
+    if (this.statistics.highScore >= 50000) {
+      milestones.push({ name: 'ハイスコア', value: this.statistics.highScore, unit: '点', rank: 'platinum' as const })
+    } else if (this.statistics.highScore >= 25000) {
+      milestones.push({ name: 'ハイスコア', value: this.statistics.highScore, unit: '点', rank: 'gold' as const })
+    } else if (this.statistics.highScore >= 10000) {
+      milestones.push({ name: 'ハイスコア', value: this.statistics.highScore, unit: '点', rank: 'silver' as const })
+    } else if (this.statistics.highScore >= 5000) {
+      milestones.push({ name: 'ハイスコア', value: this.statistics.highScore, unit: '点', rank: 'bronze' as const })
+    }
+    
+    // チェーンマイルストーン
+    if (this.statistics.longestChain >= 10) {
+      milestones.push({ name: '最長チェーン', value: this.statistics.longestChain, unit: 'チェーン', rank: 'platinum' as const })
+    } else if (this.statistics.longestChain >= 7) {
+      milestones.push({ name: '最長チェーン', value: this.statistics.longestChain, unit: 'チェーン', rank: 'gold' as const })
+    } else if (this.statistics.longestChain >= 5) {
+      milestones.push({ name: '最長チェーン', value: this.statistics.longestChain, unit: 'チェーン', rank: 'silver' as const })
+    } else if (this.statistics.longestChain >= 3) {
+      milestones.push({ name: '最長チェーン', value: this.statistics.longestChain, unit: 'チェーン', rank: 'bronze' as const })
+    }
+
+    return { achievements, milestones }
+  }
+
+  private formatDuration(seconds: number): string {
+    if (seconds < 60) {
+      return `${seconds}秒`
+    } else if (seconds < 3600) {
+      const minutes = Math.floor(seconds / 60)
+      const remainingSeconds = seconds % 60
+      return remainingSeconds > 0 ? `${minutes}分${remainingSeconds}秒` : `${minutes}分`
+    } else {
+      const hours = Math.floor(seconds / 3600)
+      const remainingMinutes = Math.floor((seconds % 3600) / 60)
+      return remainingMinutes > 0 ? `${hours}時間${remainingMinutes}分` : `${hours}時間`
+    }
+  }
+
+  // 統計データエクスポート
+  exportStatistics(): string {
+    return JSON.stringify({
+      statistics: this.statistics,
+      exportDate: new Date().toISOString(),
+      version: '1.0'
+    }, null, 2)
+  }
+
+  // 統計データインポート
+  importStatistics(jsonString: string): boolean {
+    try {
+      const data = JSON.parse(jsonString)
+      
+      if (data.statistics && typeof data.statistics === 'object') {
+        // データ整合性チェック（基本的なもののみ）
+        const imported = { ...this.getDefaultStatistics(), ...data.statistics }
+        this.statistics = imported
+        this.saveStatistics()
+        return true
+      }
+      
+      return false
+    } catch (error) {
+      console.warn('統計データのインポートに失敗しました:', error)
+      return false
+    }
+  }
+}
+
+// グローバル統計マネージャー
+export const statisticsManager = new StatisticsManager()
\ No newline at end of file

```

