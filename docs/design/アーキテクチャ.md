# TypeScriptノベルゲーム - アーキテクチャ仕様書

## 概要

本アプリケーションは、TypeScript + Phaser3を基盤としたビジュアルノベルゲームエンジンです。  
モジュラー設計により、拡張性と保守性を重視した商用レベルのアーキテクチャを採用しています。

## システム全体構成

### レイヤー構成図

```plantuml
@startuml システムレイヤー構成

package "プレゼンテーション層" {
  [Web Browser]
  [HTML5 Canvas]
}

package "フレームワーク層" {
  [Phaser3 Engine]
  [Vite Build System]
}

package "アプリケーション層" {
  [Scene Manager]
  [Game Scenes]
}

package "ドメイン層" {
  [Story System]
  [Character System]
  [Effect System]
  [UI System]
  [Save System]
}

package "インフラストラクチャ層" {
  [Asset Manager]
  [Configuration]
  [TypeScript Types]
}

[Web Browser] --> [HTML5 Canvas]
[HTML5 Canvas] --> [Phaser3 Engine]
[Phaser3 Engine] --> [Scene Manager]
[Scene Manager] --> [Game Scenes]
[Game Scenes] --> [Story System]
[Game Scenes] --> [Character System]
[Game Scenes] --> [Effect System]
[Game Scenes] --> [UI System]
[Game Scenes] --> [Save System]
[Story System] --> [Asset Manager]
[Character System] --> [Asset Manager]
[Effect System] --> [Asset Manager]
[UI System] --> [Asset Manager]
[Save System] --> [Asset Manager]
[Asset Manager] --> [Configuration]
[Configuration] --> [TypeScript Types]

@enduml
```

## システム構成要素

### 1. コアアーキテクチャ

```plantuml
@startuml コア構成

package "Core Framework" {
  class PhaserGameConfig {
    - config: GameConfig
    + createGame(): Game
    + getConfig(): GameConfig
  }
  
  class "Main Entry Point" {
    + main.ts
  }
}

package "Scene Management" {
  class LoadingScene {
    + preload(): void
    + create(): void
  }
  
  class TitleScene {
    + create(): void
    + setupMenu(): void
  }
  
  class GameScene {
    + characterManager: CharacterManager
    + dialogueBox: DialogueBox
    + effectManager: EffectManager
    + backgroundManager: BackgroundManager
  }
  
  class ScenarioScene {
    + scenarioManager: ScenarioManager
    + characterManager: CharacterManager
    + backgroundManager: BackgroundManager
  }
  
  class TestScene {
    + runTests(): void
  }
}

PhaserGameConfig --> LoadingScene
PhaserGameConfig --> TitleScene  
PhaserGameConfig --> GameScene
PhaserGameConfig --> ScenarioScene
PhaserGameConfig --> TestScene

@enduml
```

### 2. ストーリーシステム

```plantuml
@startuml ストーリーシステム

package "Story Domain" {
  class ScenarioManager {
    - currentScenario: ScenarioData
    - currentSceneIndex: number
    - flags: Record<string, GameFlagValue>
    + loadScenario(data: ScenarioData): void
    + getCurrentScene(): SceneData
    + nextScene(): SceneData
    + processChoice(choiceIndex: number): void
    + evaluateConditions(conditions: Condition[]): boolean
    + setFlag(key: string, value: GameFlagValue): void
    + getFlag(key: string): GameFlagValue
    + save(): SaveData
    + load(saveData: SaveData): void
  }
  
  interface ScenarioData {
    + id: string
    + title: string
    + description: string
    + scenes: SceneData[]
  }
  
  interface SceneData {
    + id: string
    + dialogue: DialogueData[]
    + choices?: ChoiceData[]
    + background?: string
    + characters?: CharacterStateData[]
    + conditions?: Condition[]
    + effects?: EffectData[]
  }
  
  interface ChoiceData {
    + id: string
    + text: string
    + nextSceneId?: string
    + conditions?: Condition[]
    + effects?: EffectData[]
  }
}

ScenarioManager --> ScenarioData
ScenarioData --> SceneData
SceneData --> ChoiceData

@enduml
```

### 3. キャラクターシステム

```plantuml
@startuml キャラクターシステム

package "Character Domain" {
  class CharacterManager {
    - scene: Phaser.Scene
    - characters: Map<string, Character>
    - characterConfigs: Map<string, string[]>
    + registerCharacter(name: string, expressions: string[]): void
    + isRegistered(name: string): boolean
    + showCharacter(name: string, expression: string, position: Position): void
    + hideCharacter(name: string): void
    + showCharacterWithFadeIn(name: string, expression: string, position: Position): void
    + hideCharacterWithFadeOut(name: string): void
    + changeCharacterExpression(name: string, expression: string): void
    + moveCharacter(name: string, position: Position, duration?: number): void
    + getAllCharacters(): Character[]
    + clearAllCharacters(): void
  }
  
  class Character {
    - scene: Phaser.Scene
    - name: string
    - sprite: Phaser.GameObjects.Sprite
    - currentExpression: string
    - currentPosition: Position
    - isVisible: boolean
    + show(expression: string, position: Position): void
    + hide(): void
    + fadeIn(expression: string, position: Position, duration?: number): void
    + fadeOut(duration?: number): void
    + changeExpression(expression: string): void
    + move(position: Position, duration?: number): void
  }
  
  interface Position {
    + x: number
    + y: number
  }
  
  interface CharacterConfig {
    + name: string
    + expressions: string[]
    + defaultPosition: Position
  }
}

CharacterManager --> Character
Character --> Position
CharacterManager --> CharacterConfig

@enduml
```

### 4. エフェクトシステム

```plantuml
@startuml エフェクトシステム

package "Effect Domain" {
  class EffectManager {
    - scene: Phaser.Scene
    - activeTweens: Phaser.Tweens.Tween[]
    - activeOverlays: Phaser.GameObjects.Rectangle[]
    + flash(color: string, duration?: number): void
    + shake(intensity?: ShakeIntensity): void
    + fadeIn(duration?: number): void
    + fadeOut(duration?: number): void
    + screenOverlay(color: string, alpha?: number, duration?: number): void
    + clearAllEffects(): void
  }
  
  class BackgroundManager {
    - scene: Phaser.Scene
    - currentBackground: Phaser.GameObjects.Image
    + setBackground(backgroundKey: string): void
    + changeBackgroundWithFade(backgroundKey: string, duration?: number): void
    + clearBackground(): void
  }
  
  enum ShakeIntensity {
    LIGHT
    MEDIUM
    HEAVY
  }
  
  interface EffectData {
    + type: string
    + parameters: Record<string, any>
    + timing?: EffectTiming
  }
  
  interface EffectTiming {
    + delay?: number
    + duration?: number
  }
}

EffectManager --> ShakeIntensity
EffectManager --> EffectData
EffectData --> EffectTiming

@enduml
```

### 5. UIシステム

```plantuml
@startuml UIシステム

package "UI Domain" {
  class DialogueBox {
    - scene: Phaser.Scene
    - messages: string[]
    - backgroundBox: Phaser.GameObjects.Rectangle
    - textObject: Phaser.GameObjects.Text
    - speakerObject: Phaser.GameObjects.Text
    + isVisible: boolean
    + currentText: string
    + currentSpeaker: string
    + show(): void
    + hide(): void
    + setSpeaker(speaker: string): void
    + setMessages(messages: string[]): void
    + nextMessage(): boolean
    + isFinished(): boolean
  }
  
  class ChoicePanel {
    - scene: Phaser.Scene
    - choices: ChoiceButton[]
    - background: Phaser.GameObjects.Rectangle
    + showChoices(choices: ChoiceData[]): void
    + hideChoices(): void
    + onChoiceSelected(callback: (index: number) => void): void
  }
  
  class ChoiceButton {
    - scene: Phaser.Scene
    - button: Button
    - choiceData: ChoiceData
    + show(): void
    + hide(): void
    + onClick(callback: () => void): void
  }
  
  class Button {
    - scene: Phaser.Scene
    - background: Phaser.GameObjects.Rectangle
    - text: Phaser.GameObjects.Text
    + setText(text: string): void
    + setPosition(x: number, y: number): void
    + onClick(callback: () => void): void
    + setEnabled(enabled: boolean): void
  }
  
  class Menu {
    - scene: Phaser.Scene
    - buttons: Button[]
    + addMenuItem(item: MenuItem): void
    + show(): void
    + hide(): void
  }
  
  interface MenuItem {
    + text: string
    + action: () => void
  }
}

DialogueBox --> "uses" Button
ChoicePanel --> ChoiceButton
ChoiceButton --> Button
Menu --> Button
Menu --> MenuItem

@enduml
```

### 6. セーブシステム

```plantuml
@startuml セーブシステム

package "Save Domain" {
  class SaveManager {
    - saveSlots: Map<number, SaveData>
    + save(slotNumber: number, data: SaveData): void
    + load(slotNumber: number): SaveData
    + deleteSave(slotNumber: number): void
    + getSaveSlots(): SaveSlot[]
    + exportSave(slotNumber: number): string
    + importSave(slotNumber: number, data: string): void
  }
  
  interface SaveData {
    + scenarioId: string
    + currentSceneId: string
    + flags: Record<string, GameFlagValue>
    + timestamp: number
    + playerName?: string
    + gameVersion: string
  }
  
  interface SaveSlot {
    + slotNumber: number
    + saveData?: SaveData
    + isEmpty: boolean
  }
  
}

SaveManager --> SaveData
SaveManager --> SaveSlot
SaveData --> GameFlagValue

@enduml
```

## 設計パターンと原則

### 1. アーキテクチャパターン

- **Layered Architecture**: 明確な責務分離
- **Component-Based Architecture**: Phaser3の特性を活かした構成
- **Manager Pattern**: 各ドメインの責務を一元管理

### 2. 設計原則

- **Single Responsibility Principle**: 各クラスは単一の責務を持つ
- **Open/Closed Principle**: 拡張に対して開いており、修正に対して閉じている
- **Dependency Inversion Principle**: 抽象に依存し、具象に依存しない
- **Interface Segregation Principle**: 必要なインターフェースのみに依存

### 3. TypeScript活用

- **型安全性**: 完全な型定義によるコンパイル時エラー検出
- **インターフェース活用**: 契約の明確化
- **ジェネリクス**: 型パラメータによる再利用性向上

## データフロー

### ゲーム進行のメインフロー

```plantuml
@startuml ゲーム進行フロー

actor Player
participant TitleScene
participant ScenarioScene
participant ScenarioManager
participant CharacterManager
participant DialogueBox
participant EffectManager
participant BackgroundManager

Player -> TitleScene: ゲーム開始
TitleScene -> ScenarioScene: シーン遷移

ScenarioScene -> ScenarioManager: シナリオロード
ScenarioManager -> ScenarioScene: 初期シーンデータ

loop シーン進行
  ScenarioScene -> DialogueBox: ダイアログ表示
  ScenarioScene -> CharacterManager: キャラクター表示
  ScenarioScene -> BackgroundManager: 背景設定
  ScenarioScene -> EffectManager: エフェクト実行
  
  DialogueBox -> Player: テキスト表示
  Player -> DialogueBox: 入力（クリック/キー）
  
  alt 選択肢がある場合
    ScenarioScene -> ChoicePanel: 選択肢表示
    Player -> ChoicePanel: 選択
    ChoicePanel -> ScenarioManager: 選択処理
  end
  
  ScenarioManager -> ScenarioManager: フラグ更新
  ScenarioManager -> ScenarioScene: 次シーンデータ
end

@enduml
```

### システム初期化フロー

```plantuml
@startuml システム初期化

participant Main
participant PhaserGameConfig
participant LoadingScene
participant AssetManager

Main -> PhaserGameConfig: ゲーム設定作成
PhaserGameConfig -> LoadingScene: シーン登録

LoadingScene -> AssetManager: アセット読み込み開始

loop 各アセット
  AssetManager -> AssetManager: リソース読み込み
  AssetManager -> LoadingScene: 進捗更新
end

AssetManager -> LoadingScene: 読み込み完了
LoadingScene -> TitleScene: シーン遷移

@enduml
```

## テクノロジースタック

### フロントエンド

| カテゴリ | 技術 | バージョン | 役割 |
|----------|------|------------|------|
| 言語 | TypeScript | 5.x | 型安全なJavaScript |
| ゲームエンジン | Phaser3 | 3.x | 2Dゲーム開発フレームワーク |
| ビルドツール | Vite | 5.x | 高速開発サーバー・ビルド |
| テストフレームワーク | Vitest | 3.x | ユニットテスト |
| リンター | ESLint | 9.x | コード品質検査 |
| フォーマッター | Prettier | 3.x | コード整形 |
| タスクランナー | Gulp | 5.x | 開発タスク自動化 |

### 開発・運用

| カテゴリ | 技術 | 役割 |
|----------|------|------|
| バージョン管理 | Git | ソースコード管理 |
| パッケージ管理 | npm | 依存関係管理 |
| 開発環境 | Docker + Dev Container | 統一開発環境 |
| ドキュメント | MkDocs | ドキュメント生成 |

## パフォーマンス考慮事項

### 1. アセット管理

- **遅延読み込み**: 必要時のみアセット読み込み
- **テクスチャアトラス**: 描画パフォーマンス向上
- **オーディオ圧縮**: ファイルサイズ最適化

### 2. メモリ管理

- **オブジェクトプール**: 頻繁な生成・破棄の回避
- **適切な破棄処理**: メモリリーク防止
- **参照管理**: 循環参照の回避

### 3. レンダリング最適化

- **レイヤー分離**: 更新頻度による描画最適化
- **カリング**: 画面外オブジェクトの描画スキップ
- **バッチング**: 描画コール数の削減

## セキュリティ考慮事項

### 1. データ保護

- **セーブデータ整合性**: チェックサム検証
- **不正データ防止**: 入力値検証
- **XSS対策**: ユーザー入力のサニタイズ

### 2. アセット保護

- **難読化**: コードの可読性低下
- **整合性チェック**: アセット改ざん検出

## 拡張ポイント

### 1. 新機能追加

- **プラグインシステム**: 独立したモジュールとして機能追加
- **カスタムエフェクト**: EffectManagerの拡張
- **新UIコンポーネント**: UI層への追加

### 2. データ形式拡張

- **シナリオフォーマット**: 新たなストーリー表現
- **キャラクター設定**: より詳細な属性管理
- **選択肢システム**: 複雑な分岐制御

### 3. プラットフォーム対応

- **マルチプラットフォーム**: Electron等での展開
- **モバイル対応**: タッチインターフェース最適化
- **VR対応**: 没入体験の実現

## 品質保証

### 1. テスト戦略

- **ユニットテスト**: 個別モジュールのテスト（273テスト）
- **統合テスト**: システム連携のテスト
- **E2Eテスト**: エンドユーザー視点のテスト

### 2. コード品質

- **ESLint**: 静的解析によるコード品質向上
- **Prettier**: 一貫したコードフォーマット
- **TypeScript**: 型システムによる安全性確保

### 3. 継続的インテグレーション

- **自動テスト**: コミット時の品質チェック
- **自動ビルド**: デプロイ可能な成果物生成
- **品質メトリクス**: コードカバレッジ・複雑度測定

## 運用考慮事項

### 1. デプロイメント

- **静的サイト**: GitHub Pages, Netlify等での配信
- **CDN活用**: アセット配信の高速化
- **キャッシュ戦略**: ブラウザキャッシュ最適化

### 2. 監視・メンテナンス

- **エラー追跡**: 実行時エラーの監視
- **パフォーマンス計測**: フレームレート・読み込み時間
- **ユーザーフィードバック**: プレイデータ分析

## 今後の発展

### 短期目標（次イテレーション）

1. **CI/CDパイプライン構築**: 自動テスト・デプロイ
2. **シナリオエディター**: GUI-based story creation tool
3. **音響システム**: BGM・SE統合管理
4. **セーブ機能完全実装**: クラウドセーブ対応

### 中期目標（3-6ヶ月）

1. **マルチプラットフォーム対応**: Desktop/Mobile
2. **アニメーションシステム**: キャラクター動作
3. **ボイス対応**: 音声データ統合
4. **国際化対応**: 多言語サポート

### 長期目標（6ヶ月以上）

1. **AI統合**: 動的ストーリー生成
2. **VR対応**: 没入型体験
3. **商用エンジン化**: 一般開発者向けツール
4. **クラウドサービス化**: SaaS型提供

---

本アーキテクチャは、現在の商用レベル品質を維持しながら、将来の拡張性を確保したモジュラー設計です。各システムが疎結合で設計されており、個別の改良・拡張が容易な構造となっています。
